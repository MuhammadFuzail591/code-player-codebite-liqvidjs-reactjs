/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompletionContext: () => (/* binding */ CompletionContext),
/* harmony export */   acceptCompletion: () => (/* binding */ acceptCompletion),
/* harmony export */   autocompletion: () => (/* binding */ autocompletion),
/* harmony export */   clearSnippet: () => (/* binding */ clearSnippet),
/* harmony export */   closeBrackets: () => (/* binding */ closeBrackets),
/* harmony export */   closeBracketsKeymap: () => (/* binding */ closeBracketsKeymap),
/* harmony export */   closeCompletion: () => (/* binding */ closeCompletion),
/* harmony export */   completeAnyWord: () => (/* binding */ completeAnyWord),
/* harmony export */   completeFromList: () => (/* binding */ completeFromList),
/* harmony export */   completionKeymap: () => (/* binding */ completionKeymap),
/* harmony export */   completionStatus: () => (/* binding */ completionStatus),
/* harmony export */   currentCompletions: () => (/* binding */ currentCompletions),
/* harmony export */   deleteBracketPair: () => (/* binding */ deleteBracketPair),
/* harmony export */   hasNextSnippetField: () => (/* binding */ hasNextSnippetField),
/* harmony export */   hasPrevSnippetField: () => (/* binding */ hasPrevSnippetField),
/* harmony export */   ifIn: () => (/* binding */ ifIn),
/* harmony export */   ifNotIn: () => (/* binding */ ifNotIn),
/* harmony export */   insertBracket: () => (/* binding */ insertBracket),
/* harmony export */   insertCompletionText: () => (/* binding */ insertCompletionText),
/* harmony export */   moveCompletionSelection: () => (/* binding */ moveCompletionSelection),
/* harmony export */   nextSnippetField: () => (/* binding */ nextSnippetField),
/* harmony export */   pickedCompletion: () => (/* binding */ pickedCompletion),
/* harmony export */   prevSnippetField: () => (/* binding */ prevSnippetField),
/* harmony export */   selectedCompletion: () => (/* binding */ selectedCompletion),
/* harmony export */   selectedCompletionIndex: () => (/* binding */ selectedCompletionIndex),
/* harmony export */   setSelectedCompletion: () => (/* binding */ setSelectedCompletion),
/* harmony export */   snippet: () => (/* binding */ snippet),
/* harmony export */   snippetCompletion: () => (/* binding */ snippetCompletion),
/* harmony export */   snippetKeymap: () => (/* binding */ snippetKeymap),
/* harmony export */   startCompletion: () => (/* binding */ startCompletion)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.js");



class CompletionContext {
    constructor(state, pos, explicit, view) {
        this.state = state;
        this.pos = pos;
        this.explicit = explicit;
        this.view = view;
        this.abortListeners = [];
        this.abortOnDocChange = false;
    }
    tokenBefore(types) {
        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);
        while (token && types.indexOf(token.name) < 0)
            token = token.parent;
        return token ? { from: token.from, to: this.pos,
            text: this.state.sliceDoc(token.from, this.pos),
            type: token.type } : null;
    }
    matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos);
        let start = Math.max(line.from, this.pos - 250);
        let str = line.text.slice(start - line.from, this.pos - line.from);
        let found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
    }
    get aborted() { return this.abortListeners == null; }
    addEventListener(type, listener, options) {
        if (type == "abort" && this.abortListeners) {
            this.abortListeners.push(listener);
            if (options && options.onDocChange)
                this.abortOnDocChange = true;
        }
    }
}
function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
        flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
    let first = Object.create(null), rest = Object.create(null);
    for (let { label } of options) {
        first[label[0]] = true;
        for (let i = 1; i < label.length; i++)
            rest[label[i]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
    let options = list.map(o => typeof o == "string" ? { label: o } : o);
    let [validFor, match] = options.every(o => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
    return (context) => {
        let token = context.matchBefore(match);
        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
    };
}
function ifIn(nodes, source) {
    return (context) => {
        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
            if (nodes.indexOf(pos.name) > -1)
                return source(context);
            if (pos.type.isTop)
                break;
        }
        return null;
    };
}
function ifNotIn(nodes, source) {
    return (context) => {
        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
            if (nodes.indexOf(pos.name) > -1)
                return null;
            if (pos.type.isTop)
                break;
        }
        return source(context);
    };
}
class Option {
    constructor(completion, source, match, score) {
        this.completion = completion;
        this.source = source;
        this.match = match;
        this.score = score;
    }
}
function cur(state) { return state.selection.main.from; }
function ensureAnchor(expr, start) {
    var _a;
    let { source } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
        return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? "i" : ""));
}
const pickedCompletion = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();
function insertCompletionText(state, text, from, to) {
    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
    return Object.assign(Object.assign({}, state.changeByRange(range => {
        if (range != main && from != to &&
            state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
            return { range };
        let lines = state.toText(text);
        return {
            changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + lines.length)
        };
    })), { scrollIntoView: true, userEvent: "input.complete" });
}
const SourceCache = new WeakMap();
function asSource(source) {
    if (!Array.isArray(source))
        return source;
    let known = SourceCache.get(source);
    if (!known)
        SourceCache.set(source, known = completeFromList(source));
    return known;
}
const startCompletionEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const closeCompletionEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
class FuzzyMatcher {
    constructor(pattern) {
        this.pattern = pattern;
        this.chars = [];
        this.folded = [];
        this.any = [];
        this.precise = [];
        this.byWord = [];
        this.score = 0;
        this.matched = [];
        for (let p = 0; p < pattern.length;) {
            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);
            this.chars.push(char);
            let part = pattern.slice(p, p + size), upper = part.toUpperCase();
            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));
            p += size;
        }
        this.astral = pattern.length != this.chars.length;
    }
    ret(score, matched) {
        this.score = score;
        this.matched = matched;
        return this;
    }
    match(word) {
        if (this.pattern.length == 0)
            return this.ret(-100, []);
        if (word.length < this.pattern.length)
            return null;
        let { chars, folded, any, precise, byWord } = this;
        if (chars.length == 1) {
            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);
            let score = firstSize == word.length ? 0 : -100;
            if (first == chars[0])
                ;
            else if (first == folded[0])
                score += -200;
            else
                return null;
            return this.ret(score, [0, firstSize]);
        }
        let direct = word.indexOf(this.pattern);
        if (direct == 0)
            return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
        let len = chars.length, anyTo = 0;
        if (direct < 0) {
            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);
                if (next == chars[anyTo] || next == folded[anyTo])
                    any[anyTo++] = i;
                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);
            }
            if (anyTo < len)
                return null;
        }
        let preciseTo = 0;
        let byWordTo = 0, byWordFolded = false;
        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
        let hasLower = /[a-z]/.test(word), wordAdjacent = true;
        for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len;) {
            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);
            if (direct < 0) {
                if (preciseTo < len && next == chars[preciseTo])
                    precise[preciseTo++] = i;
                if (adjacentTo < len) {
                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                        if (adjacentTo == 0)
                            adjacentStart = i;
                        adjacentEnd = i + 1;
                        adjacentTo++;
                    }
                    else {
                        adjacentTo = 0;
                    }
                }
            }
            let ch, type = next < 0xff
                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0)
                : ((ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0);
            if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
                if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))
                    byWord[byWordTo++] = i;
                else if (byWord.length)
                    wordAdjacent = false;
            }
            prevType = type;
            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
            return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0)
            return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
        if (direct > -1)
            return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
        if (adjacentTo == len)
            return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
        if (byWordTo == len)
            return this.result(-100 + (byWordFolded ? -200 : 0) + -700 +
                (wordAdjacent ? 0 : -1100), byWord, word);
        return chars.length == 2 ? null
            : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
    }
    result(score, positions, word) {
        let result = [], i = 0;
        for (let pos of positions) {
            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);
            if (i && result[i - 1] == pos)
                result[i - 1] = to;
            else {
                result[i++] = pos;
                result[i++] = to;
            }
        }
        return this.ret(score - word.length, result);
    }
}
class StrictMatcher {
    constructor(pattern) {
        this.pattern = pattern;
        this.matched = [];
        this.score = 0;
        this.folded = pattern.toLowerCase();
    }
    match(word) {
        if (word.length < this.pattern.length)
            return null;
        let start = word.slice(0, this.pattern.length);
        let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
        if (match == null)
            return null;
        this.matched = [0, start.length];
        this.score = match + (word.length == this.pattern.length ? 0 : -100);
        return this;
    }
}
const completionConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {
            activateOnTyping: true,
            activateOnCompletion: () => false,
            activateOnTypingDelay: 100,
            selectOnOpen: true,
            override: null,
            closeOnBlur: true,
            maxRenderedOptions: 100,
            defaultKeymap: true,
            tooltipClass: () => "",
            optionClass: () => "",
            aboveCursor: false,
            icons: true,
            addToOptions: [],
            positionInfo: defaultPositionInfo,
            filterStrict: false,
            compareCompletions: (a, b) => a.label.localeCompare(b.label),
            interactionDelay: 75,
            updateSyncTime: 100
        }, {
            defaultKeymap: (a, b) => a && b,
            closeOnBlur: (a, b) => a && b,
            icons: (a, b) => a && b,
            tooltipClass: (a, b) => c => joinClass(a(c), b(c)),
            optionClass: (a, b) => c => joinClass(a(c), b(c)),
            addToOptions: (a, b) => a.concat(b),
            filterStrict: (a, b) => a || b,
        });
    }
});
function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
}
function defaultPositionInfo(view, list, option, info, space, tooltip) {
    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;
    let side = "top", offset, maxWidth;
    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
    if (left && spaceLeft < Math.min(infoWidth, spaceRight))
        left = false;
    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
        left = true;
    if (infoWidth <= (left ? spaceLeft : spaceRight)) {
        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
        maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
    }
    else {
        narrow = true;
        maxWidth = Math.min(400, (rtl ? list.right : space.right - list.left) - 30);
        let spaceBelow = space.bottom - list.bottom;
        if (spaceBelow >= infoHeight || spaceBelow > list.top) {
            offset = option.bottom - list.top;
        }
        else {
            side = "bottom";
            offset = list.bottom - option.top;
        }
    }
    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
    let scaleX = (list.right - list.left) / tooltip.offsetWidth;
    return {
        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
        class: "cm-completionInfo-" + (narrow ? (rtl ? "left-narrow" : "right-narrow") : left ? "left" : "right")
    };
}
function optionContent(config) {
    let content = config.addToOptions.slice();
    if (config.icons)
        content.push({
            render(completion) {
                let icon = document.createElement("div");
                icon.classList.add("cm-completionIcon");
                if (completion.type)
                    icon.classList.add(...completion.type.split(/\s+/g).map(cls => "cm-completionIcon-" + cls));
                icon.setAttribute("aria-hidden", "true");
                return icon;
            },
            position: 20
        });
    content.push({
        render(completion, _s, _v, match) {
            let labelElt = document.createElement("span");
            labelElt.className = "cm-completionLabel";
            let label = completion.displayLabel || completion.label, off = 0;
            for (let j = 0; j < match.length;) {
                let from = match[j++], to = match[j++];
                if (from > off)
                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));
                let span = labelElt.appendChild(document.createElement("span"));
                span.appendChild(document.createTextNode(label.slice(from, to)));
                span.className = "cm-completionMatchedText";
                off = to;
            }
            if (off < label.length)
                labelElt.appendChild(document.createTextNode(label.slice(off)));
            return labelElt;
        },
        position: 50
    }, {
        render(completion) {
            if (!completion.detail)
                return null;
            let detailElt = document.createElement("span");
            detailElt.className = "cm-completionDetail";
            detailElt.textContent = completion.detail;
            return detailElt;
        },
        position: 80
    });
    return content.sort((a, b) => a.position - b.position).map(a => a.render);
}
function rangeAroundSelected(total, selected, max) {
    if (total <= max)
        return { from: 0, to: total };
    if (selected < 0)
        selected = 0;
    if (selected <= (total >> 1)) {
        let off = Math.floor(selected / max);
        return { from: off * max, to: (off + 1) * max };
    }
    let off = Math.floor((total - selected) / max);
    return { from: total - (off + 1) * max, to: total - off * max };
}
class CompletionTooltip {
    constructor(view, stateField, applyCompletion) {
        this.view = view;
        this.stateField = stateField;
        this.applyCompletion = applyCompletion;
        this.info = null;
        this.infoDestroy = null;
        this.placeInfoReq = {
            read: () => this.measureInfo(),
            write: (pos) => this.placeInfo(pos),
            key: this
        };
        this.space = null;
        this.currentClass = "";
        let cState = view.state.field(stateField);
        let { options, selected } = cState.open;
        let config = view.state.facet(completionConfig);
        this.optionContent = optionContent(config);
        this.optionClass = config.optionClass;
        this.tooltipClass = config.tooltipClass;
        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
        this.dom = document.createElement("div");
        this.dom.className = "cm-tooltip-autocomplete";
        this.updateTooltipClass(view.state);
        this.dom.addEventListener("mousedown", (e) => {
            let { options } = view.state.field(stateField).open;
            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
                if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                    this.applyCompletion(view, options[+match[1]]);
                    e.preventDefault();
                    return;
                }
            }
        });
        this.dom.addEventListener("focusout", (e) => {
            let state = view.state.field(this.stateField, false);
            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur &&
                e.relatedTarget != view.contentDOM)
                view.dispatch({ effects: closeCompletionEffect.of(null) });
        });
        this.showOptions(options, cState.id);
    }
    mount() { this.updateSel(); }
    showOptions(options, id) {
        if (this.list)
            this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));
        this.list.addEventListener("scroll", () => {
            if (this.info)
                this.view.requestMeasure(this.placeInfoReq);
        });
    }
    update(update) {
        var _a;
        let cState = update.state.field(this.stateField);
        let prevState = update.startState.field(this.stateField);
        this.updateTooltipClass(update.state);
        if (cState != prevState) {
            let { options, selected, disabled } = cState.open;
            if (!prevState.open || prevState.open.options != options) {
                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
                this.showOptions(options, cState.id);
            }
            this.updateSel();
            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled))
                this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
        }
    }
    updateTooltipClass(state) {
        let cls = this.tooltipClass(state);
        if (cls != this.currentClass) {
            for (let c of this.currentClass.split(" "))
                if (c)
                    this.dom.classList.remove(c);
            for (let c of cls.split(" "))
                if (c)
                    this.dom.classList.add(c);
            this.currentClass = cls;
        }
    }
    positioned(space) {
        this.space = space;
        if (this.info)
            this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
        let cState = this.view.state.field(this.stateField), open = cState.open;
        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
            this.showOptions(open.options, cState.id);
        }
        if (this.updateSelectedOption(open.selected)) {
            this.destroyInfo();
            let { completion } = open.options[open.selected];
            let { info } = completion;
            if (!info)
                return;
            let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
            if (!infoResult)
                return;
            if ("then" in infoResult) {
                infoResult.then(obj => {
                    if (obj && this.view.state.field(this.stateField, false) == cState)
                        this.addInfoPane(obj, completion);
                }).catch(e => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, "completion info"));
            }
            else {
                this.addInfoPane(infoResult, completion);
            }
        }
    }
    addInfoPane(content, completion) {
        this.destroyInfo();
        let wrap = this.info = document.createElement("div");
        wrap.className = "cm-tooltip cm-completionInfo";
        if (content.nodeType != null) {
            wrap.appendChild(content);
            this.infoDestroy = null;
        }
        else {
            let { dom, destroy } = content;
            wrap.appendChild(dom);
            this.infoDestroy = destroy || null;
        }
        this.dom.appendChild(wrap);
        this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(selected) {
        let set = null;
        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
            if (opt.nodeName != "LI" || !opt.id) {
                i--;
            }
            else if (i == selected) {
                if (!opt.hasAttribute("aria-selected")) {
                    opt.setAttribute("aria-selected", "true");
                    set = opt;
                }
            }
            else {
                if (opt.hasAttribute("aria-selected"))
                    opt.removeAttribute("aria-selected");
            }
        }
        if (set)
            scrollIntoView(this.list, set);
        return set;
    }
    measureInfo() {
        let sel = this.dom.querySelector("[aria-selected]");
        if (!sel || !this.info)
            return null;
        let listRect = this.dom.getBoundingClientRect();
        let infoRect = this.info.getBoundingClientRect();
        let selRect = sel.getBoundingClientRect();
        let space = this.space;
        if (!space) {
            let docElt = this.dom.ownerDocument.documentElement;
            space = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
        }
        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||
            selRect.bottom < Math.max(space.top, listRect.top) + 10)
            return null;
        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
    }
    placeInfo(pos) {
        if (this.info) {
            if (pos) {
                if (pos.style)
                    this.info.style.cssText = pos.style;
                this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
            }
            else {
                this.info.style.cssText = "top: -1e6px";
            }
        }
    }
    createListBox(options, id, range) {
        const ul = document.createElement("ul");
        ul.id = id;
        ul.setAttribute("role", "listbox");
        ul.setAttribute("aria-expanded", "true");
        ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
        ul.addEventListener("mousedown", e => {
            if (e.target == ul)
                e.preventDefault();
        });
        let curSection = null;
        for (let i = range.from; i < range.to; i++) {
            let { completion, match } = options[i], { section } = completion;
            if (section) {
                let name = typeof section == "string" ? section : section.name;
                if (name != curSection && (i > range.from || range.from == 0)) {
                    curSection = name;
                    if (typeof section != "string" && section.header) {
                        ul.appendChild(section.header(section));
                    }
                    else {
                        let header = ul.appendChild(document.createElement("completion-section"));
                        header.textContent = name;
                    }
                }
            }
            const li = ul.appendChild(document.createElement("li"));
            li.id = id + "-" + i;
            li.setAttribute("role", "option");
            let cls = this.optionClass(completion);
            if (cls)
                li.className = cls;
            for (let source of this.optionContent) {
                let node = source(completion, this.view.state, this.view, match);
                if (node)
                    li.appendChild(node);
            }
        }
        if (range.from)
            ul.classList.add("cm-completionListIncompleteTop");
        if (range.to < options.length)
            ul.classList.add("cm-completionListIncompleteBottom");
        return ul;
    }
    destroyInfo() {
        if (this.info) {
            if (this.infoDestroy)
                this.infoDestroy();
            this.info.remove();
            this.info = null;
        }
    }
    destroy() {
        this.destroyInfo();
    }
}
function completionTooltip(stateField, applyCompletion) {
    return (view) => new CompletionTooltip(view, stateField, applyCompletion);
}
function scrollIntoView(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    let scaleY = parent.height / container.offsetHeight;
    if (self.top < parent.top)
        container.scrollTop -= (parent.top - self.top) / scaleY;
    else if (self.bottom > parent.bottom)
        container.scrollTop += (self.bottom - parent.bottom) / scaleY;
}
function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +
        (option.type ? 1 : 0);
}
function sortOptions(active, state) {
    let options = [];
    let sections = null;
    let addOption = (option) => {
        options.push(option);
        let { section } = option.completion;
        if (section) {
            if (!sections)
                sections = [];
            let name = typeof section == "string" ? section : section.name;
            if (!sections.some(s => s.name == name))
                sections.push(typeof section == "string" ? { name } : section);
        }
    };
    let conf = state.facet(completionConfig);
    for (let a of active)
        if (a.hasResult()) {
            let getMatch = a.result.getMatch;
            if (a.result.filter === false) {
                for (let option of a.result.options) {
                    addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
                }
            }
            else {
                let pattern = state.sliceDoc(a.from, a.to), match;
                let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
                for (let option of a.result.options)
                    if (match = matcher.match(option.label)) {
                        let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
                        addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));
                    }
            }
        }
    if (sections) {
        let sectionOrder = Object.create(null), pos = 0;
        let cmp = (a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1); };
        for (let s of sections.sort(cmp)) {
            pos -= 1e5;
            sectionOrder[s.name] = pos;
        }
        for (let option of options) {
            let { section } = option.completion;
            if (section)
                option.score += sectionOrder[typeof section == "string" ? section : section.name];
        }
    }
    let result = [], prev = null;
    let compare = conf.compareCompletions;
    for (let opt of options.sort((a, b) => (b.score - a.score) || compare(a.completion, b.completion))) {
        let cur = opt.completion;
        if (!prev || prev.label != cur.label || prev.detail != cur.detail ||
            (prev.type != null && cur.type != null && prev.type != cur.type) ||
            prev.apply != cur.apply || prev.boost != cur.boost)
            result.push(opt);
        else if (score(opt.completion) > score(prev))
            result[result.length - 1] = opt;
        prev = opt.completion;
    }
    return result;
}
class CompletionDialog {
    constructor(options, attrs, tooltip, timestamp, selected, disabled) {
        this.options = options;
        this.attrs = attrs;
        this.tooltip = tooltip;
        this.timestamp = timestamp;
        this.selected = selected;
        this.disabled = disabled;
    }
    setSelected(selected, id) {
        return selected == this.selected || selected >= this.options.length ? this
            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id, prev, conf, didSetActive) {
        if (prev && !didSetActive && active.some(s => s.isPending))
            return prev.setDisabled();
        let options = sortOptions(active, state);
        if (!options.length)
            return prev && active.some(a => a.isPending) ? prev.setDisabled() : null;
        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
        if (prev && prev.selected != selected && prev.selected != -1) {
            let selectedValue = prev.options[prev.selected].completion;
            for (let i = 0; i < options.length; i++)
                if (options[i].completion == selectedValue) {
                    selected = i;
                    break;
                }
        }
        return new CompletionDialog(options, makeAttrs(id, selected), {
            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
            create: createTooltip,
            above: conf.aboveCursor,
        }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
    }
    setDisabled() {
        return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
    }
}
class CompletionState {
    constructor(active, id, open) {
        this.active = active;
        this.id = id;
        this.open = open;
    }
    static start() {
        return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
        let { state } = tr, conf = state.facet(completionConfig);
        let sources = conf.override ||
            state.languageDataAt("autocomplete", cur(state)).map(asSource);
        let active = sources.map(source => {
            let value = this.active.find(s => s.source == source) ||
                new ActiveSource(source, this.active.some(a => a.state != 0) ? 1 : 0);
            return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
            active = this.active;
        let open = this.open, didSet = tr.effects.some(e => e.is(setActiveEffect));
        if (open && tr.docChanged)
            open = open.map(tr.changes);
        if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||
            !sameResults(active, this.active) || didSet)
            open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
        else if (open && open.disabled && !active.some(a => a.isPending))
            open = null;
        if (!open && active.every(a => !a.isPending) && active.some(a => a.hasResult()))
            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0) : a);
        for (let effect of tr.effects)
            if (effect.is(setSelectedEffect))
                open = open && open.setSelected(effect.value, this.id);
        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() { return this.open ? this.open.tooltip : null; }
    get attrs() { return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs; }
}
function sameResults(a, b) {
    if (a == b)
        return true;
    for (let iA = 0, iB = 0;;) {
        while (iA < a.length && !a[iA].hasResult())
            iA++;
        while (iB < b.length && !b[iB].hasResult())
            iB++;
        let endA = iA == a.length, endB = iB == b.length;
        if (endA || endB)
            return endA == endB;
        if (a[iA++].result != b[iB++].result)
            return false;
    }
}
const baseAttrs = {
    "aria-autocomplete": "list"
};
const noAttrs = {};
function makeAttrs(id, selected) {
    let result = {
        "aria-autocomplete": "list",
        "aria-haspopup": "listbox",
        "aria-controls": id
    };
    if (selected > -1)
        result["aria-activedescendant"] = id + "-" + selected;
    return result;
}
const none = [];
function getUpdateType(tr, conf) {
    if (tr.isUserEvent("input.complete")) {
        let completion = tr.annotation(pickedCompletion);
        if (completion && conf.activateOnCompletion(completion))
            return 4 | 8;
    }
    let typing = tr.isUserEvent("input.type");
    return typing && conf.activateOnTyping ? 4 | 1
        : typing ? 1
            : tr.isUserEvent("delete.backward") ? 2
                : tr.selection ? 8
                    : tr.docChanged ? 16 : 0;
}
class ActiveSource {
    constructor(source, state, explicit = false) {
        this.source = source;
        this.state = state;
        this.explicit = explicit;
    }
    hasResult() { return false; }
    get isPending() { return this.state == 1; }
    update(tr, conf) {
        let type = getUpdateType(tr, conf), value = this;
        if ((type & 8) || (type & 16) && this.touches(tr))
            value = new ActiveSource(value.source, 0);
        if ((type & 4) && value.state == 0)
            value = new ActiveSource(this.source, 1);
        value = value.updateFor(tr, type);
        for (let effect of tr.effects) {
            if (effect.is(startCompletionEffect))
                value = new ActiveSource(value.source, 1, effect.value);
            else if (effect.is(closeCompletionEffect))
                value = new ActiveSource(value.source, 0);
            else if (effect.is(setActiveEffect))
                for (let active of effect.value)
                    if (active.source == value.source)
                        value = active;
        }
        return value;
    }
    updateFor(tr, type) { return this.map(tr.changes); }
    map(changes) { return this; }
    touches(tr) {
        return tr.changes.touchesRange(cur(tr.state));
    }
}
class ActiveResult extends ActiveSource {
    constructor(source, explicit, limit, result, from, to) {
        super(source, 3, explicit);
        this.limit = limit;
        this.result = result;
        this.from = from;
        this.to = to;
    }
    hasResult() { return true; }
    updateFor(tr, type) {
        var _a;
        if (!(type & 3))
            return this.map(tr.changes);
        let result = this.result;
        if (result.map && !tr.changes.empty)
            result = result.map(result, tr.changes);
        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
        let pos = cur(tr.state);
        if (pos > to || !result ||
            (type & 2) && (cur(tr.startState) == this.from || pos < this.limit))
            return new ActiveSource(this.source, type & 4 ? 1 : 0);
        let limit = tr.changes.mapPos(this.limit);
        if (checkValid(result.validFor, tr.state, from, to))
            return new ActiveResult(this.source, this.explicit, limit, result, from, to);
        if (result.update &&
            (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
            return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));
        return new ActiveSource(this.source, 1, this.explicit);
    }
    map(mapping) {
        if (mapping.empty)
            return this;
        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
        if (!result)
            return new ActiveSource(this.source, 0);
        return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
    touches(tr) {
        return tr.changes.touchesRange(this.from, this.to);
    }
}
function checkValid(validFor, state, from, to) {
    if (!validFor)
        return false;
    let text = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
const setActiveEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({
    map(sources, mapping) { return sources.map(s => s.map(mapping)); }
});
const setSelectedEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const completionState = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() { return CompletionState.start(); },
    update(value, tr) { return value.update(tr); },
    provide: f => [
        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, val => val.tooltip),
        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, state => state.attrs)
    ]
});
function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = view.state.field(completionState).active.find(a => a.source == option.source);
    if (!(result instanceof ActiveResult))
        return false;
    if (typeof apply == "string")
        view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
    else
        apply(view, option.completion, result.from, result.to);
    return true;
}
const createTooltip = completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
    return (view) => {
        let cState = view.state.field(completionState, false);
        if (!cState || !cState.open || cState.open.disabled ||
            Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
            return false;
        let step = 1, tooltip;
        if (by == "page" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip)))
            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /
                tooltip.dom.querySelector("li").offsetHeight) - 1);
        let { length } = cState.open.options;
        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
        if (selected < 0)
            selected = by == "page" ? 0 : length - 1;
        else if (selected >= length)
            selected = by == "page" ? length - 1 : 0;
        view.dispatch({ effects: setSelectedEffect.of(selected) });
        return true;
    };
}
const acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled ||
        Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
    return applyCompletion(view, cState.open.options[cState.open.selected]);
};
const startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
        return false;
    view.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
};
const closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some(a => a.state != 0))
        return false;
    view.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
};
class RunningQuery {
    constructor(active, context) {
        this.active = active;
        this.context = context;
        this.time = Date.now();
        this.updates = [];
        this.done = undefined;
    }
}
const MaxUpdateCount = 50, MinAbortTime = 1000;
const completionPlugin = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.debounceUpdate = -1;
        this.running = [];
        this.debounceAccept = -1;
        this.pendingStart = false;
        this.composing = 0;
        for (let active of view.state.field(completionState).active)
            if (active.isPending)
                this.startQuery(active);
    }
    update(update) {
        let cState = update.state.field(completionState);
        let conf = update.state.facet(completionConfig);
        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
            return;
        let doesReset = update.transactions.some(tr => {
            let type = getUpdateType(tr, conf);
            return (type & 8) || (tr.selection || tr.docChanged) && !(type & 3);
        });
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (doesReset ||
                query.context.abortOnDocChange && update.docChanged ||
                query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
                for (let handler of query.context.abortListeners) {
                    try {
                        handler();
                    }
                    catch (e) {
                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);
                    }
                }
                query.context.abortListeners = null;
                this.running.splice(i--, 1);
            }
            else {
                query.updates.push(...update.transactions);
            }
        }
        if (this.debounceUpdate > -1)
            clearTimeout(this.debounceUpdate);
        if (update.transactions.some(tr => tr.effects.some(e => e.is(startCompletionEffect))))
            this.pendingStart = true;
        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
        this.debounceUpdate = cState.active.some(a => a.isPending && !this.running.some(q => q.active.source == a.source))
            ? setTimeout(() => this.startUpdate(), delay) : -1;
        if (this.composing != 0)
            for (let tr of update.transactions) {
                if (tr.isUserEvent("input.type"))
                    this.composing = 2;
                else if (this.composing == 2 && tr.selection)
                    this.composing = 3;
            }
    }
    startUpdate() {
        this.debounceUpdate = -1;
        this.pendingStart = false;
        let { state } = this.view, cState = state.field(completionState);
        for (let active of cState.active) {
            if (active.isPending && !this.running.some(r => r.active.source == active.source))
                this.startQuery(active);
        }
        if (this.running.length && cState.open && cState.open.disabled)
            this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    startQuery(active) {
        let { state } = this.view, pos = cur(state);
        let context = new CompletionContext(state, pos, active.explicit, this.view);
        let pending = new RunningQuery(active, context);
        this.running.push(pending);
        Promise.resolve(active.source(context)).then(result => {
            if (!pending.context.aborted) {
                pending.done = result || null;
                this.scheduleAccept();
            }
        }, err => {
            this.view.dispatch({ effects: closeCompletionEffect.of(null) });
            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);
        });
    }
    scheduleAccept() {
        if (this.running.every(q => q.done !== undefined))
            this.accept();
        else if (this.debounceAccept < 0)
            this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    accept() {
        var _a;
        if (this.debounceAccept > -1)
            clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        let updated = [];
        let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (query.done === undefined)
                continue;
            this.running.splice(i--, 1);
            if (query.done) {
                let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
                let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
                let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : pos);
                for (let tr of query.updates)
                    active = active.update(tr, conf);
                if (active.hasResult()) {
                    updated.push(active);
                    continue;
                }
            }
            let current = cState.active.find(a => a.source == query.active.source);
            if (current && current.isPending) {
                if (query.done == null) {
                    let active = new ActiveSource(query.active.source, 0);
                    for (let tr of query.updates)
                        active = active.update(tr, conf);
                    if (!active.isPending)
                        updated.push(active);
                }
                else {
                    this.startQuery(current);
                }
            }
        }
        if (updated.length || cState.open && cState.open.disabled)
            this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
}, {
    eventHandlers: {
        blur(event) {
            let state = this.view.state.field(completionState, false);
            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);
                if (!dialog || !dialog.dom.contains(event.relatedTarget))
                    setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
            }
        },
        compositionstart() {
            this.composing = 1;
        },
        compositionend() {
            if (this.composing == 3) {
                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
            }
            this.composing = 0;
        }
    }
});
const windows = typeof navigator == "object" && /Win/.test(navigator.platform);
const commitCharacters = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({
    keydown(event, view) {
        let field = view.state.field(completionState, false);
        if (!field || !field.open || field.open.disabled || field.open.selected < 0 ||
            event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
            return false;
        let option = field.open.options[field.open.selected];
        let result = field.active.find(a => a.source == option.source);
        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
        if (commitChars && commitChars.indexOf(event.key) > -1)
            applyCompletion(view, option);
        return false;
    }
}));
const baseTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            height: "100%",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li, & > completion-section": {
                padding: "1px 3px",
                lineHeight: 1.2
            },
            "& > li": {
                overflowX: "hidden",
                textOverflow: "ellipsis",
                cursor: "pointer"
            },
            "& > completion-section": {
                display: "list-item",
                borderBottom: "1px solid silver",
                paddingLeft: "0.5em",
                opacity: 0.7
            }
        }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#17c",
        color: "white",
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#777",
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#347",
        color: "white",
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#444",
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '"···"',
        opacity: 0.5,
        display: "block",
        textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: `${400}px`,
        boxSizing: "border-box",
        whiteSpace: "pre-line"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        display: "inline-block",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
        textDecoration: "underline"
    },
    ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
    },
    ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6",
        boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": { content: "'ƒ'" }
    },
    ".cm-completionIcon-class": {
        "&:after": { content: "'○'" }
    },
    ".cm-completionIcon-interface": {
        "&:after": { content: "'◌'" }
    },
    ".cm-completionIcon-variable": {
        "&:after": { content: "'𝑥'" }
    },
    ".cm-completionIcon-constant": {
        "&:after": { content: "'𝐶'" }
    },
    ".cm-completionIcon-type": {
        "&:after": { content: "'𝑡'" }
    },
    ".cm-completionIcon-enum": {
        "&:after": { content: "'∪'" }
    },
    ".cm-completionIcon-property": {
        "&:after": { content: "'□'" }
    },
    ".cm-completionIcon-keyword": {
        "&:after": { content: "'🔑\uFE0E'" }
    },
    ".cm-completionIcon-namespace": {
        "&:after": { content: "'▢'" }
    },
    ".cm-completionIcon-text": {
        "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
});
class FieldPos {
    constructor(field, line, from, to) {
        this.field = field;
        this.line = line;
        this.from = from;
        this.to = to;
    }
}
class FieldRange {
    constructor(field, from, to) {
        this.field = field;
        this.from = from;
        this.to = to;
    }
    map(changes) {
        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);
        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);
        return from == null || to == null ? null : new FieldRange(this.field, from, to);
    }
}
class Snippet {
    constructor(lines, fieldPositions) {
        this.lines = lines;
        this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
        let text = [], lineStart = [pos];
        let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
        for (let line of this.lines) {
            if (text.length) {
                let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
                for (let i = 0; i < tabs; i++)
                    indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);
                lineStart.push(pos + indent.length - tabs);
                line = indent + line.slice(tabs);
            }
            text.push(line);
            pos += line.length + 1;
        }
        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));
        return { text, ranges };
    }
    static parse(template) {
        let fields = [];
        let lines = [], positions = [], m;
        for (let line of template.split(/\r\n?|\n/)) {
            while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line)) {
                let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || "", found = -1;
                let name = rawName.replace(/\\[{}]/g, m => m[1]);
                for (let i = 0; i < fields.length; i++) {
                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)
                        found = i;
                }
                if (found < 0) {
                    let i = 0;
                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))
                        i++;
                    fields.splice(i, 0, { seq, name });
                    found = i;
                    for (let pos of positions)
                        if (pos.field >= found)
                            pos.field++;
                }
                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
                line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);
            }
            line = line.replace(/\\([{}])/g, (_, brace, index) => {
                for (let pos of positions)
                    if (pos.line == lines.length && pos.from > index) {
                        pos.from--;
                        pos.to--;
                    }
                return brace;
            });
            lines.push(line);
        }
        return new Snippet(lines, positions);
    }
}
let fieldMarker = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({ widget: new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {
        toDOM() {
            let span = document.createElement("span");
            span.className = "cm-snippetFieldPosition";
            return span;
        }
        ignoreEvent() { return false; }
    } });
let fieldRange = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: "cm-snippetField" });
class ActiveSnippet {
    constructor(ranges, active) {
        this.ranges = ranges;
        this.active = active;
        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
    }
    map(changes) {
        let ranges = [];
        for (let r of this.ranges) {
            let mapped = r.map(changes);
            if (!mapped)
                return null;
            ranges.push(mapped);
        }
        return new ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));
    }
}
const setActive = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({
    map(value, changes) { return value && value.map(changes); }
});
const moveToField = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const snippetState = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() { return null; },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setActive))
                return effect.value;
            if (effect.is(moveToField) && value)
                return new ActiveSnippet(value.ranges, effect.value);
        }
        if (value && tr.docChanged)
            value = value.map(tr.changes);
        if (value && tr.selection && !value.selectionInsideField(tr.selection))
            value = null;
        return value;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, val => val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)
});
function fieldSelection(ranges, field) {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter(r => r.field == field).map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));
}
function snippet(template) {
    let snippet = Snippet.parse(template);
    return (editor, completion, from, to) => {
        let { text, ranges } = snippet.instantiate(editor.state, from);
        let { main } = editor.state.selection;
        let spec = {
            changes: { from, to: to == main.from ? main.to : to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text) },
            scrollIntoView: true,
            annotations: completion ? [pickedCompletion.of(completion), _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent.of("input.complete")] : undefined
        };
        if (ranges.length)
            spec.selection = fieldSelection(ranges, 0);
        if (ranges.some(r => r.field > 0)) {
            let active = new ActiveSnippet(ranges, 0);
            let effects = spec.effects = [setActive.of(active)];
            if (editor.state.field(snippetState, false) === undefined)
                effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));
        }
        editor.dispatch(editor.state.update(spec));
    };
}
function moveField(dir) {
    return ({ state, dispatch }) => {
        let active = state.field(snippetState, false);
        if (!active || dir < 0 && active.active == 0)
            return false;
        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);
        dispatch(state.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
            scrollIntoView: true
        }));
        return true;
    };
}
const clearSnippet = ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active)
        return false;
    dispatch(state.update({ effects: setActive.of(null) }));
    return true;
};
const nextSnippetField = moveField(1);
const prevSnippetField = moveField(-1);
function hasNextSnippetField(state) {
    let active = state.field(snippetState, false);
    return !!(active && active.ranges.some(r => r.field == active.active + 1));
}
function hasPrevSnippetField(state) {
    let active = state.field(snippetState, false);
    return !!(active && active.active > 0);
}
const defaultSnippetKeymap = [
    { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
    { key: "Escape", run: clearSnippet }
];
const snippetKeymap = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }
});
const addSnippetKeymap = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));
function snippetCompletion(template, completion) {
    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
}
const snippetPointerHandler = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({
    mousedown(event, view) {
        let active = view.state.field(snippetState, false), pos;
        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
            return false;
        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);
        if (!match || match.field == active.active)
            return false;
        view.dispatch({
            selection: fieldSelection(active.ranges, match.field),
            effects: setActive.of(active.ranges.some(r => r.field > match.field)
                ? new ActiveSnippet(active.ranges, match.field) : null),
            scrollIntoView: true
        });
        return true;
    }
});
function wordRE(wordChars) {
    let escaped = wordChars.replace(/[\]\-\\]/g, "\\$&");
    try {
        return new RegExp(`[\\p{Alphabetic}\\p{Number}_${escaped}]+`, "ug");
    }
    catch (_a) {
        return new RegExp(`[\w${escaped}]`, "g");
    }
}
function mapRE(re, f) {
    return new RegExp(f(re.source), re.unicode ? "u" : "");
}
const wordCaches = Object.create(null);
function wordCache(wordChars) {
    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);
}
function storeWords(doc, wordRE, result, seen, ignoreAt) {
    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {
        let { value } = lines, m;
        wordRE.lastIndex = 0;
        while (m = wordRE.exec(value)) {
            if (!seen[m[0]] && pos + m.index != ignoreAt) {
                result.push({ type: "text", label: m[0] });
                seen[m[0]] = true;
                if (result.length >= 2000)
                    return;
            }
        }
        pos += value.length + 1;
    }
}
function collectWords(doc, cache, wordRE, to, ignoreAt) {
    let big = doc.length >= 1000;
    let cached = big && cache.get(doc);
    if (cached)
        return cached;
    let result = [], seen = Object.create(null);
    if (doc.children) {
        let pos = 0;
        for (let ch of doc.children) {
            if (ch.length >= 1000) {
                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {
                    if (!seen[c.label]) {
                        seen[c.label] = true;
                        result.push(c);
                    }
                }
            }
            else {
                storeWords(ch, wordRE, result, seen, ignoreAt - pos);
            }
            pos += ch.length + 1;
        }
    }
    else {
        storeWords(doc, wordRE, result, seen, ignoreAt);
    }
    if (big && result.length < 2000)
        cache.set(doc, result);
    return result;
}
const completeAnyWord = context => {
    let wordChars = context.state.languageDataAt("wordChars", context.pos).join("");
    let re = wordRE(wordChars);
    let token = context.matchBefore(mapRE(re, s => s + "$"));
    if (!token && !context.explicit)
        return null;
    let from = token ? token.from : context.pos;
    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000, from);
    return { from, options, validFor: mapRE(re, s => "^" + s) };
};
const defaults = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
};
const closeBracketEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({
    map(value, mapping) {
        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);
        return mapped == null ? undefined : mapped;
    }
});
const closedBracket = new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {
};
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() { return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty; },
    update(value, tr) {
        value = value.map(tr.changes);
        if (tr.selection) {
            let line = tr.state.doc.lineAt(tr.selection.main.head);
            value = value.update({ filter: from => from >= line.from && from <= line.to });
        }
        for (let effect of tr.effects)
            if (effect.is(closeBracketEffect))
                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
        return value;
    }
});
function closeBrackets() {
    return [inputHandler, bracketState];
}
const definedClosing = "()[]{}<>«»»«［］｛｝";
function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
        if (definedClosing.charCodeAt(i) == ch)
            return definedClosing.charAt(i + 1);
    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}
const android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
const inputHandler = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
        return false;
    let sel = view.state.selection.main;
    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 ||
        from != sel.from || to != sel.to)
        return false;
    let tr = insertBracket(view.state, insert);
    if (!tr)
        return false;
    view.dispatch(tr);
    return true;
});
const deleteBracketPair = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    let dont = null, changes = state.changeByRange(range => {
        if (range.empty) {
            let before = prevChar(state.doc, range.head);
            for (let token of tokens) {
                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0)))
                    return { changes: { from: range.head - token.length, to: range.head + token.length },
                        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length) };
            }
        }
        return { range: dont = range };
    });
    if (!dont)
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
    return !dont;
};
const closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket) {
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    for (let tok of tokens) {
        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));
        if (bracket == tok)
            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)
                : handleOpen(state, tok, closed, conf.before || defaults.before);
        if (bracket == closed && closedBracketAt(state, state.selection.main.from))
            return handleClose(state, tok, closed);
    }
    return null;
}
function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, from => {
        if (from == pos)
            found = true;
    });
    return found;
}
function nextChar(doc, pos) {
    let next = doc.sliceString(pos, pos + 2);
    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));
}
function prevChar(doc, pos) {
    let prev = doc.sliceString(pos - 2, pos);
    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
    let dont = null, changes = state.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
                effects: closeBracketEffect.of(range.to + open.length),
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length) };
        let next = nextChar(state.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
            return { changes: { insert: open + close, from: range.head },
                effects: closeBracketEffect.of(range.head + open.length),
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length) };
        return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function handleClose(state, _open, close) {
    let dont = null, changes = state.changeByRange(range => {
        if (range.empty && nextChar(state.doc, range.head) == close)
            return { changes: { from: range.head, to: range.head + close.length, insert: close },
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length) };
        return dont = { range };
    });
    return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function handleSame(state, token, allowTriple, config) {
    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;
    let dont = null, changes = state.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
                effects: closeBracketEffect.of(range.to + token.length),
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length) };
        let pos = range.head, next = nextChar(state.doc, pos), start;
        if (next == token) {
            if (nodeStart(state, pos)) {
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };
            }
            else if (closedBracketAt(state, pos)) {
                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
                let content = isTriple ? token + token + token : token;
                return { changes: { from: pos, to: pos + content.length, insert: content },
                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length) };
            }
        }
        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&
            (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 &&
            nodeStart(state, start)) {
            return { changes: { insert: token + token + token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };
        }
        else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {
            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };
        }
        return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function nodeStart(state, pos) {
    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
    for (let i = 0; i < 5; i++) {
        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
        let quotePos = start.indexOf(quoteToken);
        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
            let first = node.firstChild;
            while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
                    return false;
                first = first.firstChild;
            }
            return true;
        }
        let parent = node.to == pos && node.parent;
        if (!parent)
            break;
        node = parent;
    }
    return false;
}
function canStartStringAt(state, pos, prefixes) {
    let charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word)
        return pos;
    for (let prefix of prefixes) {
        let start = pos - prefix.length;
        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word)
            return start;
    }
    return -1;
}
function autocompletion(config = {}) {
    return [
        commitCharacters,
        completionState,
        completionConfig.of(config),
        completionPlugin,
        completionKeymapExt,
        baseTheme
    ];
}
const completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { mac: "Alt-`", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: moveCompletionSelection(true) },
    { key: "ArrowUp", run: moveCompletionSelection(false) },
    { key: "PageDown", run: moveCompletionSelection(true, "page") },
    { key: "PageUp", run: moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
];
const completionKeymapExt = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
function completionStatus(state) {
    let cState = state.field(completionState, false);
    return cState && cState.active.some(a => a.isPending) ? "pending"
        : cState && cState.active.some(a => a.state != 0) ? "active" : null;
}
const completionArrayCache = new WeakMap;
function currentCompletions(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    if (!open || open.disabled)
        return [];
    let completions = completionArrayCache.get(open.options);
    if (!completions)
        completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));
    return completions;
}
function selectedCompletion(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;
}
function selectedCompletionIndex(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    return open && !open.disabled && open.selected >= 0 ? open.selected : null;
}
function setSelectedCompletion(index) {
    return setSelectedEffect.of(index);
}



/***/ }),

/***/ "./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blockComment: () => (/* binding */ blockComment),
/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),
/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),
/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),
/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),
/* harmony export */   cursorCharBackwardLogical: () => (/* binding */ cursorCharBackwardLogical),
/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),
/* harmony export */   cursorCharForwardLogical: () => (/* binding */ cursorCharForwardLogical),
/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),
/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),
/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),
/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),
/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),
/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),
/* harmony export */   cursorGroupForwardWin: () => (/* binding */ cursorGroupForwardWin),
/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),
/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),
/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),
/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),
/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),
/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),
/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),
/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),
/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),
/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),
/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),
/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),
/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),
/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),
/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),
/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),
/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),
/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),
/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),
/* harmony export */   deleteCharBackwardStrict: () => (/* binding */ deleteCharBackwardStrict),
/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),
/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),
/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),
/* harmony export */   deleteLine: () => (/* binding */ deleteLine),
/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),
/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),
/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),
/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),
/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),
/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),
/* harmony export */   history: () => (/* binding */ history),
/* harmony export */   historyField: () => (/* binding */ historyField),
/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),
/* harmony export */   indentLess: () => (/* binding */ indentLess),
/* harmony export */   indentMore: () => (/* binding */ indentMore),
/* harmony export */   indentSelection: () => (/* binding */ indentSelection),
/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),
/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),
/* harmony export */   insertNewline: () => (/* binding */ insertNewline),
/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),
/* harmony export */   insertNewlineKeepIndent: () => (/* binding */ insertNewlineKeepIndent),
/* harmony export */   insertTab: () => (/* binding */ insertTab),
/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),
/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),
/* harmony export */   lineComment: () => (/* binding */ lineComment),
/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),
/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),
/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),
/* harmony export */   redo: () => (/* binding */ redo),
/* harmony export */   redoDepth: () => (/* binding */ redoDepth),
/* harmony export */   redoSelection: () => (/* binding */ redoSelection),
/* harmony export */   selectAll: () => (/* binding */ selectAll),
/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),
/* harmony export */   selectCharBackwardLogical: () => (/* binding */ selectCharBackwardLogical),
/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),
/* harmony export */   selectCharForwardLogical: () => (/* binding */ selectCharForwardLogical),
/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),
/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),
/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),
/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),
/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),
/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),
/* harmony export */   selectGroupForwardWin: () => (/* binding */ selectGroupForwardWin),
/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),
/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),
/* harmony export */   selectLine: () => (/* binding */ selectLine),
/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),
/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),
/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),
/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),
/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),
/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),
/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),
/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),
/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),
/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),
/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),
/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),
/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),
/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),
/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),
/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),
/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),
/* harmony export */   splitLine: () => (/* binding */ splitLine),
/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),
/* harmony export */   temporarilySetTabFocusMode: () => (/* binding */ temporarilySetTabFocusMode),
/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),
/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),
/* harmony export */   toggleComment: () => (/* binding */ toggleComment),
/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),
/* harmony export */   toggleTabFocusMode: () => (/* binding */ toggleTabFocusMode),
/* harmony export */   transposeChars: () => (/* binding */ transposeChars),
/* harmony export */   undo: () => (/* binding */ undo),
/* harmony export */   undoDepth: () => (/* binding */ undoDepth),
/* harmony export */   undoSelection: () => (/* binding */ undoSelection)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.js");
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.js");




const toggleComment = target => {
    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
    return ({ state, dispatch }) => {
        if (state.readOnly)
            return false;
        let tr = f(option, state);
        if (!tr)
            return false;
        dispatch(state.update(tr));
        return true;
    };
}
const toggleLineComment = command(changeLineComment, 0);
const lineComment = command(changeLineComment, 1);
const lineUncomment = command(changeLineComment, 2);
const toggleBlockComment = command(changeBlockComment, 0);
const blockComment = command(changeBlockComment, 1);
const blockUncomment = command(changeBlockComment, 2);
const toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos, 1);
    return data.length ? data[0] : {};
}
const SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&
        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
        startText = endText = state.sliceDoc(from, to);
    }
    else {
        startText = state.sliceDoc(from, from + SearchMargin);
        endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open &&
        endText.slice(endOff, endOff + close.length) == close) {
        return { open: { pos: from + startSpace + open.length,
                margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },
            close: { pos: to - endSpace - close.length,
                margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };
    }
    return null;
}
function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
        let fromLine = state.doc.lineAt(r.from);
        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
        if (toLine.from > fromLine.from && toLine.from == r.to)
            toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last].to > fromLine.from)
            ranges[last].to = toLine.to;
        else
            ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
    }
    return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map(r => getConfig(state, r.from).block);
    if (!tokens.every(c => c))
        return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 && !comments.every(c => c)) {
        return { changes: state.changes(ranges.map((range, i) => {
                if (comments[i])
                    return [];
                return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
            })) };
    }
    else if (option != 1 && comments.some(c => c)) {
        let changes = [];
        for (let i = 0, comment; i < comments.length; i++)
            if (comment = comments[i]) {
                let token = tokens[i], { open, close } = comment;
                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
            }
        return { changes };
    }
    return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
        let startI = lines.length, minIndent = 1e9;
        let token = getConfig(state, from).line;
        if (!token)
            continue;
        for (let pos = from; pos <= to;) {
            let line = state.doc.lineAt(pos);
            if (line.from > prevLine && (from == to || to > line.from)) {
                prevLine = line.from;
                let indent = /^\s*/.exec(line.text)[0].length;
                let empty = indent == line.length;
                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                if (indent < line.text.length && indent < minIndent)
                    minIndent = indent;
                lines.push({ line, comment, token, indent, empty, single: false });
            }
            pos = line.to + 1;
        }
        if (minIndent < 1e9)
            for (let i = startI; i < lines.length; i++)
                if (lines[i].indent < lines[i].line.text.length)
                    lines[i].indent = minIndent;
        if (lines.length == startI + 1)
            lines[startI].single = true;
    }
    if (option != 2 && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
        let changes = [];
        for (let { line, token, indent, empty, single } of lines)
            if (single || !empty)
                changes.push({ from: line.from + indent, insert: token + " " });
        let changeSet = state.changes(changes);
        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    }
    else if (option != 1 && lines.some(l => l.comment >= 0)) {
        let changes = [];
        for (let { line, comment, token } of lines)
            if (comment >= 0) {
                let from = line.from + comment, to = from + token.length;
                if (line.text[to - line.from] == " ")
                    to++;
                changes.push({ from, to });
            }
        return { changes };
    }
    return null;
}
const fromHistory = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();
const isolateHistory = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();
const invertedEffects = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();
const historyConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (_t, isAdjacent) => isAdjacent,
        }, {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
        });
    }
});
const historyField_ = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() {
        return HistoryState.empty;
    },
    update(state, tr) {
        let config = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
            let other = from == 0 ? state.undone : state.done;
            if (item)
                other = updateBranch(other, other.length, config.minDepth, item);
            else
                other = addSelection(other, tr.startState.selection);
            return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before")
            state = state.isolate();
        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false)
            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);
        if (event)
            state = state.addChanges(event, time, userEvent, config, tr);
        else if (tr.selection)
            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
        if (isolate == "full" || isolate == "after")
            state = state.isolate();
        return state;
    },
    toJSON(value) {
        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };
    },
    fromJSON(json) {
        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
});
function history(config = {}) {
    return [
        historyField_,
        historyConfig.of(config),
        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({
            beforeinput(e, view) {
                let command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
                if (!command)
                    return false;
                e.preventDefault();
                return command(view);
            }
        })
    ];
}
const historyField = historyField_;
function cmd(side, selection) {
    return function ({ state, dispatch }) {
        if (!selection && state.readOnly)
            return false;
        let historyState = state.field(historyField_, false);
        if (!historyState)
            return false;
        let tr = historyState.pop(side, state, selection);
        if (!tr)
            return false;
        dispatch(tr);
        return true;
    };
}
const undo = cmd(0, false);
const redo = cmd(1, false);
const undoSelection = cmd(0, true);
const redoSelection = cmd(1, true);
function depth(side) {
    return function (state) {
        let histState = state.field(historyField_, false);
        if (!histState)
            return 0;
        let branch = side == 0 ? histState.done : histState.undone;
        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
    };
}
const undoDepth = depth(0);
const redoDepth = depth(1);
class HistEvent {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
        this.changes = changes;
        this.effects = effects;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
        var _a, _b, _c;
        return {
            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
        };
    }
    static fromJSON(json) {
        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection) {
        let effects = none;
        for (let invert of tr.startState.facet(invertedEffects)) {
            let result = invert(tr);
            if (result.length)
                effects = effects.concat(result);
        }
        if (!effects.length && tr.changes.empty)
            return null;
        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);
    }
    static selection(selections) {
        return new HistEvent(undefined, none, undefined, undefined, selections);
    }
}
function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
}
function isAdjacent(a, b) {
    let ranges = [], isAdjacent = false;
    a.iterChangedRanges((f, t) => ranges.push(f, t));
    b.iterChangedRanges((_f, _t, f, t) => {
        for (let i = 0; i < ranges.length;) {
            let from = ranges[i++], to = ranges[i++];
            if (t >= from && f <= to)
                isAdjacent = true;
        }
    });
    return isAdjacent;
}
function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length &&
        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
}
const none = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
    if (!branch.length) {
        return [HistEvent.selection([selection])];
    }
    else {
        let lastEvent = branch[branch.length - 1];
        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
        if (sels.length && sels[sels.length - 1].eq(selection))
            return branch;
        sels.push(selection);
        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
}
function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
}
function addMappingToBranch(branch, mapping) {
    if (!branch.length)
        return branch;
    let length = branch.length, selections = none;
    while (length) {
        let event = mapEvent(branch[length - 1], mapping, selections);
        if (event.changes && !event.changes.empty || event.effects.length) {
            let result = branch.slice(0, length);
            result[length - 1] = event;
            return result;
        }
        else {
            mapping = event.mapped;
            length--;
            selections = event.selectionsAfter;
        }
    }
    return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);
    if (!event.changes)
        return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
    }
    isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, config, tr) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&
            (!userEvent || joinableUserEvent.test(userEvent)) &&
            ((!lastEvent.selectionsAfter.length &&
                time - this.prevTime < config.newGroupDelay &&
                config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||
                userEvent == "input.type.compose")) {
            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
        }
        else {
            done = updateBranch(done, done.length, config.minDepth, event);
        }
        return new HistoryState(done, none, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
        if (last.length > 0 &&
            time - this.prevTime < newGroupDelay &&
            userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) &&
            eqSelectionShape(last[last.length - 1], selection))
            return this;
        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, onlySelection) {
        let branch = side == 0 ? this.done : this.undone;
        if (branch.length == 0)
            return null;
        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
        if (onlySelection && event.selectionsAfter.length) {
            return state.update({
                selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
                userEvent: side == 0 ? "select.undo" : "select.redo",
                scrollIntoView: true
            });
        }
        else if (!event.changes) {
            return null;
        }
        else {
            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
            if (event.mapped)
                rest = addMappingToBranch(rest, event.mapped);
            return state.update({
                changes: event.changes,
                selection: event.startSelection,
                effects: event.effects,
                annotations: fromHistory.of({ side, rest, selection }),
                filter: false,
                userEvent: side == 0 ? "undo" : "redo",
                scrollIntoView: true
            });
        }
    }
}
HistoryState.empty = new HistoryState(none, none);
const historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
    return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection, true))
        return false;
    dispatch(setSel(state, selection));
    return true;
}
function rangeEnd(range, forward) {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;
}
const cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));
const cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));
const cursorCharForward = view => cursorByChar(view, true);
const cursorCharBackward = view => cursorByChar(view, false);
function byCharLogical(state, range, forward) {
    let pos = range.head, line = state.doc.lineAt(pos);
    if (pos == (forward ? line.to : line.from))
        pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);
    else
        pos = line.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward);
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos, forward ? -1 : 1);
}
function moveByCharLogical(target, forward) {
    return moveSel(target, range => range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));
}
const cursorCharForwardLogical = target => moveByCharLogical(target, true);
const cursorCharBackwardLogical = target => moveByCharLogical(target, false);
function cursorByGroup(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
const cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));
const cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));
const cursorGroupForward = view => cursorByGroup(view, true);
const cursorGroupBackward = view => cursorByGroup(view, false);
function toGroupStart(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start), initial = cat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space;
    return (next) => {
        let nextCat = categorize(next);
        if (nextCat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space)
            return initial && nextCat == cat;
        initial = false;
        return true;
    };
}
const cursorGroupForwardWin = view => {
    return moveSel(view, range => range.empty
        ? view.moveByChar(range, true, start => toGroupStart(view, range.head, start))
        : rangeEnd(range, true));
};
const segmenter = typeof Intl != "undefined" && Intl.Segmenter ?
    new (Intl.Segmenter)(undefined, { granularity: "word" }) : null;
function moveBySubword(view, range, forward) {
    let categorize = view.state.charCategorizer(range.from);
    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;
    let done = false, sawUpper = false, sawLower = false;
    let step = (next) => {
        if (done)
            return false;
        pos += forward ? next.length : -next.length;
        let nextCat = categorize(next), ahead;
        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\W_]/.test(next))
            nextCat = -1;
        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space)
            cat = nextCat;
        if (cat != nextCat)
            return false;
        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {
            if (next.toLowerCase() == next) {
                if (!forward && sawUpper)
                    return false;
                sawLower = true;
            }
            else if (sawLower) {
                if (forward)
                    return false;
                done = true;
            }
            else {
                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word &&
                    ahead.toLowerCase() == ahead)
                    return false;
                sawUpper = true;
            }
        }
        steps++;
        return true;
    };
    let end = view.moveByChar(range, forward, start => {
        step(start);
        return step;
    });
    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {
        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);
        let skipped = view.state.sliceDoc(from, to);
        if (skipped.length > 1 && /[\u4E00-\uffff]/.test(skipped)) {
            let segments = Array.from(segmenter.segment(skipped));
            if (segments.length > 1) {
                if (forward)
                    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);
            }
        }
    }
    return end;
}
function cursorBySubword(view, forward) {
    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
}
const cursorSubwordForward = view => cursorBySubword(view, true);
const cursorSubwordBackward = view => cursorBySubword(view, false);
function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
        return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);
    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;
    for (let at = start.head;;) {
        let next = forward ? pos.childAfter(at) : pos.childBefore(at);
        if (!next)
            break;
        if (interestingNode(state, next, bracketProp))
            pos = next;
        else
            at = forward ? next.to : next.from;
    }
    let bracket = pos.type.prop(bracketProp), match, newPos;
    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched)
        newPos = forward ? match.end.to : match.end.from;
    else
        newPos = forward ? pos.to : pos.from;
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);
}
const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
    return moveSel(view, range => {
        if (!range.empty)
            return rangeEnd(range, forward);
        let moved = view.moveVertically(range, forward);
        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
}
const cursorLineUp = view => cursorByLine(view, false);
const cursorLineDown = view => cursorByLine(view, true);
function pageInfo(view) {
    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)) {
            let margins = source(view);
            if (margins === null || margins === void 0 ? void 0 : margins.top)
                marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
            if (margins === null || margins === void 0 ? void 0 : margins.bottom)
                marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
        }
        height = view.scrollDOM.clientHeight - marginTop - marginBottom;
    }
    else {
        height = (view.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return { marginTop, marginBottom, selfScroll,
        height: Math.max(view.defaultLineHeight, height - 5) };
}
function cursorByPage(view, forward) {
    let page = pageInfo(view);
    let { state } = view, selection = updateSel(state.selection, range => {
        return range.empty ? view.moveVertically(range, forward, page.height)
            : rangeEnd(range, forward);
    });
    if (selection.eq(state.selection))
        return false;
    let effect;
    if (page.selfScroll) {
        let startPos = view.coordsAtPos(state.selection.main.head);
        let scrollRect = view.scrollDOM.getBoundingClientRect();
        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
            effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view.dispatch(setSel(state, selection), { effects: effect });
    return true;
}
const cursorPageUp = view => cursorByPage(view, false);
const cursorPageDown = view => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
        moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
        let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
        if (space && start.head != line.from + space)
            moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);
    }
    return moved;
}
const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
const cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
const cursorLineStart = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
const cursorLineEnd = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
    let found = false, selection = updateSel(state.selection, range => {
        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1)
            || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1)
            || (range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1))
            || (range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1));
        if (!matching || !matching.end)
            return range;
        found = true;
        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);
    });
    if (!found)
        return false;
    dispatch(setSel(state, selection));
    return true;
}
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
const selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);
function extendSel(target, how) {
    let selection = updateSel(target.state.selection, range => {
        let head = how(range);
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);
    });
    if (selection.eq(target.state.selection))
        return false;
    target.dispatch(setSel(target.state, selection));
    return true;
}
function selectByChar(view, forward) {
    return extendSel(view, range => view.moveByChar(range, forward));
}
const selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));
const selectCharRight = view => selectByChar(view, ltrAtCursor(view));
const selectCharForward = view => selectByChar(view, true);
const selectCharBackward = view => selectByChar(view, false);
const selectCharForwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, true));
const selectCharBackwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, false));
function selectByGroup(view, forward) {
    return extendSel(view, range => view.moveByGroup(range, forward));
}
const selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));
const selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));
const selectGroupForward = view => selectByGroup(view, true);
const selectGroupBackward = view => selectByGroup(view, false);
const selectGroupForwardWin = view => {
    return extendSel(view, range => view.moveByChar(range, true, start => toGroupStart(view, range.head, start)));
};
function selectBySubword(view, forward) {
    return extendSel(view, range => moveBySubword(view, range, forward));
}
const selectSubwordForward = view => selectBySubword(view, true);
const selectSubwordBackward = view => selectBySubword(view, false);
const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward));
}
const selectLineUp = view => selectByLine(view, false);
const selectLineDown = view => selectByLine(view, true);
function selectByPage(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));
}
const selectPageUp = view => selectByPage(view, false);
const selectPageDown = view => selectByPage(view, true);
const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
const selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
const selectLineStart = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));
const selectLineEnd = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));
const cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
};
const cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
};
const selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
};
const selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
};
const selectAll = ({ state, dispatch }) => {
    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
};
const selectLine = ({ state, dispatch }) => {
    let ranges = selectedLineBlocks(state).map(({ from, to }) => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch(state.update({ selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges), userEvent: "select" }));
    return true;
};
const selectParentSyntax = ({ state, dispatch }) => {
    let selection = updateSel(state.selection, range => {
        let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state), stack = tree.resolveStack(range.from, 1);
        if (range.empty) {
            let stackBefore = tree.resolveStack(range.from, -1);
            if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
                stack = stackBefore;
        }
        for (let cur = stack; cur; cur = cur.next) {
            let { node } = cur;
            if (((node.from < range.from && node.to >= range.to) ||
                (node.to > range.to && node.from <= range.from)) &&
                cur.next)
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);
        }
        return range;
    });
    if (selection.eq(state.selection))
        return false;
    dispatch(setSel(state, selection));
    return true;
};
const simplifySelection = ({ state, dispatch }) => {
    let cur = state.selection, selection = null;
    if (cur.ranges.length > 1)
        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)]);
    if (!selection)
        return false;
    dispatch(setSel(state, selection));
    return true;
};
function deleteBy(target, by) {
    if (target.state.readOnly)
        return false;
    let event = "delete.selection", { state } = target;
    let changes = state.changeByRange(range => {
        let { from, to } = range;
        if (from == to) {
            let towards = by(range);
            if (towards < from) {
                event = "delete.backward";
                towards = skipAtomic(target, towards, false);
            }
            else if (towards > from) {
                event = "delete.forward";
                towards = skipAtomic(target, towards, true);
            }
            from = Math.min(from, towards);
            to = Math.max(to, towards);
        }
        else {
            from = skipAtomic(target, from, false);
            to = skipAtomic(target, to, true);
        }
        return from == to ? { range } : { changes: { from, to }, range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1) };
    });
    if (changes.changes.empty)
        return false;
    target.dispatch(state.update(changes, {
        scrollIntoView: true,
        userEvent: event,
        effects: event == "delete.selection" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase("Selection deleted")) : undefined
    }));
    return true;
}
function skipAtomic(target, pos, forward) {
    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView)
        for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map(f => f(target)))
            ranges.between(pos, pos, (from, to) => {
                if (from < pos && to > pos)
                    pos = forward ? to : from;
            });
    return pos;
}
const deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, range => {
    let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 &&
        !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "\t")
            return pos - 1;
        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);
        for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
            pos--;
        targetPos = pos;
    }
    else {
        targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;
        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
            targetPos += forward ? 1 : -1;
        else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
            targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false) + line.from;
    }
    return targetPos;
});
const deleteCharBackward = view => deleteByChar(view, false, true);
const deleteCharBackwardStrict = view => deleteByChar(view, false, false);
const deleteCharForward = view => deleteByChar(view, true, false);
const deleteByGroup = (target, forward) => deleteBy(target, range => {
    let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null;;) {
        if (pos == (forward ? line.to : line.from)) {
            if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
                pos += forward ? 1 : -1;
            break;
        }
        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;
        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        let nextCat = categorize(nextChar);
        if (cat != null && nextCat != cat)
            break;
        if (nextChar != " " || pos != range.head)
            cat = nextCat;
        pos = next;
    }
    return pos;
});
const deleteGroupBackward = target => deleteByGroup(target, false);
const deleteGroupForward = target => deleteByGroup(target, true);
const deleteToLineEnd = view => deleteBy(view, range => {
    let lineEnd = view.lineBlockAt(range.head).to;
    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
const deleteToLineStart = view => deleteBy(view, range => {
    let lineStart = view.lineBlockAt(range.head).from;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
const deleteLineBoundaryBackward = view => deleteBy(view, range => {
    let lineStart = view.moveToLineBoundary(range, false).head;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
const deleteLineBoundaryForward = view => deleteBy(view, range => {
    let lineStart = view.moveToLineBoundary(range, true).head;
    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
const deleteTrailingWhitespace = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let pos = 0, prev = "", iter = state.doc.iter();;) {
        iter.next();
        if (iter.lineBreak || iter.done) {
            let trailing = prev.search(/\s+$/);
            if (trailing > -1)
                changes.push({ from: pos - (prev.length - trailing), to: pos });
            if (iter.done)
                break;
            prev = "";
        }
        else {
            prev = iter.value;
        }
        pos += iter.value.length;
    }
    if (!changes.length)
        return false;
    dispatch(state.update({ changes, userEvent: "delete" }));
    return true;
};
const splitLine = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = state.changeByRange(range => {
        return { changes: { from: range.from, to: range.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(["", ""]) },
            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from) };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
};
const transposeChars = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = state.changeByRange(range => {
        if (!range.empty || range.from == 0 || range.from == state.doc.length)
            return { range };
        let pos = range.from, line = state.doc.lineAt(pos);
        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;
        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;
        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to) };
    });
    if (changes.changes.empty)
        return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
};
function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
        if (!range.empty && range.to == endLine.from)
            endLine = state.doc.lineAt(range.to - 1);
        if (upto >= startLine.number) {
            let prev = blocks[blocks.length - 1];
            prev.to = endLine.to;
            prev.ranges.push(range);
        }
        else {
            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
        }
        upto = endLine.number + 1;
    }
    return blocks;
}
function moveLine(state, dispatch, forward) {
    if (state.readOnly)
        return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward ? block.to == state.doc.length : block.from == 0)
            continue;
        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        let size = nextLine.length + 1;
        if (forward) {
            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
            for (let r of block.ranges)
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
        }
        else {
            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
            for (let r of block.ranges)
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));
        }
    }
    if (!changes.length)
        return false;
    dispatch(state.update({
        changes,
        scrollIntoView: true,
        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),
        userEvent: "move.line"
    }));
    return true;
}
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward)
            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
        else
            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
}
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
const deleteLine = view => {
    if (view.state.readOnly)
        return false;
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
        if (from > 0)
            from--;
        else if (to < state.doc.length)
            to++;
        return { from, to };
    }));
    let selection = updateSel(state.selection, range => {
        let dist = undefined;
        if (view.lineWrapping) {
            let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (pos)
                dist = (block.bottom + view.documentTop) - pos.bottom + view.defaultLineHeight / 2;
        }
        return view.moveVertically(range, true, dist);
    }).map(changes);
    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
};
const insertNewline = ({ state, dispatch }) => {
    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
const insertNewlineKeepIndent = ({ state, dispatch }) => {
    dispatch(state.update(state.changeByRange(range => {
        let indent = /^\s*/.exec(state.doc.lineAt(range.from).text)[0];
        return {
            changes: { from: range.from, to: range.to, insert: state.lineBreak + indent },
            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + indent.length + 1)
        };
    }), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
        return { from: pos, to: pos };
    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos &&
        (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&
        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&
        !/\S/.test(state.sliceDoc(before.to, after.from)))
        return { from: before.to, to: after.from };
    return null;
}
const insertNewlineAndIndent = newlineAndIndent(false);
const insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
    return ({ state, dispatch }) => {
        if (state.readOnly)
            return false;
        let changes = state.changeByRange(range => {
            let { from, to } = range, line = state.doc.lineAt(from);
            let explode = !atEof && from == to && isBetweenBrackets(state, from);
            if (atEof)
                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);
            if (indent == null)
                indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
            while (to < line.to && /\s/.test(line.text[to - line.from]))
                to++;
            if (explode)
                ({ from, to } = explode);
            else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
                from = line.from;
            let insert = ["", (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)];
            if (explode)
                insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));
            return { changes: { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert) },
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length) };
        });
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
    };
}
function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange(range => {
        let changes = [];
        for (let pos = range.from; pos <= range.to;) {
            let line = state.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
                f(line, changes, range);
                atLine = line.number;
            }
            pos = line.to + 1;
        }
        let changeSet = state.changes(changes);
        return { changes,
            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };
    });
}
const indentSelection = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let updated = Object.create(null);
    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { overrideIndentation: start => {
            let found = updated[start];
            return found == null ? -1 : found;
        } });
    let changes = changeBySelectedLine(state, (line, changes, range) => {
        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);
        if (indent == null)
            return;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);
        if (cur != norm || range.from < line.from + cur.length) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    });
    if (!changes.changes.empty)
        dispatch(state.update(changes, { userEvent: "indent" }));
    return true;
};
const indentMore = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
};
const indentLess = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        let space = /^\s*/.exec(line.text)[0];
        if (!space)
            return;
        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;
        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));
        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
            keep++;
        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
};
const toggleTabFocusMode = view => {
    view.setTabFocusMode();
    return true;
};
const temporarilySetTabFocusMode = view => {
    view.setTabFocusMode(2000);
    return true;
};
const insertTab = ({ state, dispatch }) => {
    if (state.selection.ranges.some(r => !r.empty))
        return indentMore({ state, dispatch });
    dispatch(state.update(state.replaceSelection("\t"), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
const emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown },
];
const standardKeymap = [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
    { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));
const defaultKeymap = [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment },
    { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode },
].concat(standardKeymap);
const indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };



/***/ }),

/***/ "./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DocInput: () => (/* binding */ DocInput),
/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),
/* harmony export */   IndentContext: () => (/* binding */ IndentContext),
/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),
/* harmony export */   Language: () => (/* binding */ Language),
/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),
/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),
/* harmony export */   ParseContext: () => (/* binding */ ParseContext),
/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),
/* harmony export */   StringStream: () => (/* binding */ StringStream),
/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),
/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),
/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),
/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),
/* harmony export */   codeFolding: () => (/* binding */ codeFolding),
/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),
/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),
/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),
/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),
/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),
/* harmony export */   flatIndent: () => (/* binding */ flatIndent),
/* harmony export */   foldAll: () => (/* binding */ foldAll),
/* harmony export */   foldCode: () => (/* binding */ foldCode),
/* harmony export */   foldEffect: () => (/* binding */ foldEffect),
/* harmony export */   foldGutter: () => (/* binding */ foldGutter),
/* harmony export */   foldInside: () => (/* binding */ foldInside),
/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),
/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),
/* harmony export */   foldService: () => (/* binding */ foldService),
/* harmony export */   foldState: () => (/* binding */ foldState),
/* harmony export */   foldable: () => (/* binding */ foldable),
/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),
/* harmony export */   forceParsing: () => (/* binding */ forceParsing),
/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),
/* harmony export */   getIndentation: () => (/* binding */ getIndentation),
/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),
/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),
/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),
/* harmony export */   indentRange: () => (/* binding */ indentRange),
/* harmony export */   indentService: () => (/* binding */ indentService),
/* harmony export */   indentString: () => (/* binding */ indentString),
/* harmony export */   indentUnit: () => (/* binding */ indentUnit),
/* harmony export */   language: () => (/* binding */ language),
/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),
/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),
/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),
/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),
/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),
/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),
/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),
/* harmony export */   toggleFold: () => (/* binding */ toggleFold),
/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),
/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),
/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.js");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.js");
/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ "./node_modules/style-mod/src/style-mod.js");





var _a;
const languageDataProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();
function defineLanguageFacet(baseData) {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
        combine: baseData ? values => values.concat(baseData) : undefined
    });
}
const sublanguageProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();
class Language {
    constructor(data, parser, extraExtensions = [], name = "") {
        this.data = data;
        this.name = name;
        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty("tree"))
            Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, "tree", { get() { return syntaxTree(this); } });
        this.parser = parser;
        this.extension = [
            language.of(this),
            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side) => {
                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);
                if (!data)
                    return [];
                let base = state.facet(data), sub = top.type.prop(sublanguageProp);
                if (sub) {
                    let innerNode = top.resolve(pos - top.from, side);
                    for (let sublang of sub)
                        if (sublang.test(innerNode, state)) {
                            let data = state.facet(sublang.facet);
                            return sublang.type == "replace" ? data : data.concat(base);
                        }
                }
                return base;
            })
        ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
            return [];
        let result = [];
        let explore = (tree, from) => {
            if (tree.prop(languageDataProp) == this.data) {
                result.push({ from, to: from + tree.length });
                return;
            }
            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);
            if (mount) {
                if (mount.tree.prop(languageDataProp) == this.data) {
                    if (mount.overlay)
                        for (let r of mount.overlay)
                            result.push({ from: r.from + from, to: r.to + from });
                    else
                        result.push({ from: from, to: from + tree.length });
                    return;
                }
                else if (mount.overlay) {
                    let size = result.length;
                    explore(mount.tree, mount.overlay[0].from + from);
                    if (result.length > size)
                        return;
                }
            }
            for (let i = 0; i < tree.children.length; i++) {
                let ch = tree.children[i];
                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree)
                    explore(ch, tree.positions[i] + from);
            }
        };
        explore(syntaxTree(state), 0);
        return result;
    }
    get allowsNesting() { return true; }
}
Language.setState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();
function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
        for (let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))
            if (node.type.isTop)
                tree = node;
    }
    return tree;
}
class LRLanguage extends Language {
    constructor(data, parser, name) {
        super(data, parser, [], name);
        this.parser = parser;
    }
    static define(spec) {
        let data = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data, spec.parser.configure({
            props: [languageDataProp.add(type => type.isTop ? data : undefined)]
        }), spec.name);
    }
    configure(options, name) {
        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
    }
    get allowsNesting() { return this.parser.hasWrappers(); }
}
function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;
}
function ensureSyntaxTree(state, upto, timeout = 50) {
    var _a;
    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
    if (!parse)
        return null;
    let oldVieport = parse.viewport;
    parse.updateViewport({ from: 0, to: upto });
    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
    parse.updateViewport(oldVieport);
    return result;
}
function syntaxTreeAvailable(state, upto = state.doc.length) {
    var _a;
    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;
}
function forceParsing(view, upto = view.viewport.to, timeout = 100) {
    let success = ensureSyntaxTree(view.state, upto, timeout);
    if (success != syntaxTree(view.state))
        view.dispatch({});
    return !!success;
}
function syntaxParserRunning(view) {
    var _a;
    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;
}
class DocInput {
    constructor(doc) {
        this.doc = doc;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc.iter();
    }
    get length() { return this.doc.length; }
    syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
    }
    chunk(pos) {
        this.syncTo(pos);
        return this.string;
    }
    get lineChunks() { return true; }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
}
let currentContext = null;
class ParseContext {
    constructor(parser, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
        this.parser = parser;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        this.tempSkipped = [];
    }
    static create(parser, state, viewport) {
        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);
    }
    startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
        if (upto != null && upto >= this.state.doc.length)
            upto = undefined;
        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
            this.takeTree();
            return true;
        }
        return this.withContext(() => {
            var _a;
            if (typeof until == "number") {
                let endTime = Date.now() + until;
                until = () => Date.now() > endTime;
            }
            if (!this.parse)
                this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
                upto < this.state.doc.length)
                this.parse.stopAt(upto);
            for (;;) {
                let done = this.parse.advance();
                if (done) {
                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
                    this.tree = done;
                    this.parse = null;
                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                        this.parse = this.startParse();
                    else
                        return true;
                }
                if (until())
                    return false;
            }
        });
    }
    takeTree() {
        let pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
                this.parse.stopAt(pos);
            this.withContext(() => { while (!(tree = this.parse.advance())) { } });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));
            this.parse = null;
        }
    }
    withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
            return f();
        }
        finally {
            currentContext = prev;
        }
    }
    withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop();)
            fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
    }
    changes(changes, newState) {
        let { fragments, tree, treeLen, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);
            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;
            treeLen = 0;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
                skipped = [];
                for (let r of this.skipped) {
                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                    if (from < to)
                        skipped.push({ from, to });
                }
            }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
            return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i = 0; i < this.skipped.length; i++) {
            let { from, to } = this.skipped[i];
            if (from < viewport.to && to > viewport.from) {
                this.fragments = cutFragments(this.fragments, from, to);
                this.skipped.splice(i--, 1);
            }
        }
        if (this.skipped.length >= startLen)
            return false;
        this.reset();
        return true;
    }
    reset() {
        if (this.parse) {
            this.takeTree();
            this.parse = null;
        }
    }
    skipUntilInView(from, to) {
        this.skipped.push({ from, to });
    }
    static getSkippingParser(until) {
        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
            createParse(input, fragments, ranges) {
                let from = ranges[0].from, to = ranges[ranges.length - 1].to;
                let parser = {
                    parsedPos: from,
                    advance() {
                        let cx = currentContext;
                        if (cx) {
                            for (let r of ranges)
                                cx.tempSkipped.push(r);
                            if (until)
                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                        }
                        this.parsedPos = to;
                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);
                    },
                    stoppedAt: null,
                    stopAt() { }
                };
                return parser;
            }
        };
    }
    isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() { return currentContext; }
}
function cutFragments(fragments, from, to) {
    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
    constructor(context) {
        this.context = context;
        this.tree = context.tree;
    }
    apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree)
            return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        let upto = this.context.treeLen == tr.startState.doc.length ? undefined
            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20, upto))
            newCx.takeTree();
        return new LanguageState(newCx);
    }
    static init(state) {
        let vpTo = Math.min(3000, state.doc.length);
        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
        if (!parseState.work(20, vpTo))
            parseState.takeTree();
        return new LanguageState(parseState);
    }
}
Language.state = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({
    create: LanguageState.init,
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(Language.setState))
                return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
            return LanguageState.init(tr.state);
        return value.apply(tr);
    }
});
let requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
        let idle = -1, timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, { timeout: 500 - 100 });
        }, 100);
        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)
    ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
        this.view = view;
        this.working = null;
        this.workScheduled = 0;
        this.chunkEnd = -1;
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
            this.scheduleWork();
        if (update.docChanged || update.selectionSet) {
            if (this.view.hasFocus)
                this.chunkBudget += 50;
            this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
        if (this.working)
            return;
        let { state } = this.view, field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
            this.working = requestIdle(this.work);
    }
    work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
            this.chunkEnd = now + 30000;
            this.chunkBudget = 3000;
        }
        if (this.chunkBudget <= 0)
            return;
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000))
            return;
        let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
        let done = field.context.work(() => {
            return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 100000));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork();
        this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn
                .then(() => this.scheduleWork())
                .catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err))
                .then(() => this.workScheduled--);
            cx.scheduleOn = null;
        }
    }
    destroy() {
        if (this.working)
            this.working();
    }
    isWorking() {
        return !!(this.working || this.workScheduled > 0);
    }
}, {
    eventHandlers: { focus() { this.scheduleWork(); } }
});
const language = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(languages) { return languages.length ? languages[0] : null; },
    enables: language => [
        Language.state,
        parseWorker,
        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([language], state => {
            let lang = state.facet(language);
            return lang && lang.name ? { "data-language": lang.name } : {};
        })
    ]
});
class LanguageSupport {
    constructor(language, support = []) {
        this.language = language;
        this.support = support;
        this.extension = [language, support];
    }
}
class LanguageDescription {
    constructor(name, alias, extensions, filename, loadFunc, support = undefined) {
        this.name = name;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        this.support = support;
        this.loading = null;
    }
    load() {
        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));
    }
    static of(spec) {
        let { load, support } = spec;
        if (!load) {
            if (!support)
                throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = () => Promise.resolve(support);
        }
        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
    }
    static matchFilename(descs, filename) {
        for (let d of descs)
            if (d.filename && d.filename.test(filename))
                return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext)
            for (let d of descs)
                if (d.extensions.indexOf(ext[1]) > -1)
                    return d;
        return null;
    }
    static matchLanguageName(descs, name, fuzzy = true) {
        name = name.toLowerCase();
        for (let d of descs)
            if (d.alias.some(a => a == name))
                return d;
        if (fuzzy)
            for (let d of descs)
                for (let a of d.alias) {
                    let found = name.indexOf(a);
                    if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                        return d;
                }
        return null;
    }
}
const indentService = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const indentUnit = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine: values => {
        if (!values.length)
            return "  ";
        let unit = values[0];
        if (!unit || /\S/.test(unit) || Array.from(unit).some(e => e != unit[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
        return unit;
    }
});
function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "\t") {
        while (cols >= ts) {
            result += "\t";
            cols -= ts;
        }
        ch = " ";
    }
    for (let i = 0; i < cols; i++)
        result += ch;
    return result;
}
function getIndentation(context, pos) {
    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState)
        context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
        let result = service(context, pos);
        if (result !== undefined)
            return result;
    }
    let tree = syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
function indentRange(state, from, to) {
    let updated = Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: start => { var _a; return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1; } });
    let changes = [];
    for (let pos = from; pos <= to;) {
        let line = state.doc.lineAt(pos);
        pos = line.to + 1;
        let indent = getIndentation(context, line.from);
        if (indent == null)
            continue;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    }
    return state.changes(changes);
}
class IndentContext {
    constructor(state, options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak, simulateDoubleBreak } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos)
                return { text: "", from: pos };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
            else
                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
        }
        return line;
    }
    textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
            return "";
        let { text, from } = this.lineAt(pos, bias);
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
        if (override > -1)
            result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
    }
    countColumn(line, pos = line.length) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
            let overriden = override(from);
            if (overriden > -1)
                return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
        return this.options.simulateBreak || null;
    }
}
const indentNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();
function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
        let add = [];
        for (let cur = inner; cur && !(cur.from < stack.node.from || cur.to > stack.node.to ||
            cur.from == stack.node.from && cur.type == stack.node.type); cur = cur.parent)
            add.push(cur);
        for (let i = add.length - 1; i >= 0; i--)
            stack = { node: add[i], next: stack };
    }
    return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
    for (let cur = stack; cur; cur = cur.next) {
        let strategy = indentStrategy(cur.node);
        if (strategy)
            return strategy(TreeIndentContext.create(cx, pos, cur));
    }
    return 0;
}
function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
        return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
    }
    return tree.parent == null ? topIndent : null;
}
function topIndent() { return 0; }
class TreeIndentContext extends IndentContext {
    constructor(base, pos, context) {
        super(base.state, base.options);
        this.base = base;
        this.pos = pos;
        this.context = context;
    }
    get node() { return this.context.node; }
    static create(base, pos, context) {
        return new TreeIndentContext(base, pos, context);
    }
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    get baseIndent() {
        return this.baseIndentFor(this.node);
    }
    baseIndentFor(node) {
        let line = this.state.doc.lineAt(node.from);
        for (;;) {
            let atBreak = node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
                atBreak = atBreak.parent;
            if (isParent(atBreak, node))
                break;
            line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
    }
    continue() {
        return indentFor(this.context.next, this.base, this.pos);
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
        return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to;;) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
            return null;
        if (!next.type.isSkipped) {
            if (next.from >= lineEnd)
                return null;
            let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
            return { from: openToken.from, to: openToken.to + space };
        }
        pos = next.to;
    }
}
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
        return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
const flatIndent = (context) => context.baseIndent;
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}
const DontIndentBeyond = 200;
function indentOnInput() {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of(tr => {
        if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
            return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length)
            return tr;
        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
        if (head > line.from + DontIndentBeyond)
            return tr;
        let lineStart = doc.sliceString(line.from, head);
        if (!rules.some(r => r.test(lineStart)))
            return tr;
        let { state } = tr, last = -1, changes = [];
        for (let { head } of state.selection.ranges) {
            let line = state.doc.lineAt(head);
            if (line.from == last)
                continue;
            last = line.from;
            let indent = getIndentation(state, line.from);
            if (indent == null)
                continue;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state, indent);
            if (cur != norm)
                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
        return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
}
const foldService = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const foldNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();
function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end)
        return null;
    let stack = tree.resolveStack(end, 1);
    let found = null;
    for (let iter = stack; iter; iter = iter.next) {
        let cur = iter.node;
        if (cur.to <= end || cur.from > end)
            continue;
        if (found && cur.from < start)
            break;
        let prop = cur.type.prop(foldNodeProp);
        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
            let value = prop(cur, state);
            if (value && value.from <= end && value.from >= start && value.to > end)
                found = value;
        }
    }
    return found;
}
function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd);
        if (result)
            return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? undefined : { from, to };
}
const foldEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({ map: mapRange });
const unfoldEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({ map: mapRange });
function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
        if (lines.some(l => l.from <= head && l.to >= head))
            continue;
        lines.push(view.lineBlockAt(head));
    }
    return lines;
}
const foldState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({
    create() {
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;
    },
    update(folded, tr) {
        if (tr.isUserEvent("delete"))
            tr.changes.iterChangedRanges((fromA, toA) => folded = clearTouchedFolds(folded, fromA, toA));
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
                let { preparePlaceholder } = tr.state.facet(foldConfig);
                let widget = !preparePlaceholder ? foldWidget :
                    _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
                folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
            }
            else if (e.is(unfoldEffect)) {
                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,
                    filterFrom: e.value.from, filterTo: e.value.to });
            }
        }
        if (tr.selection)
            folded = clearTouchedFolds(folded, tr.selection.main.head);
        return folded;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),
    toJSON(folded, state) {
        let ranges = [];
        folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });
        return ranges;
    },
    fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
            throw new RangeError("Invalid JSON for fold state");
        let ranges = [];
        for (let i = 0; i < value.length;) {
            let from = value[i++], to = value[i++];
            if (typeof from != "number" || typeof to != "number")
                throw new RangeError("Invalid JSON for fold state");
            ranges.push(foldWidget.range(from, to));
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);
    }
});
function clearTouchedFolds(folded, from, to = from) {
    let touched = false;
    folded.between(from, to, (a, b) => {
        if (a < to && b > from)
            touched = true;
    });
    return !touched ? folded : folded.update({
        filterFrom: from,
        filterTo: to,
        filter: (a, b) => a >= to || b <= from
    });
}
function foldedRanges(state) {
    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;
}
function findFold(state, from, to) {
    var _a;
    let found = null;
    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
        if (!found || found.from > from)
            found = { from, to };
    });
    return found;
}
function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => {
        if (a == from && b == to)
            found = true;
    });
    return found;
}
function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));
}
const foldCode = view => {
    for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to);
        if (range) {
            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
            return true;
        }
    }
    return false;
};
const unfoldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
        view.dispatch({ effects });
    return effects.length > 0;
};
function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
const foldAll = view => {
    let { state } = view, effects = [];
    for (let pos = 0; pos < state.doc.length;) {
        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
        if (range)
            effects.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
const unfoldAll = view => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
        return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });
    view.dispatch({ effects });
    return true;
};
function foldableContainer(view, lineBlock) {
    for (let line = lineBlock;;) {
        let foldableRegion = foldable(view.state, line.from, line.to);
        if (foldableRegion && foldableRegion.to > lineBlock.from)
            return foldableRegion;
        if (!line.from)
            return null;
        line = view.lineBlockAt(line.from - 1);
    }
}
const toggleFold = (view) => {
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
        }
        else {
            let foldRange = foldableContainer(view, line);
            if (foldRange)
                effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));
        }
    }
    if (effects.length > 0)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
const foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: "…"
};
const foldConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(values) { return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig); }
});
function codeFolding(config) {
    let result = [foldState, baseTheme$1];
    if (config)
        result.push(foldConfig.of(config));
    return result;
}
function widgetToDOM(view, prepared) {
    let { state } = view, conf = state.facet(foldConfig);
    let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            view.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
    };
    if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick, prepared);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
}
const foldWidget = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({ widget: new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {
        toDOM(view) { return widgetToDOM(view, null); }
    } });
class PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {
    constructor(value) {
        super();
        this.value = value;
    }
    eq(other) { return this.value == other.value; }
    toDOM(view) { return widgetToDOM(view, this.value); }
}
const foldGutterDefaults = {
    openText: "⌄",
    closedText: "›",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
};
class FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {
    constructor(config, open) {
        super();
        this.config = config;
        this.open = open;
    }
    eq(other) { return this.config == other.config && this.open == other.open; }
    toDOM(view) {
        if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
    }
}
function foldGutter(config = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {
        constructor(view) {
            this.from = view.viewport.from;
            this.markers = this.buildMarkers(view);
        }
        update(update) {
            if (update.docChanged || update.viewportChanged ||
                update.startState.facet(language) != update.state.facet(language) ||
                update.startState.field(foldState, false) != update.state.field(foldState, false) ||
                syntaxTree(update.startState) != syntaxTree(update.state) ||
                fullConfig.foldingChanged(update))
                this.markers = this.buildMarkers(update.view);
        }
        buildMarkers(view) {
            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();
            for (let line of view.viewportLineBlocks) {
                let mark = findFold(view.state, line.from, line.to) ? canUnfold
                    : foldable(view.state, line.from, line.to) ? canFold : null;
                if (mark)
                    builder.add(line.from, line.from, mark);
            }
            return builder.finish();
        }
    });
    let { domEventHandlers } = fullConfig;
    return [
        markers,
        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({
            class: "cm-foldGutter",
            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty; },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                        return true;
                    let folded = findFold(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({ effects: unfoldEffect.of(folded) });
                        return true;
                    }
                    let range = foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({ effects: foldEffect.of(range) });
                        return true;
                    }
                    return false;
                } })
        }),
        codeFolding()
    ];
}
const baseTheme$1 = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});
class HighlightStyle {
    constructor(specs, options) {
        this.specs = specs;
        let modSpec;
        function def(spec) {
            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
        }
        const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
        const scopeOpt = options.scope;
        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data
            : scopeOpt ? (type) => type == scopeOpt : undefined;
        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map(style => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
        })), {
            all,
        }).style;
        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;
        this.themeType = options.themeType;
    }
    static define(specs, options) {
        return new HighlightStyle(specs, options || {});
    }
}
const highlighterFacet = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const fallbackHighlighter = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(values) { return values.length ? [values[0]] : null; }
});
function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
        if (highlighter.module)
            ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));
        themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
        ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
        ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme], state => {
            return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
        }));
    else
        ext.push(highlighterFacet.of(highlighter));
    return ext;
}
function highlightingFor(state, tags, scope) {
    let highlighters = getHighlighters(state);
    let result = null;
    if (highlighters)
        for (let highlighter of highlighters) {
            if (!highlighter.scope || scope && highlighter.scope(scope)) {
                let cls = highlighter.style(tags);
                if (cls)
                    result = result ? result + " " + cls : cls;
            }
        }
    return result;
}
class TreeHighlighter {
    constructor(view) {
        this.markCache = Object.create(null);
        this.tree = syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlighters(view.state));
        this.decoratedTo = view.viewport.to;
    }
    update(update) {
        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
        let styleChange = highlighters != getHighlighters(update.startState);
        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
            this.decorations = this.decorations.map(update.changes);
            this.decoratedTo = decoratedToMapped;
        }
        else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, highlighters);
            this.decoratedTo = viewport.to;
        }
    }
    buildDeco(view, highlighters) {
        if (!highlighters || !this.tree.length)
            return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;
        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();
        for (let { from, to } of view.visibleRanges) {
            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style) => {
                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: style })));
            }, from, to);
        }
        return builder.finish();
    }
}
const treeHighlighter = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {
    decorations: v => v.decorations
}));
const defaultHighlightStyle = HighlightStyle.define([
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,
        color: "#404740" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,
        textDecoration: "underline" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,
        textDecoration: "underline",
        fontWeight: "bold" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,
        fontStyle: "italic" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,
        fontWeight: "bold" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,
        textDecoration: "line-through" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,
        color: "#708" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName],
        color: "#219" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted],
        color: "#164" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted],
        color: "#a11" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)],
        color: "#e40" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),
        color: "#00f" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),
        color: "#30a" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace],
        color: "#085" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,
        color: "#167" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName],
        color: "#256" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),
        color: "#00c" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,
        color: "#940" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,
        color: "#f00" }
]);
const baseTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
const DefaultScanDist = 10000, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist,
            renderMatch: defaultRenderMatch
        });
    }
});
const matchingMark = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
    let decorations = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations.push(mark.range(match.start.from, match.start.to));
    if (match.end)
        decorations.push(mark.range(match.end.from, match.end.to));
    return decorations;
}
const bracketMatchingState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({
    create() { return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none; },
    update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
            return deco;
        let decorations = [];
        let config = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
            if (!range.empty)
                continue;
            let match = matchBrackets(tr.state, range.head, -1, config)
                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))
                || (config.afterCursor &&
                    (matchBrackets(tr.state, range.head, 1, config) ||
                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
            if (match)
                decorations = decorations.concat(config.renderMatch(match, tr.state));
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)
});
const bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme
];
function bracketMatching(config = {}) {
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}
const bracketMatchingHandle = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();
function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);
    if (byProp)
        return byProp;
    if (node.name.length == 1) {
        let index = brackets.indexOf(node.name);
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
    }
    return null;
}
function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur = node; cur; cur = cur.parent) {
        let matches = matchingNodes(cur.type, dir, brackets);
        if (matches && cur.from < cur.to) {
            let handle = findHandle(cur);
            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
                return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
        }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
        do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                    let endHandle = findHandle(cursor);
                    return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : undefined, matched: true };
                }
                else if (matchingNodes(cursor.type, dir, brackets)) {
                    depth++;
                }
                else if (matchingNodes(cursor.type, -dir, brackets)) {
                    if (depth == 0) {
                        let endHandle = findHandle(cursor);
                        return {
                            start: firstToken,
                            end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : undefined,
                            matched: false
                        };
                    }
                    depth--;
                }
            }
        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket = brackets.indexOf(startCh);
    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))
        return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {
        let text = iter.value;
        if (dir < 0)
            distance += text.length;
        let basePos = pos + distance * dir;
        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
            let found = brackets.indexOf(text[pos]);
            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)
                continue;
            if ((found % 2 == 0) == (dir > 0)) {
                depth++;
            }
            else if (depth == 1) {
                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };
            }
            else {
                depth--;
            }
        }
        if (dir > 0)
            distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
}
function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
    if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1)
            end = string.length;
    }
    let n = startValue;
    for (let i = startIndex; i < end; i++) {
        if (string.charCodeAt(i) == 9)
            n += tabSize - (n % tabSize);
        else
            n++;
    }
    return n;
}
class StringStream {
    constructor(string, tabSize, indentUnit, overrideIndent) {
        this.string = string;
        this.tabSize = tabSize;
        this.indentUnit = indentUnit;
        this.overrideIndent = overrideIndent;
        this.pos = 0;
        this.start = 0;
        this.lastColumnPos = 0;
        this.lastColumnValue = 0;
    }
    eol() { return this.pos >= this.string.length; }
    sol() { return this.pos == 0; }
    peek() { return this.string.charAt(this.pos) || undefined; }
    next() {
        if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
    }
    eat(match) {
        let ch = this.string.charAt(this.pos);
        let ok;
        if (typeof match == "string")
            ok = ch == match;
        else
            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
        if (ok) {
            ++this.pos;
            return ch;
        }
    }
    eatWhile(match) {
        let start = this.pos;
        while (this.eat(match)) { }
        return this.pos > start;
    }
    eatSpace() {
        let start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
        return this.pos > start;
    }
    skipToEnd() { this.pos = this.string.length; }
    skipTo(ch) {
        let found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
            this.pos = found;
            return true;
        }
    }
    backUp(n) { this.pos -= n; }
    column() {
        if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
        }
        return this.lastColumnValue;
    }
    indentation() {
        var _a;
        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);
    }
    match(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false)
                    this.pos += pattern.length;
                return true;
            }
            else
                return null;
        }
        else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
                return null;
            if (match && consume !== false)
                this.pos += match[0].length;
            return match;
        }
    }
    current() { return this.string.slice(this.start, this.pos); }
}
function fullParser(spec) {
    return {
        name: spec.name || "",
        token: spec.token,
        blankLine: spec.blankLine || (() => { }),
        startState: spec.startState || (() => true),
        copyState: spec.copyState || defaultCopyState,
        indent: spec.indent || (() => null),
        languageData: spec.languageData || {},
        tokenTable: spec.tokenTable || noTokens,
        mergeTokens: spec.mergeTokens !== false
    };
}
function defaultCopyState(state) {
    if (typeof state != "object")
        return state;
    let newState = {};
    for (let prop in state) {
        let val = state[prop];
        newState[prop] = (val instanceof Array ? val.slice() : val);
    }
    return newState;
}
const IndentedFrom = new WeakMap();
class StreamLanguage extends Language {
    constructor(parser) {
        let data = defineLanguageFacet(parser.languageData);
        let p = fullParser(parser), self;
        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
            createParse(input, fragments, ranges) {
                return new Parse(self, input, fragments, ranges);
            }
        };
        super(data, impl, [], parser.name);
        this.topNode = docID(data, this);
        self = this;
        this.streamParser = p;
        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({ perNode: true });
        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
    }
    static define(spec) { return new StreamLanguage(spec); }
    getIndent(cx) {
        let from = undefined;
        let { overrideIndentation } = cx.options;
        if (overrideIndentation) {
            from = IndentedFrom.get(cx.state);
            if (from != null && from < cx.pos - 1e4)
                from = undefined;
        }
        let start = findState(this, cx.node.tree, cx.node.from, cx.node.from, from !== null && from !== void 0 ? from : cx.pos), statePos, state;
        if (start) {
            state = start.state;
            statePos = start.pos + 1;
        }
        else {
            state = this.streamParser.startState(cx.unit);
            statePos = cx.node.from;
        }
        if (cx.pos - statePos > 10000)
            return null;
        while (statePos < cx.pos) {
            let line = cx.state.doc.lineAt(statePos), end = Math.min(cx.pos, line.to);
            if (line.length) {
                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;
                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);
                while (stream.pos < end - line.from)
                    readToken(this.streamParser.token, stream, state);
            }
            else {
                this.streamParser.blankLine(state, cx.unit);
            }
            if (end == cx.pos)
                break;
            statePos = line.to + 1;
        }
        let line = cx.lineAt(cx.pos);
        if (overrideIndentation && from == null)
            IndentedFrom.set(cx.state, line.from);
        return this.streamParser.indent(state, /^\s*(.*)/.exec(line.text)[1], cx);
    }
    get allowsNesting() { return false; }
}
function findState(lang, tree, off, startPos, before) {
    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
    if (state)
        return { state: lang.streamParser.copyState(state), pos: off + tree.length };
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let child = tree.children[i], pos = off + tree.positions[i];
        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);
        if (found)
            return found;
    }
    return null;
}
function cutTree(lang, tree, from, to, inside) {
    if (inside && from <= 0 && to >= tree.length)
        return tree;
    if (!inside && from == 0 && tree.type == lang.topNode)
        inside = true;
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let pos = tree.positions[i], child = tree.children[i], inner;
        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {
            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
                break;
            return !inside ? inner
                : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
        }
    }
    return null;
}
function findStartInFragments(lang, fragments, startPos, endPos, editorState) {
    for (let f of fragments) {
        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);
        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;
        if (found && found.pos <= endPos && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
            return { state: found.state, tree };
    }
    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty };
}
class Parse {
    constructor(lang, input, fragments, ranges) {
        this.lang = lang;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.stoppedAt = null;
        this.chunks = [];
        this.chunkPos = [];
        this.chunk = [];
        this.chunkReused = undefined;
        this.rangeIndex = 0;
        this.to = ranges[ranges.length - 1].to;
        let context = ParseContext.get(), from = ranges[0].from;
        let { state, tree } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);
        this.state = state;
        this.parsedPos = this.chunkStart = from + tree.length;
        for (let i = 0; i < tree.children.length; i++) {
            this.chunks.push(tree.children[i]);
            this.chunkPos.push(tree.positions[i]);
        }
        if (context && this.parsedPos < context.viewport.from - 100000 &&
            ranges.some(r => r.from <= context.viewport.from && r.to >= context.viewport.from)) {
            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
            context.skipUntilInView(this.parsedPos, context.viewport.from);
            this.parsedPos = context.viewport.from;
        }
        this.moveRangeIndex();
    }
    advance() {
        let context = ParseContext.get();
        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
        let end = Math.min(parseEnd, this.chunkStart + 2048);
        if (context)
            end = Math.min(end, context.viewport.to);
        while (this.parsedPos < end)
            this.parseLine(context);
        if (this.chunkStart < this.parsedPos)
            this.finishChunk();
        if (this.parsedPos >= parseEnd)
            return this.finish();
        if (context && this.parsedPos >= context.viewport.to) {
            context.skipUntilInView(this.parsedPos, parseEnd);
            return this.finish();
        }
        return null;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
    }
    lineAfter(pos) {
        let chunk = this.input.chunk(pos);
        if (!this.input.lineChunks) {
            let eol = chunk.indexOf("\n");
            if (eol > -1)
                chunk = chunk.slice(0, eol);
        }
        else if (chunk == "\n") {
            chunk = "";
        }
        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
    }
    nextLine() {
        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;
        for (let index = this.rangeIndex;;) {
            let rangeEnd = this.ranges[index].to;
            if (rangeEnd >= end)
                break;
            line = line.slice(0, rangeEnd - (end - line.length));
            index++;
            if (index == this.ranges.length)
                break;
            let rangeStart = this.ranges[index].from;
            let after = this.lineAfter(rangeStart);
            line += after;
            end = rangeStart + after.length;
        }
        return { line, end };
    }
    skipGapsTo(pos, offset, side) {
        for (;;) {
            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;
            if (side > 0 ? end > offPos : end >= offPos)
                break;
            let start = this.ranges[++this.rangeIndex].from;
            offset += start - end;
        }
        return offset;
    }
    moveRangeIndex() {
        while (this.ranges[this.rangeIndex].to < this.parsedPos)
            this.rangeIndex++;
    }
    emitToken(id, from, to, offset) {
        let size = 4;
        if (this.ranges.length > 1) {
            offset = this.skipGapsTo(from, offset, 1);
            from += offset;
            let len0 = this.chunk.length;
            offset = this.skipGapsTo(to, offset, -1);
            to += offset;
            size += this.chunk.length - len0;
        }
        let last = this.chunk.length - 4;
        if (this.lang.streamParser.mergeTokens && size == 4 && last >= 0 &&
            this.chunk[last] == id && this.chunk[last + 2] == from)
            this.chunk[last + 2] = to;
        else
            this.chunk.push(id, from, to, size);
        return offset;
    }
    parseLine(context) {
        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;
        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
        if (stream.eol()) {
            streamParser.blankLine(this.state, stream.indentUnit);
        }
        else {
            while (!stream.eol()) {
                let token = readToken(streamParser.token, stream, this.state);
                if (token)
                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);
                if (stream.start > 10000)
                    break;
            }
        }
        this.parsedPos = end;
        this.moveRangeIndex();
        if (this.parsedPos < this.to)
            this.parsedPos++;
    }
    finishChunk() {
        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet,
            topID: 0,
            maxBufferLength: 2048,
            reused: this.chunkReused
        });
        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
        this.chunks.push(tree);
        this.chunkPos.push(this.chunkStart - this.ranges[0].from);
        this.chunk = [];
        this.chunkReused = undefined;
        this.chunkStart = this.parsedPos;
    }
    finish() {
        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
    }
}
function readToken(token, stream, state) {
    stream.start = stream.pos;
    for (let i = 0; i < 10; i++) {
        let result = token(stream, state);
        if (stream.pos > stream.start)
            return result;
    }
    throw new Error("Stream parser failed to advance stream.");
}
const noTokens = Object.create(null);
const typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];
const nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);
const warned = [];
const byTag = Object.create(null);
const defaultTable = Object.create(null);
for (let [legacyName, name] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
])
    defaultTable[legacyName] = createTokenType(noTokens, name);
class TokenTable {
    constructor(extra) {
        this.extra = extra;
        this.table = Object.assign(Object.create(null), defaultTable);
    }
    resolve(tag) {
        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
    }
}
const defaultTokenTable = new TokenTable(noTokens);
function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
        return;
    warned.push(part);
    console.warn(msg);
}
function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name of tagStr.split(" ")) {
        let found = [];
        for (let part of name.split(".")) {
            let value = (extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part]);
            if (!value) {
                warnForPart(part, `Unknown highlighting tag ${part}`);
            }
            else if (typeof value == "function") {
                if (!found.length)
                    warnForPart(part, `Modifier ${part} used at start of tag`);
                else
                    found = found.map(value);
            }
            else {
                if (found.length)
                    warnForPart(part, `Tag ${part} used as modifier`);
                else
                    found = Array.isArray(value) ? value : [value];
            }
        }
        for (let tag of found)
            tags$1.push(tag);
    }
    if (!tags$1.length)
        return 0;
    let name = tagStr.replace(/ /g, "_"), key = name + " " + tags$1.map(t => t.id);
    let known = byTag[key];
    if (known)
        return known.id;
    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
        id: typeArray.length,
        name,
        props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({ [name]: tags$1 })]
    });
    typeArray.push(type);
    return type.id;
}
function docID(data, lang) {
    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({ id: typeArray.length, name: "Document", props: [
            languageDataProp.add(() => data),
            indentNodeProp.add(() => cx => lang.getIndent(cx))
        ], top: true });
    typeArray.push(type);
    return type;
}
function buildForLine(line) {
    return line.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line);
}
function textHasRTL(text) {
    for (let i = text.iter(); !i.next().done;)
        if (buildForLine(i.value))
            return true;
    return false;
}
function changeAddsRTL(change) {
    let added = false;
    change.iterChanges((fA, tA, fB, tB, ins) => {
        if (!added && textHasRTL(ins))
            added = true;
    });
    return added;
}
const alwaysIsolate = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({ combine: values => values.some(x => x) });
function bidiIsolates(options = {}) {
    let extensions = [isolateMarks];
    if (options.alwaysIsolate)
        extensions.push(alwaysIsolate.of(true));
    return extensions;
}
const isolateMarks = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {
    constructor(view) {
        this.always = view.state.facet(alwaysIsolate) ||
            view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR ||
            view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);
        this.hasRTL = !this.always && textHasRTL(view.state.doc);
        this.tree = syntaxTree(view.state);
        this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;
    }
    update(update) {
        let always = update.state.facet(alwaysIsolate) ||
            update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR ||
            update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);
        if (!always && !this.hasRTL && changeAddsRTL(update.changes))
            this.hasRTL = true;
        if (!always && !this.hasRTL)
            return;
        let tree = syntaxTree(update.state);
        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {
            this.tree = tree;
            this.always = always;
            this.decorations = buildDeco(update.view, tree, always);
        }
    }
}, {
    provide: plugin => {
        function access(view) {
            var _a, _b;
            return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;
        }
        return [_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access),
            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))];
    }
});
function buildDeco(view, tree, always) {
    let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();
    let ranges = view.visibleRanges;
    if (!always)
        ranges = clipRTLLines(ranges, view.state.doc);
    for (let { from, to } of ranges) {
        tree.iterate({
            enter: node => {
                let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);
                if (iso)
                    deco.add(node.from, node.to, marks[iso]);
            },
            from, to
        });
    }
    return deco.finish();
}
function clipRTLLines(ranges, doc) {
    let cur = doc.iter(), pos = 0, result = [], last = null;
    for (let { from, to } of ranges) {
        if (last && last.to > from) {
            from = last.to;
            if (from >= to)
                continue;
        }
        if (pos + cur.value.length < from) {
            cur.next(from - (pos + cur.value.length));
            pos = from;
        }
        for (;;) {
            let start = pos, end = pos + cur.value.length;
            if (!cur.lineBreak && buildForLine(cur.value)) {
                if (last && last.to > start - 10)
                    last.to = Math.min(to, end);
                else
                    result.push(last = { from: start, to: Math.min(to, end) });
            }
            if (end >= to)
                break;
            pos = end;
            cur.next();
        }
    }
    return result;
}
const marks = {
    rtl: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL }),
    ltr: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR }),
    auto: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};



/***/ }),

/***/ "./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeLintPanel: () => (/* binding */ closeLintPanel),
/* harmony export */   diagnosticCount: () => (/* binding */ diagnosticCount),
/* harmony export */   forEachDiagnostic: () => (/* binding */ forEachDiagnostic),
/* harmony export */   forceLinting: () => (/* binding */ forceLinting),
/* harmony export */   lintGutter: () => (/* binding */ lintGutter),
/* harmony export */   lintKeymap: () => (/* binding */ lintKeymap),
/* harmony export */   linter: () => (/* binding */ linter),
/* harmony export */   nextDiagnostic: () => (/* binding */ nextDiagnostic),
/* harmony export */   openLintPanel: () => (/* binding */ openLintPanel),
/* harmony export */   previousDiagnostic: () => (/* binding */ previousDiagnostic),
/* harmony export */   setDiagnostics: () => (/* binding */ setDiagnostics),
/* harmony export */   setDiagnosticsEffect: () => (/* binding */ setDiagnosticsEffect)
/* harmony export */ });
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ "./node_modules/crelt/index.js");



class SelectedDiagnostic {
    constructor(from, to, diagnostic) {
        this.from = from;
        this.to = to;
        this.diagnostic = diagnostic;
    }
}
class LintState {
    constructor(diagnostics, panel, selected) {
        this.diagnostics = diagnostics;
        this.panel = panel;
        this.selected = selected;
    }
    static init(diagnostics, panel, state) {
        let diagnosticFilter = state.facet(lintConfig).markerFilter;
        if (diagnosticFilter)
            diagnostics = diagnosticFilter(diagnostics, state);
        let sorted = diagnostics.slice().sort((a, b) => a.from - b.from || a.to - b.to);
        let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder(), active = [], pos = 0;
        for (let i = 0;;) {
            let next = i == sorted.length ? null : sorted[i];
            if (!next && !active.length)
                break;
            let from, to;
            if (active.length) {
                from = pos;
                to = active.reduce((p, d) => Math.min(p, d.to), next && next.from > from ? next.from : 1e8);
            }
            else {
                from = next.from;
                to = next.to;
                active.push(next);
                i++;
            }
            while (i < sorted.length) {
                let next = sorted[i];
                if (next.from == from && (next.to > next.from || next.to == from)) {
                    active.push(next);
                    i++;
                    to = Math.min(next.to, to);
                }
                else {
                    to = Math.min(next.from, to);
                    break;
                }
            }
            let sev = maxSeverity(active);
            if (active.some(d => d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from))) {
                deco.add(from, from, _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({
                    widget: new DiagnosticWidget(sev),
                    diagnostics: active.slice()
                }));
            }
            else {
                let markClass = active.reduce((c, d) => d.markClass ? c + " " + d.markClass : c, "");
                deco.add(from, to, _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({
                    class: "cm-lintRange cm-lintRange-" + sev + markClass,
                    diagnostics: active.slice(),
                    inclusiveEnd: active.some(a => a.to > to)
                }));
            }
            pos = to;
            for (let i = 0; i < active.length; i++)
                if (active[i].to <= pos)
                    active.splice(i--, 1);
        }
        let set = deco.finish();
        return new LintState(set, panel, findDiagnostic(set));
    }
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
        if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
            return;
        if (!found)
            found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
        else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
            return false;
        else
            found = new SelectedDiagnostic(found.from, to, found.diagnostic);
    });
    return found;
}
function hideTooltip(tr, tooltip) {
    let from = tooltip.pos, to = tooltip.end || from;
    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
    if (result != null)
        return result;
    let line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
    return {
        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
}
const setDiagnosticsEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const togglePanel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const movePanelSelection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const lintState = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() {
        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none, null, null);
    },
    update(value, tr) {
        if (tr.docChanged && value.diagnostics.size) {
            let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
            if (value.selected) {
                let selPos = tr.changes.mapPos(value.selected.from, 1);
                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
            }
            if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
                panel = null;
            value = new LintState(mapped, panel, selected);
        }
        for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
                let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
                value = LintState.init(effect.value, panel, tr.state);
            }
            else if (effect.is(togglePanel)) {
                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
            }
            else if (effect.is(movePanelSelection)) {
                value = new LintState(value.diagnostics, value.panel, effect.value);
            }
        }
        return value;
    },
    provide: f => [_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val.panel),
        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, s => s.diagnostics)]
});
function diagnosticCount(state) {
    let lint = state.field(lintState, false);
    return lint ? lint.diagnostics.size : 0;
}
const activeMark = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found, start = -1, end = -1;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
        if (pos >= from && pos <= to &&
            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {
            found = spec.diagnostics;
            start = from;
            end = to;
            return false;
        }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (found && diagnosticFilter)
        found = diagnosticFilter(found, view.state);
    if (!found)
        return null;
    return {
        pos: start,
        end: end,
        above: view.state.doc.lineAt(start).to < end,
        create() {
            return { dom: diagnosticsTooltip(view, found) };
        }
    };
}
function diagnosticsTooltip(view, diagnostics) {
    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", { class: "cm-tooltip-lint" }, diagnostics.map(d => renderDiagnostic(view, d, false)));
}
const openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });
    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, LintPanel.open);
    if (panel)
        panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
};
const closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
        return false;
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
};
const nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
        return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
        next = field.diagnostics.iter(0);
        if (!next.value || next.from == sel.from && next.to == sel.to)
            return false;
    }
    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
};
const previousDiagnostic = (view) => {
    let { state } = view, field = state.field(lintState, false);
    if (!field)
        return false;
    let sel = state.selection.main;
    let prevFrom, prevTo, lastFrom, lastTo;
    field.diagnostics.between(0, state.doc.length, (from, to) => {
        if (to < sel.to && (prevFrom == null || prevFrom < from)) {
            prevFrom = from;
            prevTo = to;
        }
        if (lastFrom == null || from > lastFrom) {
            lastFrom = from;
            lastTo = to;
        }
    });
    if (lastFrom == null || prevFrom == null && lastFrom == sel.from)
        return false;
    view.dispatch({ selection: { anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom, head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo }, scrollIntoView: true });
    return true;
};
const lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
    { key: "F8", run: nextDiagnostic }
];
const lintPlugin = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.timeout = -1;
        this.set = true;
        let { delay } = view.state.facet(lintConfig);
        this.lintTime = Date.now() + delay;
        this.run = this.run.bind(this);
        this.timeout = setTimeout(this.run, delay);
    }
    run() {
        clearTimeout(this.timeout);
        let now = Date.now();
        if (now < this.lintTime - 10) {
            this.timeout = setTimeout(this.run, this.lintTime - now);
        }
        else {
            this.set = false;
            let { state } = this.view, { sources } = state.facet(lintConfig);
            if (sources.length)
                batchResults(sources.map(s => Promise.resolve(s(this.view))), annotations => {
                    if (this.view.state.doc == state.doc)
                        this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a, b) => a.concat(b))));
                }, error => { (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, error); });
        }
    }
    update(update) {
        let config = update.state.facet(lintConfig);
        if (update.docChanged || config != update.startState.facet(lintConfig) ||
            config.needsRefresh && config.needsRefresh(update)) {
            this.lintTime = Date.now() + config.delay;
            if (!this.set) {
                this.set = true;
                this.timeout = setTimeout(this.run, config.delay);
            }
        }
    }
    force() {
        if (this.set) {
            this.lintTime = Date.now();
            this.run();
        }
    }
    destroy() {
        clearTimeout(this.timeout);
    }
});
function batchResults(promises, sink, error) {
    let collected = [], timeout = -1;
    for (let p of promises)
        p.then(value => {
            collected.push(value);
            clearTimeout(timeout);
            if (collected.length == promises.length)
                sink(collected);
            else
                timeout = setTimeout(() => sink(collected), 200);
        }, error);
}
const lintConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(input) {
        return Object.assign({ sources: input.map(i => i.source).filter(x => x != null) }, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(input.map(i => i.config), {
            delay: 750,
            markerFilter: null,
            tooltipFilter: null,
            needsRefresh: null,
            hideOn: () => null,
        }, {
            needsRefresh: (a, b) => !a ? b : !b ? a : u => a(u) || b(u)
        }));
    }
});
function linter(source, config = {}) {
    return [
        lintConfig.of({ source, config }),
        lintPlugin,
        lintExtensions
    ];
}
function forceLinting(view) {
    let plugin = view.plugin(lintPlugin);
    if (plugin)
        plugin.force();
}
function assignKeys(actions) {
    let assigned = [];
    if (actions)
        actions: for (let { name } of actions) {
            for (let i = 0; i < name.length; i++) {
                let ch = name[i];
                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {
                    assigned.push(ch);
                    continue actions;
                }
            }
            assigned.push("");
        }
    return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
    var _a;
    let keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
        let fired = false, click = (e) => {
            e.preventDefault();
            if (fired)
                return;
            fired = true;
            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
            if (found)
                action.apply(view, found.from, found.to);
        };
        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),
            (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("u", name.slice(keyIndex, keyIndex + 1)),
            name.slice(keyIndex + 1)];
        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("button", {
            type: "button",
            class: "cm-diagnosticAction",
            onclick: click,
            onmousedown: click,
            "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
        }, nameElt);
    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
class DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {
    constructor(sev) {
        super();
        this.sev = sev;
    }
    eq(other) { return other.sev == this.sev; }
    toDOM() {
        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
    }
}
class PanelItem {
    constructor(view, diagnostic) {
        this.diagnostic = diagnostic;
        this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
        this.dom = renderDiagnostic(view, diagnostic, true);
        this.dom.id = this.id;
        this.dom.setAttribute("role", "option");
    }
}
class LintPanel {
    constructor(view) {
        this.view = view;
        this.items = [];
        let onkeydown = (event) => {
            if (event.keyCode == 27) {
                closeLintPanel(this.view);
                this.view.focus();
            }
            else if (event.keyCode == 38 || event.keyCode == 33) {
                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
            }
            else if (event.keyCode == 40 || event.keyCode == 34) {
                this.moveSelection((this.selectedIndex + 1) % this.items.length);
            }
            else if (event.keyCode == 36) {
                this.moveSelection(0);
            }
            else if (event.keyCode == 35) {
                this.moveSelection(this.items.length - 1);
            }
            else if (event.keyCode == 13) {
                this.view.focus();
            }
            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
                for (let i = 0; i < keys.length; i++)
                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                        if (found)
                            diagnostic.actions[i].apply(view, found.from, found.to);
                    }
            }
            else {
                return;
            }
            event.preventDefault();
        };
        let onclick = (event) => {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].dom.contains(event.target))
                    this.moveSelection(i);
            }
        };
        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown,
            onclick
        });
        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", { class: "cm-panel-lint" }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("button", {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => closeLintPanel(this.view)
        }, "×"));
        this.update();
    }
    get selectedIndex() {
        let selected = this.view.state.field(lintState).selected;
        if (!selected)
            return -1;
        for (let i = 0; i < this.items.length; i++)
            if (this.items[i].diagnostic == selected.diagnostic)
                return i;
        return -1;
    }
    update() {
        let { diagnostics, selected } = this.view.state.field(lintState);
        let i = 0, needsSync = false, newSelectedItem = null;
        let seen = new Set();
        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
            for (let diagnostic of spec.diagnostics) {
                if (seen.has(diagnostic))
                    continue;
                seen.add(diagnostic);
                let found = -1, item;
                for (let j = i; j < this.items.length; j++)
                    if (this.items[j].diagnostic == diagnostic) {
                        found = j;
                        break;
                    }
                if (found < 0) {
                    item = new PanelItem(this.view, diagnostic);
                    this.items.splice(i, 0, item);
                    needsSync = true;
                }
                else {
                    item = this.items[found];
                    if (found > i) {
                        this.items.splice(i, found - i);
                        needsSync = true;
                    }
                }
                if (selected && item.diagnostic == selected.diagnostic) {
                    if (!item.dom.hasAttribute("aria-selected")) {
                        item.dom.setAttribute("aria-selected", "true");
                        newSelectedItem = item;
                    }
                }
                else if (item.dom.hasAttribute("aria-selected")) {
                    item.dom.removeAttribute("aria-selected");
                }
                i++;
            }
        });
        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
            needsSync = true;
            this.items.pop();
        }
        if (this.items.length == 0) {
            this.items.push(new PanelItem(this.view, {
                from: -1, to: -1,
                severity: "info",
                message: this.view.state.phrase("No diagnostics")
            }));
            needsSync = true;
        }
        if (newSelectedItem) {
            this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
            this.view.requestMeasure({
                key: this,
                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
                write: ({ sel, panel }) => {
                    let scaleY = panel.height / this.list.offsetHeight;
                    if (sel.top < panel.top)
                        this.list.scrollTop -= (panel.top - sel.top) / scaleY;
                    else if (sel.bottom > panel.bottom)
                        this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
                }
            });
        }
        else if (this.selectedIndex < 0) {
            this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync)
            this.sync();
    }
    sync() {
        let domPos = this.list.firstChild;
        function rm() {
            let prev = domPos;
            domPos = prev.nextSibling;
            prev.remove();
        }
        for (let item of this.items) {
            if (item.dom.parentNode == this.list) {
                while (domPos != item.dom)
                    rm();
                domPos = item.dom.nextSibling;
            }
            else {
                this.list.insertBefore(item.dom, domPos);
            }
        }
        while (domPos)
            rm();
    }
    moveSelection(selectedIndex) {
        if (this.selectedIndex < 0)
            return;
        let field = this.view.state.field(lintState);
        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection)
            return;
        this.view.dispatch({
            selection: { anchor: selection.from, head: selection.to },
            scrollIntoView: true,
            effects: movePanelSelection.of(selection)
        });
    }
    static open(view) { return new LintPanel(view); }
}
function svg(content, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
}
function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
const baseTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({
    ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px",
        cursor: "pointer"
    },
    ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: .7
    },
    ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x",
        paddingBottom: "0.7px",
    },
    ".cm-lintRange-error": { backgroundImage: underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: underline("orange") },
    ".cm-lintRange-info": { backgroundImage: underline("#999") },
    ".cm-lintRange-hint": { backgroundImage: underline("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
        padding: 0,
        margin: 0
    },
    ".cm-lintPoint": {
        position: "relative",
        "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
        }
    },
    ".cm-lintPoint-warning": {
        "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
        "&:after": { borderBottomColor: "#999" }
    },
    ".cm-lintPoint-hint": {
        "&:after": { borderBottomColor: "#66d" }
    },
    ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
                backgroundColor: "#ddd",
                "& u": { textDecoration: "underline" }
            },
            "&:focus [aria-selected]": {
                background_fallback: "#bdf",
                backgroundColor: "Highlight",
                color_fallback: "white",
                color: "HighlightText"
            },
            "& u": { textDecoration: "none" },
            padding: 0,
            margin: 0
        },
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        }
    }
});
function severityWeight(sev) {
    return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
    let sev = "hint", weight = 1;
    for (let d of diagnostics) {
        let w = severityWeight(d.severity);
        if (w > weight) {
            weight = w;
            sev = d.severity;
        }
    }
    return sev;
}
class LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.GutterMarker {
    constructor(diagnostics) {
        super();
        this.diagnostics = diagnostics;
        this.severity = maxSeverity(diagnostics);
    }
    toDOM(view) {
        let elt = document.createElement("div");
        elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
        let diagnostics = this.diagnostics;
        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
        if (diagnosticsFilter)
            diagnostics = diagnosticsFilter(diagnostics, view.state);
        if (diagnostics.length)
            elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
        return elt;
    }
}
function trackHoverOn(view, marker) {
    let mousemove = (event) => {
        let rect = marker.getBoundingClientRect();
        if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 &&
            event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
            return;
        for (let target = event.target; target; target = target.parentNode) {
            if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
                return;
        }
        window.removeEventListener("mousemove", mousemove);
        if (view.state.field(lintGutterTooltip))
            view.dispatch({ effects: setLintGutterTooltip.of(null) });
    };
    window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
    function hovered() {
        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
        const linePos = view.coordsAtPos(line.from);
        if (linePos) {
            view.dispatch({ effects: setLintGutterTooltip.of({
                    pos: line.from,
                    above: false,
                    clip: false,
                    create() {
                        return {
                            dom: diagnosticsTooltip(view, diagnostics),
                            getCoords: () => marker.getBoundingClientRect()
                        };
                    }
                }) });
        }
        marker.onmouseout = marker.onmousemove = null;
        trackHoverOn(view, marker);
    }
    let { hoverTime } = view.state.facet(lintGutterConfig);
    let hoverTimeout = setTimeout(hovered, hoverTime);
    marker.onmouseout = () => {
        clearTimeout(hoverTimeout);
        marker.onmouseout = marker.onmousemove = null;
    };
    marker.onmousemove = () => {
        clearTimeout(hoverTimeout);
        hoverTimeout = setTimeout(hovered, hoverTime);
    };
}
function markersForDiagnostics(doc, diagnostics) {
    let byLine = Object.create(null);
    for (let diagnostic of diagnostics) {
        let line = doc.lineAt(diagnostic.from);
        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
    }
    let markers = [];
    for (let line in byLine) {
        markers.push(new LintGutterMarker(byLine[line]).range(+line));
    }
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.of(markers, true);
}
const lintGutterExtension = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.gutter)({
    class: "cm-gutter-lint",
    markers: view => view.state.field(lintGutterMarkers),
    widgetMarker: (view, widget, block) => {
        let diagnostics = [];
        view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value) => {
            if (from > block.from && from < block.to)
                diagnostics.push(...value.diagnostics);
        });
        return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
    }
});
const lintGutterMarkers = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;
    },
    update(markers, tr) {
        markers = markers.map(tr.changes);
        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
        for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
                let diagnostics = effect.value;
                if (diagnosticFilter)
                    diagnostics = diagnosticFilter(diagnostics || [], tr.state);
                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
            }
        }
        return markers;
    }
});
const setLintGutterTooltip = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const lintGutterTooltip = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() { return null; },
    update(tooltip, tr) {
        if (tooltip && tr.docChanged)
            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
        return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);
    },
    provide: field => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(field)
});
const lintGutterTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({
    ".cm-gutter-lint": {
        width: "1.4em",
        "& .cm-gutterElement": {
            padding: ".2em"
        }
    },
    ".cm-lint-marker": {
        width: "1em",
        height: "1em"
    },
    ".cm-lint-marker-info": {
        content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
    },
    ".cm-lint-marker-warning": {
        content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`),
    },
    ".cm-lint-marker-error": {
        content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
    },
});
const lintExtensions = [
    lintState,
    _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.compute([lintState], state => {
        let { selected, panel } = state.field(lintState);
        return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set([
            activeMark.range(selected.from, selected.to)
        ]);
    }),
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.hoverTooltip)(lintTooltip, { hideOn: hideTooltip }),
    baseTheme
];
const lintGutterConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {
            hoverTime: 300,
            markerFilter: null,
            tooltipFilter: null
        });
    }
});
function lintGutter(config = {}) {
    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
}
function forEachDiagnostic(state, f) {
    let lState = state.field(lintState, false);
    if (lState && lState.diagnostics.size) {
        let pending = [], pendingStart = [], lastEnd = -1;
        for (let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.iter([lState.diagnostics]);; iter.next()) {
            for (let i = 0; i < pending.length; i++)
                if (!iter.value || iter.value.spec.diagnostics.indexOf(pending[i]) < 0) {
                    f(pending[i], pendingStart[i], lastEnd);
                    pending.splice(i, 1);
                    pendingStart.splice(i--, 1);
                }
            if (!iter.value)
                break;
            for (let d of iter.value.spec.diagnostics)
                if (pending.indexOf(d) < 0) {
                    pending.push(d);
                    pendingStart.push(iter.from);
                }
            lastEnd = iter.to;
        }
    }
}



/***/ }),

/***/ "./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegExpCursor: () => (/* binding */ RegExpCursor),
/* harmony export */   SearchCursor: () => (/* binding */ SearchCursor),
/* harmony export */   SearchQuery: () => (/* binding */ SearchQuery),
/* harmony export */   closeSearchPanel: () => (/* binding */ closeSearchPanel),
/* harmony export */   findNext: () => (/* binding */ findNext),
/* harmony export */   findPrevious: () => (/* binding */ findPrevious),
/* harmony export */   getSearchQuery: () => (/* binding */ getSearchQuery),
/* harmony export */   gotoLine: () => (/* binding */ gotoLine),
/* harmony export */   highlightSelectionMatches: () => (/* binding */ highlightSelectionMatches),
/* harmony export */   openSearchPanel: () => (/* binding */ openSearchPanel),
/* harmony export */   replaceAll: () => (/* binding */ replaceAll),
/* harmony export */   replaceNext: () => (/* binding */ replaceNext),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   searchKeymap: () => (/* binding */ searchKeymap),
/* harmony export */   searchPanelOpen: () => (/* binding */ searchPanelOpen),
/* harmony export */   selectMatches: () => (/* binding */ selectMatches),
/* harmony export */   selectNextOccurrence: () => (/* binding */ selectNextOccurrence),
/* harmony export */   selectSelectionMatches: () => (/* binding */ selectSelectionMatches),
/* harmony export */   setSearchQuery: () => (/* binding */ setSearchQuery)
/* harmony export */ });
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ "./node_modules/crelt/index.js");



const basicNormalize = typeof String.prototype.normalize == "function"
    ? x => x.normalize("NFKD") : x => x;
class SearchCursor {
    constructor(text, query, from = 0, to = text.length, normalize, test) {
        this.test = test;
        this.value = { from: 0, to: 0 };
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from, to);
        this.bufferStart = from;
        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
                return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
        }
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);
    }
    next() {
        while (this.matches.length)
            this.matches.pop();
        return this.nextOverlapping();
    }
    nextOverlapping() {
        for (;;) {
            let next = this.peek();
            if (next < 0) {
                this.done = true;
                return this;
            }
            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);
            let norm = this.normalize(str);
            if (norm.length)
                for (let i = 0, pos = start;; i++) {
                    let code = norm.charCodeAt(i);
                    let match = this.match(code, pos, this.bufferPos + this.bufferStart);
                    if (i == norm.length - 1) {
                        if (match) {
                            this.value = match;
                            return this;
                        }
                        break;
                    }
                    if (pos == start && i < str.length && str.charCodeAt(i) == code)
                        pos++;
                }
        }
    }
    match(code, pos, end) {
        let match = null;
        for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
                if (index == this.query.length - 1) {
                    match = { from: this.matches[i + 1], to: end };
                }
                else {
                    this.matches[i]++;
                    keep = true;
                }
            }
            if (!keep) {
                this.matches.splice(i, 2);
                i -= 2;
            }
        }
        if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
                match = { from: pos, to: end };
            else
                this.matches.push(1, pos);
        }
        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
            match = null;
        return match;
    }
}
if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function () { return this; };
const empty = { from: -1, to: -1, match: /.*/.exec("") };
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
class RegExpCursor {
    constructor(text, query, options, from = 0, to = text.length) {
        this.text = text;
        this.to = to;
        this.curLine = "";
        this.done = false;
        this.value = empty;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
            return new MultilineRegExpCursor(text, query, options, from, to);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.iter = text.iter();
        let startLine = text.lineAt(from);
        this.curLineStart = startLine.from;
        this.matchPos = toCharEnd(text, from);
        this.getLine(this.curLineStart);
    }
    getLine(skip) {
        this.iter.next(skip);
        if (this.iter.lineBreak) {
            this.curLine = "";
        }
        else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to)
                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
        }
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to)
            this.curLine = "";
        else
            this.getLine(0);
    }
    next() {
        for (let off = this.matchPos - this.curLineStart;;) {
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
                let from = this.curLineStart + match.index, to = from + match[0].length;
                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                if (from == this.curLineStart + this.curLine.length)
                    this.nextLine();
                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    return this;
                }
                off = this.matchPos - this.curLineStart;
            }
            else if (this.curLineStart + this.curLine.length < this.to) {
                this.nextLine();
                off = 0;
            }
            else {
                this.done = true;
                return this;
            }
        }
    }
}
const flattened = new WeakMap();
class FlattenedDoc {
    constructor(from, text) {
        this.from = from;
        this.text = text;
    }
    get to() { return this.from + this.text.length; }
    static get(doc, from, to) {
        let cached = flattened.get(doc);
        if (!cached || cached.from >= to || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc.sliceString(from, to));
            flattened.set(doc, flat);
            return flat;
        }
        if (cached.from == from && cached.to == to)
            return cached;
        let { text, from: cachedFrom } = cached;
        if (cachedFrom > from) {
            text = doc.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
        }
        if (cached.to < to)
            text += doc.sliceString(cached.to, to);
        flattened.set(doc, new FlattenedDoc(cachedFrom, text));
        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
}
class MultilineRegExpCursor {
    constructor(text, query, options, from, to) {
        this.text = text;
        this.to = to;
        this.done = false;
        this.value = empty;
        this.matchPos = toCharEnd(text, from);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000));
    }
    chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
        for (;;) {
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            if (match && !match[0] && match.index == off) {
                this.re.lastIndex = off + 1;
                match = this.re.exec(this.flat.text);
            }
            if (match) {
                let from = this.flat.from + match.index, to = from + match[0].length;
                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&
                    (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                    return this;
                }
            }
            if (this.flat.to == this.to) {
                this.done = true;
                return this;
            }
            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
    }
}
if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =
        function () { return this; };
}
function validRegExp(source) {
    try {
        new RegExp(source, baseFlags);
        return true;
    }
    catch (_a) {
        return false;
    }
}
function toCharEnd(text, pos) {
    if (pos >= text.length)
        return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)
        pos++;
    return pos;
}
function createLineDialog(view) {
    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("input", { class: "cm-textfield", name: "line", value: line });
    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("form", {
        class: "cm-gotoLine",
        onkeydown: (event) => {
            if (event.keyCode == 27) {
                event.preventDefault();
                view.dispatch({ effects: dialogEffect.of(false) });
                view.focus();
            }
            else if (event.keyCode == 13) {
                event.preventDefault();
                go();
            }
        },
        onsubmit: (event) => {
            event.preventDefault();
            go();
        }
    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("label", view.state.phrase("Go to line"), ": ", input), " ", (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")), (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("button", {
        name: "close",
        onclick: () => {
            view.dispatch({ effects: dialogEffect.of(false) });
            view.focus();
        },
        "aria-label": view.state.phrase("close"),
        type: "button"
    }, ["×"]));
    function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
        if (!match)
            return;
        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
        let [, sign, ln, cl, percent] = match;
        let col = cl ? +cl.slice(1) : 0;
        let line = ln ? +ln : startLine.number;
        if (ln && percent) {
            let pc = line / 100;
            if (sign)
                pc = pc * (sign == "-" ? -1 : 1) + (startLine.number / state.doc.lines);
            line = Math.round(state.doc.lines * pc);
        }
        else if (ln && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
        }
        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
        view.dispatch({
            effects: [dialogEffect.of(false), _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, { y: 'center' })],
            selection,
        });
        view.focus();
    }
    return { dom };
}
const dialogEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const dialogField = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() { return true; },
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(dialogEffect))
                value = e.value;
        return value;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val ? createLineDialog : null)
});
const gotoLine = view => {
    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);
    if (!panel) {
        let effects = [dialogEffect.of(true)];
        if (view.state.field(dialogField, false) == null)
            effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([dialogField, baseTheme$1]));
        view.dispatch({ effects });
        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);
    }
    if (panel)
        panel.dom.querySelector("input").select();
    return true;
};
const baseTheme$1 = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        position: "relative",
        "& label": { fontSize: "80%" },
        "& [name=close]": {
            position: "absolute",
            top: "0", bottom: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: "0"
        }
    }
});
const defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
};
const highlightConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(options) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b) => a || b,
            minSelectionLength: Math.min,
            maxMatches: Math.min
        });
    }
});
function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
        ext.push(highlightConfig.of(options));
    return ext;
}
const matchDeco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: "cm-selectionMatch" });
const mainMatchDeco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to) {
    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&
        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);
}
function insideWord(check, state, from, to) {
    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word
        && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;
}
const matchHighlighter = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let conf = view.state.facet(highlightConfig);
        let { state } = view, sel = state.selection;
        if (sel.ranges.length > 1)
            return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
            if (!conf.highlightWordAroundCursor)
                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
            let word = state.wordAt(range.head);
            if (!word)
                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
            check = state.charCategorizer(range.head);
            query = state.sliceDoc(word.from, word.to);
        }
        else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200)
                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
            if (conf.wholeWords) {
                query = state.sliceDoc(range.from, range.to);
                check = state.charCategorizer(range.head);
                if (!(insideWordBoundaries(check, state, range.from, range.to) &&
                    insideWord(check, state, range.from, range.to)))
                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
            }
            else {
                query = state.sliceDoc(range.from, range.to);
                if (!query)
                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
            }
        }
        let deco = [];
        for (let part of view.visibleRanges) {
            let cursor = new SearchCursor(state.doc, query, part.from, part.to);
            while (!cursor.next().done) {
                let { from, to } = cursor.value;
                if (!check || insideWordBoundaries(check, state, from, to)) {
                    if (range.empty && from <= range.from && to >= range.to)
                        deco.push(mainMatchDeco.range(from, to));
                    else if (from >= range.to || to <= range.from)
                        deco.push(matchDeco.range(from, to));
                    if (deco.length > conf.maxMatches)
                        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
                }
            }
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});
const defaultTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
const selectWord = ({ state, dispatch }) => {
    let { selection } = state;
    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);
    if (newSel.eq(selection))
        return false;
    dispatch(state.update({ selection: newSel }));
    return true;
};
function findNextOccurrence(state, query) {
    let { main, ranges } = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
        cursor.next();
        if (cursor.done) {
            if (cycled)
                return null;
            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
            cycled = true;
        }
        else {
            if (cycled && ranges.some(r => r.from == cursor.value.from))
                continue;
            if (fullWord) {
                let word = state.wordAt(cursor.value.from);
                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)
                    continue;
            }
            return cursor.value;
        }
    }
}
const selectNextOccurrence = ({ state, dispatch }) => {
    let { ranges } = state.selection;
    if (ranges.some(sel => sel.from === sel.to))
        return selectWord({ state, dispatch });
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))
        return false;
    let range = findNextOccurrence(state, searchedText);
    if (!range)
        return false;
    dispatch(state.update({
        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),
        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)
    }));
    return true;
};
const searchConfigFacet = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {
            top: false,
            caseSensitive: false,
            literal: false,
            regexp: false,
            wholeWord: false,
            createPanel: view => new SearchPanel(view),
            scrollToMatch: range => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)
        });
    }
});
function search(config) {
    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;
}
class SearchQuery {
    constructor(config) {
        this.search = config.search;
        this.caseSensitive = !!config.caseSensitive;
        this.literal = !!config.literal;
        this.regexp = !!config.regexp;
        this.replace = config.replace || "";
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
        this.unquoted = this.unquote(this.search);
        this.wholeWord = !!config.wholeWord;
    }
    unquote(text) {
        return this.literal ? text :
            text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
    }
    eq(other) {
        return this.search == other.search && this.replace == other.replace &&
            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&
            this.wholeWord == other.wholeWord;
    }
    create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(state, from = 0, to) {
        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({ doc: state });
        if (to == null)
            to = st.doc.length;
        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
    }
}
class QueryType {
    constructor(spec) {
        this.spec = spec;
    }
}
function stringCursor(spec, state, from, to) {
    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);
}
function stringWordTest(doc, categorizer) {
    return (from, to, buf, bufPos) => {
        if (bufPos > from || bufPos + buf.length < to) {
            bufPos = Math.max(0, from - 2);
            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
        }
        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
            categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&
            (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
                categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);
    };
}
class StringQuery extends QueryType {
    constructor(spec) {
        super(spec);
    }
    nextMatch(state, curFrom, curTo) {
        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
        if (cursor.done) {
            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();
        }
        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;
    }
    prevMatchInRange(state, from, to) {
        for (let pos = to;;) {
            let start = Math.max(from, pos - 10000 - this.spec.unquoted.length);
            let cursor = stringCursor(this.spec, state, start, pos), range = null;
            while (!cursor.nextOverlapping().done)
                range = cursor.value;
            if (range)
                return range;
            if (start == from)
                return null;
            pos -= 10000;
        }
    }
    prevMatch(state, curFrom, curTo) {
        let found = this.prevMatchInRange(state, 0, curFrom);
        if (!found)
            found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
        return found && (found.from != curFrom || found.to != curTo) ? found : null;
    }
    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }
    matchAll(state, limit) {
        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
function regexpCursor(spec, state, from, to) {
    return new RegExpCursor(state.doc, spec.search, {
        ignoreCase: !spec.caseSensitive,
        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined
    }, from, to);
}
function charBefore(str, index) {
    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);
}
function charAfter(str, index) {
    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));
}
function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length ||
        (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
            categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&
            (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
                categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);
}
class RegExpQuery extends QueryType {
    nextMatch(state, curFrom, curTo) {
        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
        if (cursor.done)
            cursor = regexpCursor(this.spec, state, 0, curFrom).next();
        return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from, to) {
        for (let size = 1;; size++) {
            let start = Math.max(from, to - size * 10000);
            let cursor = regexpCursor(this.spec, state, start, to), range = null;
            while (!cursor.next().done)
                range = cursor.value;
            if (range && (start == from || range.from > start + 10))
                return range;
            if (start == from)
                return null;
        }
    }
    prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) ||
            this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
        return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m, i) => {
            if (i == "&")
                return result.match[0];
            if (i == "$")
                return "$";
            for (let l = i.length; l > 0; l--) {
                let n = +i.slice(0, l);
                if (n > 0 && n < result.match.length)
                    return result.match[n] + i.slice(l);
            }
            return m;
        });
    }
    matchAll(state, limit) {
        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to + 250, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
const setSearchQuery = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const togglePanel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const searchState = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create(state) {
        return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setSearchQuery))
                value = new SearchState(effect.value.create(), value.panel);
            else if (effect.is(togglePanel))
                value = new SearchState(value.query, effect.value ? createSearchPanel : null);
        }
        return value;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val.panel)
});
function getSearchQuery(state) {
    let curState = state.field(searchState, false);
    return curState ? curState.query.spec : defaultQuery(state);
}
function searchPanelOpen(state) {
    var _a;
    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;
}
class SearchState {
    constructor(query, panel) {
        this.query = query;
        this.panel = panel;
    }
}
const matchMark = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
const searchHighlighter = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
        let state = update.state.field(searchState);
        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
            this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
        if (!panel || !query.spec.valid)
            return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;
        let { view } = this;
        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();
        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
            let { from, to } = ranges[i];
            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
                to = ranges[++i].to;
            query.highlight(view.state, from, to, (from, to) => {
                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);
                builder.add(from, to, selected ? selectedMatchMark : matchMark);
            });
        }
        return builder.finish();
    }
}, {
    decorations: v => v.decorations
});
function searchCommand(f) {
    return view => {
        let state = view.state.field(searchState, false);
        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
}
const findNext = searchCommand((view, { query }) => {
    let { to } = view.state.selection.main;
    let next = query.nextMatch(view.state, to, to);
    if (!next)
        return false;
    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],
        userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
});
const findPrevious = searchCommand((view, { query }) => {
    let { state } = view, { from } = state.selection.main;
    let prev = query.prevMatch(state, from, from);
    if (!prev)
        return false;
    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],
        userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
});
const selectMatches = searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state, 1000);
    if (!ranges || !ranges.length)
        return false;
    view.dispatch({
        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),
        userEvent: "select.search.matches"
    });
    return true;
});
const selectSelectionMatches = ({ state, dispatch }) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
        return false;
    let { from, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {
        if (ranges.length > 1000)
            return false;
        if (cur.value.from == from)
            main = ranges.length;
        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));
    }
    dispatch(state.update({
        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),
        userEvent: "select.search.matches"
    }));
    return true;
};
const replaceNext = searchCommand((view, { query }) => {
    let { state } = view, { from, to } = state.selection.main;
    if (state.readOnly)
        return false;
    let match = query.nextMatch(state, from, from);
    if (!match)
        return false;
    let next = match;
    let changes = [], selection, replacement;
    let effects = [];
    if (next.from == from && next.to == to) {
        replacement = state.toText(query.getReplacement(next));
        changes.push({ from: next.from, to: next.to, insert: replacement });
        next = query.nextMatch(state, next.from, next.to);
        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
    }
    let changeSet = view.state.changes(changes);
    if (next) {
        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to).map(changeSet);
        effects.push(announceMatch(view, next));
        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
    }
    view.dispatch({
        changes: changeSet,
        selection,
        effects,
        userEvent: "input.replace"
    });
    return true;
});
const replaceAll = searchCommand((view, { query }) => {
    if (view.state.readOnly)
        return false;
    let changes = query.matchAll(view.state, 1e9).map(match => {
        let { from, to } = match;
        return { from, to, insert: query.getReplacement(match) };
    });
    if (!changes.length)
        return false;
    let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
    view.dispatch({
        changes,
        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),
        userEvent: "input.replace.all"
    });
    return true;
});
function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
    var _a, _b, _c, _d, _e;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
        return fallback;
    let config = state.facet(searchConfigFacet);
    return new SearchQuery({
        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,
        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord
    });
}
function getSearchInput(view) {
    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);
    return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
    let input = getSearchInput(view);
    if (input && input == view.root.activeElement)
        input.select();
}
const openSearchPanel = view => {
    let state = view.state.field(searchState, false);
    if (state && state.panel) {
        let searchInput = getSearchInput(view);
        if (searchInput && searchInput != view.root.activeElement) {
            let query = defaultQuery(view.state, state.query.spec);
            if (query.valid)
                view.dispatch({ effects: setSearchQuery.of(query) });
            searchInput.focus();
            searchInput.select();
        }
    }
    else {
        view.dispatch({ effects: [
                togglePanel.of(true),
                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)
            ] });
    }
    return true;
};
const closeSearchPanel = view => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel)
        return false;
    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
        view.focus();
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
};
const searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Mod-Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true },
];
class SearchPanel {
    constructor(view) {
        this.view = view;
        let query = this.query = view.state.field(searchState).query.spec;
        this.commit = this.commit.bind(this);
        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
            value: query.search,
            placeholder: phrase(view, "Find"),
            "aria-label": phrase(view, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
            value: query.replace,
            placeholder: phrase(view, "Replace"),
            "aria-label": phrase(view, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: query.caseSensitive,
            onchange: this.commit
        });
        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: query.regexp,
            onchange: this.commit
        });
        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: query.wholeWord,
            onchange: this.commit
        });
        function button(name, onclick, content) {
            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("button", { class: "cm-button", name, onclick, type: "button" }, content);
        }
        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
            this.searchField,
            button("next", () => findNext(view), [phrase(view, "next")]),
            button("prev", () => findPrevious(view), [phrase(view, "previous")]),
            button("select", () => selectMatches(view), [phrase(view, "all")]),
            (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("label", null, [this.caseField, phrase(view, "match case")]),
            (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("label", null, [this.reField, phrase(view, "regexp")]),
            (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("label", null, [this.wordField, phrase(view, "by word")]),
            ...view.state.readOnly ? [] : [
                (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("br"),
                this.replaceField,
                button("replace", () => replaceNext(view), [phrase(view, "replace")]),
                button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
            ],
            (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("button", {
                name: "close",
                onclick: () => closeSearchPanel(view),
                "aria-label": phrase(view, "close"),
                type: "button"
            }, ["×"])
        ]);
    }
    commit() {
        let query = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value,
        });
        if (!query.eq(this.query)) {
            this.query = query;
            this.view.dispatch({ effects: setSearchQuery.of(query) });
        }
    }
    keydown(e) {
        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, "search-panel")) {
            e.preventDefault();
        }
        else if (e.keyCode == 13 && e.target == this.searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(this.view);
        }
        else if (e.keyCode == 13 && e.target == this.replaceField) {
            e.preventDefault();
            replaceNext(this.view);
        }
    }
    update(update) {
        for (let tr of update.transactions)
            for (let effect of tr.effects) {
                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                    this.setQuery(effect.value);
            }
    }
    setQuery(query) {
        this.query = query;
        this.searchField.value = query.search;
        this.replaceField.value = query.replace;
        this.caseField.checked = query.caseSensitive;
        this.reField.checked = query.regexp;
        this.wordField.checked = query.wholeWord;
    }
    mount() {
        this.searchField.select();
    }
    get pos() { return 80; }
    get top() { return this.view.state.facet(searchConfigFacet).top; }
}
function phrase(view, phrase) { return view.state.phrase(phrase); }
const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view.state.sliceDoc(start, end);
    if (start != line.from) {
        for (let i = 0; i < AnnounceMargin; i++)
            if (!Break.test(text[i + 1]) && Break.test(text[i])) {
                text = text.slice(i);
                break;
            }
    }
    if (end != lineEnd) {
        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
            if (!Break.test(text[i - 1]) && Break.test(text[i])) {
                text = text.slice(0, i);
                break;
            }
    }
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
const baseTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({
    ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
            marginRight: ".2em"
        },
        "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
        }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
const searchExtensions = [
    searchState,
    _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),
    baseTheme
];



/***/ }),

/***/ "./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Annotation: () => (/* binding */ Annotation),
/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),
/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),
/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),
/* harmony export */   CharCategory: () => (/* binding */ CharCategory),
/* harmony export */   Compartment: () => (/* binding */ Compartment),
/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),
/* harmony export */   EditorState: () => (/* binding */ EditorState),
/* harmony export */   Facet: () => (/* binding */ Facet),
/* harmony export */   Line: () => (/* binding */ Line),
/* harmony export */   MapMode: () => (/* binding */ MapMode),
/* harmony export */   Prec: () => (/* binding */ Prec),
/* harmony export */   Range: () => (/* binding */ Range),
/* harmony export */   RangeSet: () => (/* binding */ RangeSet),
/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),
/* harmony export */   RangeValue: () => (/* binding */ RangeValue),
/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),
/* harmony export */   StateEffect: () => (/* binding */ StateEffect),
/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),
/* harmony export */   StateField: () => (/* binding */ StateField),
/* harmony export */   Text: () => (/* binding */ Text),
/* harmony export */   Transaction: () => (/* binding */ Transaction),
/* harmony export */   codePointAt: () => (/* binding */ codePointAt),
/* harmony export */   codePointSize: () => (/* binding */ codePointSize),
/* harmony export */   combineConfig: () => (/* binding */ combineConfig),
/* harmony export */   countColumn: () => (/* binding */ countColumn),
/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),
/* harmony export */   findColumn: () => (/* binding */ findColumn),
/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)
/* harmony export */ });
/* harmony import */ var _marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @marijn/find-cluster-break */ "./node_modules/@marijn/find-cluster-break/src/index.js");

class Text {
    lineAt(pos) {
        if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
        if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(0, from, parts, 2);
        if (text.length)
            text.decompose(0, text.length, parts, 1 | 2);
        this.decompose(to, this.length, parts, 1);
        return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    append(other) {
        return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
    }
    eq(other) {
        if (other == this)
            return true;
        if (other.length != this.length || other.lines != this.lines)
            return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (let skip = start, pos = start;;) {
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                return false;
            pos += a.value.length;
            if (a.done || pos >= end)
                return true;
        }
    }
    iter(dir = 1) { return new RawTextCursor(this, dir); }
    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }
    iterLines(from, to) {
        let inner;
        if (from == null) {
            inner = this.iter();
        }
        else {
            if (to == null)
                to = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
    }
    toString() { return this.sliceString(0); }
    toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
    }
    constructor() { }
    static of(text) {
        if (text.length == 0)
            throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
            return Text.empty;
        return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
}
class TextLeaf extends Text {
    constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
    }
    get lines() { return this.text.length; }
    get children() { return null; }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
                return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
        }
    }
    decompose(from, to, target, open) {
        let text = from <= 0 && to >= this.length ? this
            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & 1) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32) {
                target.push(new TextLeaf(joined, prev.length + text.length));
            }
            else {
                let mid = joined.length >> 1;
                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
        }
        else {
            target.push(text);
        }
    }
    replace(from, to, text) {
        if (!(text instanceof TextLeaf))
            return super.replace(from, to, text);
        [from, to] = clip(this, from, to);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        let newLen = this.length + text.length - (to - from);
        if (lines.length <= 32)
            return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let line of this.text)
            target.push(line);
    }
    scanIdentical() { return 0; }
    static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32) {
                target.push(new TextLeaf(part, len));
                part = [];
                len = -1;
            }
        }
        if (len > -1)
            target.push(new TextLeaf(part, len));
        return target;
    }
}
class TextNode extends Text {
    constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
            this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
                return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
        }
    }
    decompose(from, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to >= pos) {
                let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
                if (pos >= from && end <= to && !childOpen)
                    target.push(child);
                else
                    child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
        }
    }
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
                let child = this.children[i], end = pos + child.length;
                if (from >= pos && to <= end) {
                    let updated = child.replace(from - pos, to - pos, text);
                    let totalLines = this.lines - child.lines + updated.lines;
                    if (updated.lines < (totalLines >> (5 - 1)) &&
                        updated.lines > (totalLines >> (5 + 1))) {
                        let copy = this.children.slice();
                        copy[i] = updated;
                        return new TextNode(copy, this.length - (to - from) + text.length);
                    }
                    return super.replace(pos, end, updated);
                }
                pos = end + 1;
            }
        return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let child of this.children)
            child.flatten(target);
    }
    scanIdentical(other, dir) {
        if (!(other instanceof TextNode))
            return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]
            : [this.children.length - 1, other.children.length - 1, -1, -1];
        for (;; iA += dir, iB += dir) {
            if (iA == eA || iB == eB)
                return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB)
                return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
        }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
            lines += ch.lines;
        if (lines < 32) {
            let flat = [];
            for (let ch of children)
                ch.flatten(flat);
            return new TextLeaf(flat, length);
        }
        let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
                for (let node of child.children)
                    add(node);
            }
            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                flush();
                chunked.push(child);
            }
            else if (child instanceof TextLeaf && currentLines &&
                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
                child.lines + last.lines <= 32) {
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            }
            else {
                if (currentLines + child.lines > chunk)
                    flush();
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk.push(child);
            }
        }
        function flush() {
            if (currentLines == 0)
                return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
        }
        for (let child of children)
            add(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
}
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
    let length = -1;
    for (let line of text)
        length += line.length + 1;
    return length;
}
function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
        let line = text[i], end = pos + line.length;
        if (end >= from) {
            if (end > to)
                line = line.slice(0, to - pos);
            if (pos < from)
                line = line.slice(from - pos);
            if (first) {
                target[target.length - 1] += line;
                first = false;
            }
            else
                target.push(line);
        }
        pos = end + 1;
    }
    return target;
}
function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
}
class RawTextCursor {
    constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for (;;) {
            let last = this.nodes.length - 1;
            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (dir > 0 ? size : 0)) {
                if (last == 0) {
                    this.done = true;
                    this.value = "";
                    return this;
                }
                if (dir > 0)
                    this.offsets[last - 1]++;
                this.nodes.pop();
                this.offsets.pop();
            }
            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                this.offsets[last] += dir;
                if (skip == 0) {
                    this.lineBreak = true;
                    this.value = "\n";
                    return this;
                }
                skip--;
            }
            else if (top instanceof TextLeaf) {
                let next = top.text[offset + (dir < 0 ? -1 : 0)];
                this.offsets[last] += dir;
                if (next.length > Math.max(0, skip)) {
                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                    return this;
                }
                skip -= next.length;
            }
            else {
                let next = top.children[offset + (dir < 0 ? -1 : 0)];
                if (skip > next.length) {
                    skip -= next.length;
                    this.offsets[last] += dir;
                }
                else {
                    if (dir < 0)
                        this.offsets[last]--;
                    this.nodes.push(next);
                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                }
            }
        }
    }
    next(skip = 0) {
        if (skip < 0) {
            this.nextInner(-skip, (-this.dir));
            skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
    }
}
class PartialTextCursor {
    constructor(text, start, end) {
        this.value = "";
        this.done = false;
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit)
            skip = limit;
        limit -= skip;
        let { value } = this.cursor.next(skip);
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
    }
    next(skip = 0) {
        if (skip < 0)
            skip = Math.max(skip, this.from - this.pos);
        else if (skip > 0)
            skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() { return this.cursor.lineBreak && this.value != ""; }
}
class LineCursor {
    constructor(inner) {
        this.inner = inner;
        this.afterBreak = true;
        this.value = "";
        this.done = false;
    }
    next(skip = 0) {
        let { done, lineBreak, value } = this.inner.next(skip);
        if (done && this.afterBreak) {
            this.value = "";
            this.afterBreak = false;
        }
        else if (done) {
            this.done = true;
            this.value = "";
        }
        else if (lineBreak) {
            if (this.afterBreak) {
                this.value = "";
            }
            else {
                this.afterBreak = true;
                this.next();
            }
        }
        else {
            this.value = value;
            this.afterBreak = false;
        }
        return this;
    }
    get lineBreak() { return false; }
}
if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function () { return this.iter(); };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =
        LineCursor.prototype[Symbol.iterator] = function () { return this; };
}
class Line {
    constructor(from, to, number, text) {
        this.from = from;
        this.to = to;
        this.number = number;
        this.text = text;
    }
    get length() { return this.to - this.from; }
}
function clip(text, from, to) {
    from = Math.max(0, Math.min(text.length, from));
    return [from, Math.max(from, Math.min(text.length, to))];
}
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (0,_marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(str, pos, forward, includeExtending);
}
function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
        return code0;
    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
}
function fromCodePoint(code) {
    if (code <= 0xffff)
        return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
function codePointSize(code) { return code < 0x10000 ? 1 : 2; }
const DefaultSplit = /\r\n?|\n/;
var MapMode = (function (MapMode) {
    MapMode[MapMode["Simple"] = 0] = "Simple";
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
    return MapMode;
})(MapMode || (MapMode = {}));
class ChangeDesc {
    constructor(sections) {
        this.sections = sections;
    }
    get length() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
        return result;
    }
    get newLength() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
        }
        return result;
    }
    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }
    iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
                f(posA, posB, len);
                posB += len;
            }
            else {
                posB += ins;
            }
            posA += len;
        }
    }
    iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    get invertedDesc() {
        let sections = [];
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
                sections.push(len, ins);
            else
                sections.push(ins, len);
        }
        return new ChangeDesc(sections);
    }
    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }
    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
                if (endA > pos)
                    return posB + (pos - posA);
                posB += len;
            }
            else {
                if (mode != MapMode.Simple && endA >= pos &&
                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||
                        mode == MapMode.TrackBefore && posA < pos ||
                        mode == MapMode.TrackAfter && endA > pos))
                    return null;
                if (endA > pos || endA == pos && assoc < 0 && !len)
                    return pos == posA || assoc < 0 ? posB : posB + ins;
                posB += ins;
            }
            posA = endA;
        }
        if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
    }
    touchesRange(from, to = from) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from)
                return pos < from && end > to ? "cover" : true;
            pos = end;
        }
        return false;
    }
    toString() {
        let result = "";
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
    }
    toJSON() { return this.sections; }
    static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
    }
    static create(sections) { return new ChangeDesc(sections); }
}
class ChangeSet extends ChangeDesc {
    constructor(sections, inserted) {
        super(sections);
        this.inserted = inserted;
    }
    apply(doc) {
        if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
        return doc;
    }
    mapDesc(other, before = false) { return mapSet(this, other, before, true); }
    invert(doc) {
        let sections = this.sections.slice(), inserted = [];
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
                sections[i] = ins;
                sections[i + 1] = len;
                let index = i >> 1;
                while (inserted.length < index)
                    inserted.push(Text.empty);
                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
        }
        return new ChangeSet(sections, inserted);
    }
    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }
    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }
    iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    get desc() { return ChangeDesc.create(this.sections); }
    filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i = 0, pos = 0;;) {
            let next = i == ranges.length ? 1e9 : ranges[i++];
            while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                    addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
            }
            let end = ranges[i++];
            while (pos < end) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
            }
        }
        return { changes: new ChangeSet(resultSections, resultInserted),
            filtered: ChangeDesc.create(filteredSections) };
    }
    toJSON() {
        let parts = [];
        for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
                parts.push(len);
            else if (ins == 0)
                parts.push([len]);
            else
                parts.push([len].concat(this.inserted[i >> 1].toJSON()));
        }
        return parts;
    }
    static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
            if (!force && !sections.length)
                return;
            if (pos < length)
                addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
        }
        function process(spec) {
            if (Array.isArray(spec)) {
                for (let sub of spec)
                    process(sub);
            }
            else if (spec instanceof ChangeSet) {
                if (spec.length != length)
                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                flush();
                total = total ? total.compose(spec.map(total)) : spec;
            }
            else {
                let { from, to = from, insert } = spec;
                if (from > to || from < 0 || to > length)
                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                let insLen = insText.length;
                if (from == to && insLen == 0)
                    return;
                if (from < pos)
                    flush();
                if (from > pos)
                    addSection(sections, from - pos, -1);
                addSection(sections, to - from, insLen);
                addInsert(inserted, sections, insText);
                pos = to;
            }
        }
        process(changes);
        flush(!total);
        return total;
    }
    static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json) {
        if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
                sections.push(part, -1);
            }
            else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                throw new RangeError("Invalid JSON representation of ChangeSet");
            }
            else if (part.length == 1) {
                sections.push(part[0], 0);
            }
            else {
                while (inserted.length < i)
                    inserted.push(Text.empty);
                inserted[i] = Text.of(part.slice(1));
                sections.push(part[0], inserted[i].length);
            }
        }
        return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
        return new ChangeSet(sections, inserted);
    }
}
function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
        return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len;
    else if (last >= 0 && len == 0 && sections[last] == 0)
        sections[last + 1] += ins;
    else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
    }
    else
        sections.push(len, ins);
}
function addInsert(values, sections, value) {
    if (value.length == 0)
        return;
    let index = (sections.length - 2) >> 1;
    if (index < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value);
    }
    else {
        while (values.length < index)
            values.push(Text.empty);
        values.push(value);
    }
}
function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
        let len = desc.sections[i++], ins = desc.sections[i++];
        if (ins < 0) {
            posA += len;
            posB += len;
        }
        else {
            let endA = posA, endB = posB, text = Text.empty;
            for (;;) {
                endA += len;
                endB += ins;
                if (ins && inserted)
                    text = text.append(inserted[(i - 2) >> 1]);
                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                    break;
                len = desc.sections[i++];
                ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
        }
    }
}
function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1;;) {
        if (a.done && b.len || b.done && a.len) {
            throw new Error("Mismatched change set lengths");
        }
        else if (a.ins == -1 && b.ins == -1) {
            let len = Math.min(a.len, b.len);
            addSection(sections, len, -1);
            a.forward(len);
            b.forward(len);
        }
        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
            let len = b.len;
            addSection(sections, b.ins, -1);
            while (len) {
                let piece = Math.min(a.len, len);
                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                    addSection(sections, 0, a.ins);
                    if (insert)
                        addInsert(insert, sections, a.text);
                    inserted = a.i;
                }
                a.forward(piece);
                len -= piece;
            }
            b.next();
        }
        else if (a.ins >= 0) {
            let len = 0, left = a.len;
            while (left) {
                if (b.ins == -1) {
                    let piece = Math.min(left, b.len);
                    len += piece;
                    left -= piece;
                    b.forward(piece);
                }
                else if (b.ins == 0 && b.len < left) {
                    left -= b.len;
                    b.next();
                }
                else {
                    break;
                }
            }
            addSection(sections, len, inserted < a.i ? a.ins : 0);
            if (insert && inserted < a.i)
                addInsert(insert, sections, a.text);
            inserted = a.i;
            a.forward(a.len - left);
        }
        else if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else {
            throw new Error("Mismatched change set lengths");
        }
    }
}
function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false;;) {
        if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else if (a.ins == 0) {
            addSection(sections, a.len, 0, open);
            a.next();
        }
        else if (b.len == 0 && !b.done) {
            addSection(sections, 0, b.ins, open);
            if (insert)
                addInsert(insert, sections, b.text);
            b.next();
        }
        else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
        }
        else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                addSection(sections, len, insB, open);
                if (insert && insB)
                    addInsert(insert, sections, b.text);
            }
            else if (b.ins == -1) {
                addSection(sections, a.off ? 0 : a.len, len, open);
                if (insert)
                    addInsert(insert, sections, a.textBit(len));
            }
            else {
                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                if (insert && !b.off)
                    addInsert(insert, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
        }
    }
}
class SectionIter {
    constructor(set) {
        this.set = set;
        this.i = 0;
        this.next();
    }
    next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
        }
        else {
            this.len = 0;
            this.ins = -2;
        }
        this.off = 0;
    }
    get done() { return this.ins == -2; }
    get len2() { return this.ins < 0 ? this.len : this.ins; }
    get text() {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length && !len ? Text.empty
            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
    }
    forward(len) {
        if (len == this.len)
            this.next();
        else {
            this.len -= len;
            this.off += len;
        }
    }
    forward2(len) {
        if (this.ins == -1)
            this.forward(len);
        else if (len == this.ins)
            this.next();
        else {
            this.ins -= len;
            this.off += len;
        }
    }
}
class SelectionRange {
    constructor(from, to, flags) {
        this.from = from;
        this.to = to;
        this.flags = flags;
    }
    get anchor() { return this.flags & 32 ? this.to : this.from; }
    get head() { return this.flags & 32 ? this.from : this.to; }
    get empty() { return this.from == this.to; }
    get assoc() { return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0; }
    get bidiLevel() {
        let level = this.flags & 7;
        return level == 7 ? null : level;
    }
    get goalColumn() {
        let value = this.flags >> 6;
        return value == 16777215 ? undefined : value;
    }
    map(change, assoc = -1) {
        let from, to;
        if (this.empty) {
            from = to = change.mapPos(this.from, assoc);
        }
        else {
            from = change.mapPos(this.from, 1);
            to = change.mapPos(this.to, -1);
        }
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
            return EditorSelection.range(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return EditorSelection.range(this.anchor, head);
    }
    eq(other, includeAssoc = false) {
        return this.anchor == other.anchor && this.head == other.head &&
            (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    toJSON() { return { anchor: this.anchor, head: this.head }; }
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
    }
    static create(from, to, flags) {
        return new SelectionRange(from, to, flags);
    }
}
class EditorSelection {
    constructor(ranges, mainIndex) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
        if (change.empty)
            return this;
        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
    }
    eq(other, includeAssoc = false) {
        if (this.ranges.length != other.ranges.length ||
            this.mainIndex != other.mainIndex)
            return false;
        for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
                return false;
        return true;
    }
    get main() { return this.ranges[this.mainIndex]; }
    asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range, main = true) {
        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
        return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
                return EditorSelection.normalized(ranges.slice(), mainIndex);
            pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |
            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6));
    }
    static range(anchor, head, goalColumn, bidiLevel) {
        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
        return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags)
            : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
    }
    static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex];
        ranges.sort((a, b) => a.from - b.from);
        mainIndex = ranges.indexOf(main);
        for (let i = 1; i < ranges.length; i++) {
            let range = ranges[i], prev = ranges[i - 1];
            if (range.empty ? range.from <= prev.to : range.from < prev.to) {
                let from = prev.from, to = Math.max(range.to, prev.to);
                if (i <= mainIndex)
                    mainIndex--;
                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
            }
        }
        return new EditorSelection(ranges, mainIndex);
    }
}
function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
        if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
    constructor(combine, compareInput, compare, isStatic, enables) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare;
        this.isStatic = isStatic;
        this.id = nextID++;
        this.default = combine([]);
        this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    get reader() { return this; }
    static define(config = {}) {
        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    of(value) {
        return new FacetProvider([], this, 0, value);
    }
    compute(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1, get);
    }
    computeN(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2, get);
    }
    from(field, get) {
        if (!get)
            get = x => x;
        return this.compute([field], state => get(state.field(field)));
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
    constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
    }
    dynamicSlot(addresses) {
        var _a;
        let getter = this.value;
        let compare = this.facet.compareInput;
        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
            if (dep == "doc")
                depDoc = true;
            else if (dep == "selection")
                depSel = true;
            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                depAddrs.push(addresses[dep.id]);
        }
        return {
            create(state) {
                state.values[idx] = getter(state);
                return 1;
            },
            update(state, tr) {
                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {
                    let newVal = getter(state);
                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                        state.values[idx] = newVal;
                        return 1;
                    }
                }
                return 0;
            },
            reconfigure: (state, oldState) => {
                let newVal, oldAddr = oldState.config.address[id];
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (this.dependencies.every(dep => {
                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :
                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
                        state.values[idx] = oldVal;
                        return 0;
                    }
                }
                else {
                    newVal = getter(state);
                }
                state.values[idx] = newVal;
                return 1;
            }
        };
    }
}
function compareArray(a, b, compare) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!compare(a[i], b[i]))
            return false;
    return true;
}
function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
        if (ensureAddr(state, addr) & 1)
            changed = true;
    return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map(p => addresses[p.id]);
    let providerTypes = providers.map(p => p.type);
    let dynamic = providerAddrs.filter(p => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
        let values = [];
        for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2)
                for (let val of value)
                    values.push(val);
            else
                values.push(value);
        }
        return facet.combine(values);
    }
    return {
        create(state) {
            for (let addr of providerAddrs)
                ensureAddr(state, addr);
            state.values[idx] = get(state);
            return 1;
        },
        update(state, tr) {
            if (!ensureAll(state, dynamic))
                return 0;
            let value = get(state);
            if (facet.compare(value, state.values[idx]))
                return 0;
            state.values[idx] = value;
            return 1;
        },
        reconfigure(state, oldState) {
            let depChanged = ensureAll(state, providerAddrs);
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
                state.values[idx] = oldValue;
                return 0;
            }
            let value = get(state);
            if (facet.compare(value, oldValue)) {
                state.values[idx] = oldValue;
                return 0;
            }
            state.values[idx] = value;
            return 1;
        }
    };
}
const initField = Facet.define({ static: true });
class StateField {
    constructor(id, createF, updateF, compareF, spec) {
        this.id = id;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        this.provides = undefined;
    }
    static define(config) {
        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
        if (config.provide)
            field.provides = config.provide(field);
        return field;
    }
    create(state) {
        let init = state.facet(initField).find(i => i.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
            create: (state) => {
                state.values[idx] = this.create(state);
                return 1;
            },
            update: (state, tr) => {
                let oldVal = state.values[idx];
                let value = this.updateF(oldVal, tr);
                if (this.compareF(oldVal, value))
                    return 0;
                state.values[idx] = value;
                return 1;
            },
            reconfigure: (state, oldState) => {
                let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
                if ((reInit = init.find(i => i.field == this)) && reInit != oldInit.find(i => i.field == this)) {
                    state.values[idx] = reInit.create(state);
                    return 1;
                }
                if (oldState.config.address[this.id] != null) {
                    state.values[idx] = oldState.field(this);
                    return 0;
                }
                state.values[idx] = this.create(state);
                return 1;
            }
        };
    }
    init(create) {
        return [this, initField.of({ field: this, create })];
    }
    get extension() { return this; }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
    return (ext) => new PrecExtension(ext, value);
}
const Prec = {
    highest: prec(Prec_.highest),
    high: prec(Prec_.high),
    default: prec(Prec_.default),
    low: prec(Prec_.low),
    lowest: prec(Prec_.lowest)
};
class PrecExtension {
    constructor(inner, prec) {
        this.inner = inner;
        this.prec = prec;
    }
}
class Compartment {
    of(ext) { return new CompartmentInstance(this, ext); }
    reconfigure(content) {
        return Compartment.reconfigure.of({ compartment: this, extension: content });
    }
    get(state) {
        return state.config.compartments.get(this);
    }
}
class CompartmentInstance {
    constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
    }
}
class Configuration {
    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
        this.base = base;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base, compartments, oldState) {
        let fields = [];
        let facets = Object.create(null);
        let newCompartments = new Map();
        for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
                fields.push(ext);
            else
                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => field.slot(a));
        }
        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id] || [];
            if (providers.every(p => p.type == 0)) {
                address[facet.id] = (staticValues.length << 1) | 1;
                if (sameArray(oldProviders, providers)) {
                    staticValues.push(oldState.facet(facet));
                }
                else {
                    let value = facet.combine(providers.map(p => p.value));
                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                }
            }
            else {
                for (let p of providers) {
                    if (p.type == 0) {
                        address[p.id] = (staticValues.length << 1) | 1;
                        staticValues.push(p.value);
                    }
                    else {
                        address[p.id] = dynamicSlots.length << 1;
                        dynamicSlots.push(a => p.dynamicSlot(a));
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
            }
        }
        let dynamic = dynamicSlots.map(f => f(address));
        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
    }
}
function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec) {
        let known = seen.get(ext);
        if (known != null) {
            if (known <= prec)
                return;
            let found = result[known].indexOf(ext);
            if (found > -1)
                result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
                newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec);
        if (Array.isArray(ext)) {
            for (let e of ext)
                inner(e, prec);
        }
        else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
                throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec);
        }
        else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
        }
        else if (ext instanceof StateField) {
            result[prec].push(ext);
            if (ext.provides)
                inner(ext.provides, prec);
        }
        else if (ext instanceof FacetProvider) {
            result[prec].push(ext);
            if (ext.facet.extensions)
                inner(ext.facet.extensions, Prec_.default);
        }
        else {
            let content = ext.extension;
            if (!content)
                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec);
        }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
    if (addr & 1)
        return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
        return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = Facet.define();
const allowMultipleSelections = Facet.define({
    combine: values => values.some(v => v),
    static: true
});
const lineSeparator = Facet.define({
    combine: values => values.length ? values[0] : undefined,
    static: true
});
const changeFilter = Facet.define();
const transactionFilter = Facet.define();
const transactionExtender = Facet.define();
const readOnly = Facet.define({
    combine: values => values.length ? values[0] : false
});
class Annotation {
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
    static define() { return new AnnotationType(); }
}
class AnnotationType {
    of(value) { return new Annotation(this, value); }
}
class StateEffectType {
    constructor(map) {
        this.map = map;
    }
    of(value) { return new StateEffect(this, value); }
}
class StateEffect {
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
    map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) { return this.type == type; }
    static define(spec = {}) {
        return new StateEffectType(spec.map || (v => v));
    }
    static mapEffects(effects, mapping) {
        if (!effects.length)
            return effects;
        let result = [];
        for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
                result.push(mapped);
        }
        return result;
    }
}
StateEffect.reconfigure = StateEffect.define();
StateEffect.appendConfig = StateEffect.define();
class Transaction {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView;
        this._doc = null;
        this._state = null;
        if (selection)
            checkSelection(selection, changes.newLength);
        if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState, changes, selection, effects, annotations, scrollIntoView) {
        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
    }
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
        if (!this._state)
            this.startState.applyTransaction(this);
        return this._state;
    }
    annotation(type) {
        for (let ann of this.annotations)
            if (ann.type == type)
                return ann.value;
        return undefined;
    }
    get docChanged() { return !this.changes.empty; }
    get reconfigured() { return this.startState.config != this.state.config; }
    isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
}
Transaction.time = Annotation.define();
Transaction.userEvent = Annotation.define();
Transaction.addToHistory = Annotation.define();
Transaction.remote = Annotation.define();
function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0;;) {
        let from, to;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
        }
        else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
        }
        else
            return result;
        if (!result.length || result[result.length - 1] < from)
            result.push(from, to);
        else if (result[result.length - 1] < to)
            result[result.length - 1] = to;
    }
}
function mergeTransaction(a, b, sequential) {
    var _a;
    let mapForA, mapForB, changes;
    if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
    }
    else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
    }
    return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
}
function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
        changes: spec.changes instanceof ChangeSet ? spec.changes
            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
    };
}
function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
        filter = false;
    for (let i = 1; i < specs.length; i++) {
        if (specs[i].filter === false)
            filter = false;
        let seq = !!specs[i].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
        let value = filter(tr);
        if (value === false) {
            result = false;
            break;
        }
        if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
        let changes, back;
        if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
        }
        else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
        }
        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
        let filtered = filters[i](tr);
        if (filtered instanceof Transaction)
            tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr = filtered[0];
        else
            tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
}
function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
        let extension = extenders[i](tr);
        if (extension && Object.keys(extension).length)
            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = (function (CharCategory) {
    CharCategory[CharCategory["Word"] = 0] = "Word";
    CharCategory[CharCategory["Space"] = 1] = "Space";
    CharCategory[CharCategory["Other"] = 2] = "Other";
    return CharCategory;
})(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
    wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
}
catch (_) { }
function hasWordChar(str) {
    if (wordChar)
        return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
        let ch = str[i];
        if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
            return true;
    }
    return false;
}
function makeCategorizer(wordChars) {
    return (char) => {
        if (!/\S/.test(char))
            return CharCategory.Space;
        if (hasWordChar(char))
            return CharCategory.Word;
        for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
                return CharCategory.Word;
        return CharCategory.Other;
    };
}
class EditorState {
    constructor(config, doc, selection, values, computeSlot, tr) {
        this.config = config;
        this.doc = doc;
        this.selection = selection;
        this.values = values;
        this.status = config.statusTemplate.slice();
        this.computeSlot = computeSlot;
        if (tr)
            tr._state = this;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
        this.computeSlot = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require)
                throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    update(...specs) {
        return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
        let conf = this.config, { base, compartments } = conf;
        for (let effect of tr.effects) {
            if (effect.is(Compartment.reconfigure)) {
                if (conf) {
                    compartments = new Map;
                    conf.compartments.forEach((val, key) => compartments.set(key, val));
                    conf = null;
                }
                compartments.set(effect.value.compartment, effect.value.extension);
            }
            else if (effect.is(StateEffect.reconfigure)) {
                conf = null;
                base = effect.value;
            }
            else if (effect.is(StateEffect.appendConfig)) {
                conf = null;
                base = asArray(base).concat(effect.value);
            }
        }
        let startValues;
        if (!conf) {
            conf = Configuration.resolve(base, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
            startValues = intermediateState.values;
        }
        else {
            startValues = tr.startState.values.slice();
        }
        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text) {
        if (typeof text == "string")
            text = this.toText(text);
        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },
            range: EditorSelection.cursor(range.from + text.length) }));
    }
    changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects = asArray(result1.effects);
        for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j = 0; j < i; j++)
                ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
        };
    }
    changes(spec = []) {
        if (spec instanceof ChangeSet)
            return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string) {
        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
            return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    toJSON(fields) {
        let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (fields)
            for (let prop in fields) {
                let value = fields[prop];
                if (value instanceof StateField && this.config.address[value.id] != null)
                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
        return result;
    }
    static fromJSON(json, config = {}, fields) {
        if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
            for (let prop in fields) {
                if (Object.prototype.hasOwnProperty.call(json, prop)) {
                    let field = fields[prop], value = json[prop];
                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
                }
            }
        return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
        });
    }
    static create(config = {}) {
        let configuration = Configuration.resolve(config.extensions || [], new Map);
        let doc = config.doc instanceof Text ? config.doc
            : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = !config.selection ? EditorSelection.single(0)
            : config.selection instanceof EditorSelection ? config.selection
                : EditorSelection.single(config.selection.anchor, config.selection.head);
        checkSelection(selection, doc.length);
        if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() { return this.facet(EditorState.tabSize); }
    get lineBreak() { return this.facet(EditorState.lineSeparator) || "\n"; }
    get readOnly() { return this.facet(readOnly); }
    phrase(phrase, ...insert) {
        for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase)) {
                phrase = map[phrase];
                break;
            }
        if (insert.length)
            phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
                if (i == "$")
                    return "$";
                let n = +(i || 1);
                return !n || n > insert.length ? m : insert[n - 1];
            });
        return phrase;
    }
    languageDataAt(name, pos, side = -1) {
        let values = [];
        for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos, side)) {
                if (Object.prototype.hasOwnProperty.call(result, name))
                    values.push(result[name]);
            }
        }
        return values;
    }
    charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
        let { text, from, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from, end = pos - from;
        while (start > 0) {
            let prev = findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != CharCategory.Word)
                break;
            start = prev;
        }
        while (end < length) {
            let next = findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != CharCategory.Word)
                break;
            end = next;
        }
        return start == end ? null : EditorSelection.range(start + from, end + from);
    }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = Facet.define({
    combine: values => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = Facet.define({
    compare(a, b) {
        let kA = Object.keys(a), kB = Object.keys(b);
        return kA.length == kB.length && kA.every(k => a[k] == b[k]);
    }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();
function combineConfig(configs, defaults, combine = {}) {
    let result = {};
    for (let config of configs)
        for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === undefined)
                result[key] = value;
            else if (current === value || value === undefined)
                ;
            else if (Object.hasOwnProperty.call(combine, key))
                result[key] = combine[key](current, value);
            else
                throw new Error("Config merge conflict for field " + key);
        }
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}
class RangeValue {
    eq(other) { return this == other; }
    range(from, to = from) { return Range.create(from, to, this); }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
class Range {
    constructor(from, to, value) {
        this.from = from;
        this.to = to;
        this.value = value;
    }
    static create(from, to, value) {
        return new Range(from, to, value);
    }
}
function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
    constructor(from, to, value, maxPoint) {
        this.from = from;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
    }
    get length() { return this.to[this.to.length - 1]; }
    findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for (let lo = startAt, hi = arr.length;;) {
            if (lo == hi)
                return lo;
            let mid = (lo + hi) >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo)
                return diff >= 0 ? lo : hi;
            if (diff >= 0)
                hi = mid;
            else
                lo = mid + 1;
        }
    }
    between(offset, from, to, f) {
        for (let i = this.findIndex(from, -1000000000, true), e = this.findIndex(to, 1000000000, false, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                return false;
    }
    map(offset, changes) {
        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
        for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                if (mapped == null)
                    continue;
                newFrom = newTo = mapped;
                if (val.startSide != val.endSide) {
                    newTo = changes.mapPos(curFrom, val.endSide);
                    if (newTo < newFrom)
                        continue;
                }
            }
            else {
                newFrom = changes.mapPos(curFrom, val.startSide);
                newTo = changes.mapPos(curTo, val.endSide);
                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                    continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                continue;
            if (newPos < 0)
                newPos = newFrom;
            if (val.point)
                maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
        }
        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
}
class RangeSet {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
        if (this.isEmpty)
            return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
            size += chunk.value.length;
        return size;
    }
    chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter = updateSpec.filter;
        if (add.length == 0 && !filter)
            return this;
        if (sort)
            add = add.slice().sort(cmpRange);
        if (this.isEmpty)
            return add.length ? RangeSet.of(add) : this;
        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                let range = add[i++];
                if (!builder.addInner(range.from, range.to, range.value))
                    spill.push(range);
            }
            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&
                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&
                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                cur.nextChunk();
            }
            else {
                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                    if (!builder.addInner(cur.from, cur.to, cur.value))
                        spill.push(Range.create(cur.from, cur.to, cur.value));
                }
                cur.next();
            }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty
            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    map(changes) {
        if (changes.empty || this.isEmpty)
            return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
                maxPoint = Math.max(maxPoint, chunk.maxPoint);
                chunks.push(chunk);
                chunkPos.push(changes.mapPos(start));
            }
            else if (touch === true) {
                let { mapped, pos } = chunk.map(start, changes);
                if (mapped) {
                    maxPoint = Math.max(maxPoint, mapped.maxPoint);
                    chunks.push(mapped);
                    chunkPos.push(pos);
                }
            }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
        if (this.isEmpty)
            return;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to >= start && from <= start + chunk.length &&
                chunk.between(start, from - start, to - start, f) === false)
                return;
        }
        this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
        return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() { return this.nextLayer == this; }
    static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
        if (to == null)
            to = 1000000000 - 1;
        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
        if (a.length != b.length)
            return false;
        if (!a.length)
            return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
        for (;;) {
            if (sideA.to != sideB.to ||
                !sameValues(sideA.active, sideB.active) ||
                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
                return false;
            if (sideA.to > to)
                return true;
            sideA.next();
            sideB.next();
        }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
        let openRanges = cursor.openStart;
        for (;;) {
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
                let active = cursor.activeForPoint(cursor.to);
                let openCount = cursor.pointFrom < from ? active.length + 1
                    : cursor.point.startSide < 0 ? active.length
                        : Math.min(active.length, openRanges);
                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
                openRanges = Math.min(cursor.openEnd(curTo), active.length);
            }
            else if (curTo > pos) {
                iterator.span(pos, curTo, cursor.active, openRanges);
                openRanges = cursor.openEnd(curTo);
            }
            if (cursor.to > to)
                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
            pos = cursor.to;
            cursor.next();
        }
    }
    static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
            build.add(range.from, range.to, range.value);
        return build.finish();
    }
    static join(sets) {
        if (!sets.length)
            return RangeSet.empty;
        let result = sets[sets.length - 1];
        for (let i = sets.length - 2; i >= 0; i--) {
            for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)
                result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
        }
        return result;
    }
}
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(ranges) {
    if (ranges.length > 1)
        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
            let cur = ranges[i];
            if (cmpRange(prev, cur) > 0)
                return ranges.slice().sort(cmpRange);
            prev = cur;
        }
    return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
    finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
        }
    }
    constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1000000000;
        this.lastTo = -1000000000;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
    }
    add(from, to, value) {
        if (!this.addInner(from, to, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
    }
    addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
            return false;
        if (this.from.length == 250)
            this.finishChunk(true);
        if (this.chunkStart < 0)
            this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
    }
    addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
        if (this.from.length)
            this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
    }
    finish() { return this.finishInner(RangeSet.empty); }
    finishInner(next) {
        if (this.from.length)
            this.finishChunk(false);
        if (this.chunks.length == 0)
            return next;
        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null;
        return result;
    }
}
function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)
        for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint <= 0)
                inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
        for (let i = 0; i < set.chunk.length; i++) {
            let known = inA.get(set.chunk[i]);
            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&
                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
                shared.add(set.chunk[i]);
        }
    return shared;
}
class LayerCursor {
    constructor(layer, skip, minPoint, rank = 0) {
        this.layer = layer;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    get endSide() { return this.value ? this.value.endSide : 0; }
    goto(pos, side = -1000000000) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
    }
    gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) ||
                this.layer.chunkEnd(this.chunkIndex) < pos ||
                next.maxPoint < this.minPoint))
                break;
            this.chunkIndex++;
            forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex)
                this.setRangeIndex(rangeIndex);
        }
        this.next();
    }
    forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
    }
    next() {
        for (;;) {
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1000000000;
                this.value = null;
                break;
            }
            else {
                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                let from = chunkPos + chunk.from[this.rangeIndex];
                this.from = from;
                this.to = chunkPos + chunk.to[this.rangeIndex];
                this.value = chunk.value[this.rangeIndex];
                this.setRangeIndex(this.rangeIndex + 1);
                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                    break;
            }
        }
    }
    setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                    this.chunkIndex++;
            }
            this.rangeIndex = 0;
        }
        else {
            this.rangeIndex = index;
        }
    }
    nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
    }
    compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||
            this.to - other.to || this.endSide - other.endSide;
    }
}
class HeapCursor {
    constructor(heap) {
        this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
                if (cur.maxPoint >= minPoint)
                    heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    goto(pos, side = -1000000000) {
        for (let cur of this.heap)
            cur.goto(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        this.next();
        return this;
    }
    forward(pos, side) {
        for (let cur of this.heap)
            cur.forward(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
    }
    next() {
        if (this.heap.length == 0) {
            this.from = this.to = 1000000000;
            this.value = null;
            this.rank = -1;
        }
        else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
                top.next();
            heapBubble(this.heap, 0);
        }
    }
}
function heapBubble(heap, index) {
    for (let cur = heap[index];;) {
        let childIndex = (index << 1) + 1;
        if (childIndex >= heap.length)
            break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
        }
        if (cur.compare(child) < 0)
            break;
        heap[childIndex] = cur;
        heap[index] = child;
        index = childIndex;
    }
}
class SpanCursor {
    constructor(sets, skip, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1000000000;
        this.endSide = 0;
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1000000000) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
    }
    forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
    }
    removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
        let i = 0, { value, to, rank } = this.cursor;
        while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
            i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
        let from = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null;
        for (;;) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[a] > from) {
                    this.to = this.activeTo[a];
                    this.endSide = this.active[a].endSide;
                    break;
                }
                this.removeActive(a);
                if (trackOpen)
                    remove(trackOpen, a);
            }
            else if (!this.cursor.value) {
                this.to = this.endSide = 1000000000;
                break;
            }
            else if (this.cursor.from > from) {
                this.to = this.cursor.from;
                this.endSide = this.cursor.startSide;
                break;
            }
            else {
                let nextVal = this.cursor.value;
                if (!nextVal.point) {
                    this.addActive(trackOpen);
                    this.cursor.next();
                }
                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                    this.cursor.next();
                }
                else {
                    this.point = nextVal;
                    this.pointFrom = this.cursor.from;
                    this.pointRank = this.cursor.rank;
                    this.to = this.cursor.to;
                    this.endSide = nextVal.endSide;
                    this.cursor.next();
                    this.forward(this.to, this.endSide);
                    break;
                }
            }
        }
        if (trackOpen) {
            this.openStart = 0;
            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
                this.openStart++;
        }
    }
    activeForPoint(to) {
        if (!this.active.length)
            return this.active;
        let active = [];
        for (let i = this.active.length - 1; i >= 0; i--) {
            if (this.activeRank[i] < this.pointRank)
                break;
            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
                active.push(this.active[i]);
        }
        return active.reverse();
    }
    openEnd(to) {
        let open = 0;
        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
            open++;
        return open;
    }
}
function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (;;) {
        let dEnd = (a.to + dPos) - b.to, diff = dEnd || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&
                sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
                comparator.comparePoint(pos, clipEnd, a.point, b.point);
        }
        else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
                comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB)
            break;
        if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)
            comparator.boundChange(end);
        pos = end;
        if (diff <= 0)
            a.next();
        if (diff >= 0)
            b.next();
    }
}
function sameValues(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
    return true;
}
function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
        array[i] = array[i + 1];
    array.pop();
}
function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
        array[i + 1] = array[i];
    array[index] = value;
}
function findMinIndex(value, array) {
    let found = -1, foundPos = 1000000000;
    for (let i = 0; i < array.length; i++)
        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
        }
    return found;
}
function countColumn(string, tabSize, to = string.length) {
    let n = 0;
    for (let i = 0; i < to && i < string.length;) {
        if (string.charCodeAt(i) == 9) {
            n += tabSize - (n % tabSize);
            i++;
        }
        else {
            n++;
            i = findClusterBreak(string, i);
        }
    }
    return n;
}
function findColumn(string, col, tabSize, strict) {
    for (let i = 0, n = 0;;) {
        if (n >= col)
            return i;
        if (i == string.length)
            break;
        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
        i = findClusterBreak(string, i);
    }
    return strict === true ? -1 : string.length;
}



/***/ }),

/***/ "./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),
/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),
/* harmony export */   BlockType: () => (/* binding */ BlockType),
/* harmony export */   Decoration: () => (/* binding */ Decoration),
/* harmony export */   Direction: () => (/* binding */ Direction),
/* harmony export */   EditorView: () => (/* binding */ EditorView),
/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),
/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),
/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),
/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),
/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),
/* harmony export */   WidgetType: () => (/* binding */ WidgetType),
/* harmony export */   __test: () => (/* binding */ __test),
/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),
/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),
/* harmony export */   drawSelection: () => (/* binding */ drawSelection),
/* harmony export */   dropCursor: () => (/* binding */ dropCursor),
/* harmony export */   getDialog: () => (/* binding */ getDialog),
/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),
/* harmony export */   getPanel: () => (/* binding */ getPanel),
/* harmony export */   getTooltip: () => (/* binding */ getTooltip),
/* harmony export */   gutter: () => (/* binding */ gutter),
/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),
/* harmony export */   gutterWidgetClass: () => (/* binding */ gutterWidgetClass),
/* harmony export */   gutters: () => (/* binding */ gutters),
/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),
/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),
/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),
/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),
/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),
/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),
/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),
/* harmony export */   keymap: () => (/* binding */ keymap),
/* harmony export */   layer: () => (/* binding */ layer),
/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),
/* harmony export */   lineNumberWidgetMarker: () => (/* binding */ lineNumberWidgetMarker),
/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),
/* harmony export */   logException: () => (/* binding */ logException),
/* harmony export */   panels: () => (/* binding */ panels),
/* harmony export */   placeholder: () => (/* binding */ placeholder),
/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),
/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),
/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),
/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),
/* harmony export */   showDialog: () => (/* binding */ showDialog),
/* harmony export */   showPanel: () => (/* binding */ showPanel),
/* harmony export */   showTooltip: () => (/* binding */ showTooltip),
/* harmony export */   tooltips: () => (/* binding */ tooltips)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ "./node_modules/style-mod/src/style-mod.js");
/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.js");
/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crelt */ "./node_modules/crelt/index.js");




function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
        target = root.getSelection ? root : root.ownerDocument;
    }
    else {
        target = root;
    }
    return target.getSelection();
}
function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode)
        return false;
    try {
        return contains(dom, selection.anchorNode);
    }
    catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
        return dom.getClientRects();
    else
        return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1)) : false;
}
function domIndex(node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
                return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
                return false;
            off = dir < 0 ? maxOffset(node) : 0;
        }
        else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
        return {
            left: 0, right: vp.width,
            top: 0, bottom: vp.height
        };
    return { left: 0, right: win.innerWidth,
        top: 0, bottom: win.innerHeight };
}
function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
        scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
        scaleY = 1;
    return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop;) {
        if (cur.nodeType == 1) {
            let bounding, top = cur == doc.body;
            let scaleX = 1, scaleY = 1;
            if (top) {
                bounding = windowRect(win);
            }
            else {
                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
                    stop = true;
                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                    cur = cur.assignedSlot || cur.parentNode;
                    continue;
                }
                let rect = cur.getBoundingClientRect();
                ({ scaleX, scaleY } = getScale(cur, rect));
                bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,
                    top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
                if (rect.top < bounding.top) {
                    moveY = rect.top - (bounding.top + yMargin);
                    if (side > 0 && rect.bottom > bounding.bottom + moveY)
                        moveY = rect.bottom - bounding.bottom + yMargin;
                }
                else if (rect.bottom > bounding.bottom) {
                    moveY = rect.bottom - bounding.bottom + yMargin;
                    if (side < 0 && (rect.top - moveY) < bounding.top)
                        moveY = rect.top - (bounding.top + yMargin);
                }
            }
            else {
                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :
                    y == "start" || y == "center" && side < 0 ? rect.top - yMargin :
                        rect.bottom - boundingHeight + yMargin;
                moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
                if (rect.left < bounding.left) {
                    moveX = rect.left - (bounding.left + xMargin);
                    if (side > 0 && rect.right > bounding.right + moveX)
                        moveX = rect.right - bounding.right + xMargin;
                }
                else if (rect.right > bounding.right) {
                    moveX = rect.right - bounding.right + xMargin;
                    if (side < 0 && rect.left < bounding.left + moveX)
                        moveX = rect.left - (bounding.left + xMargin);
                }
            }
            else {
                let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :
                    (x == "start") == ltr ? rect.left - xMargin :
                        rect.right - (bounding.right - bounding.left) + xMargin;
                moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
                if (top) {
                    win.scrollBy(moveX, moveY);
                }
                else {
                    let movedX = 0, movedY = 0;
                    if (moveY) {
                        let start = cur.scrollTop;
                        cur.scrollTop += moveY / scaleY;
                        movedY = (cur.scrollTop - start) * scaleY;
                    }
                    if (moveX) {
                        let start = cur.scrollLeft;
                        cur.scrollLeft += moveX / scaleX;
                        movedX = (cur.scrollLeft - start) * scaleX;
                    }
                    rect = { left: rect.left - movedX, top: rect.top - movedY,
                        right: rect.right - movedX, bottom: rect.bottom - movedY };
                    if (movedX && Math.abs(movedX - moveX) < 1)
                        x = "nearest";
                    if (movedY && Math.abs(movedY - moveY) < 1)
                        y = "nearest";
                }
            }
            if (top)
                break;
            if (rect.top < bounding.top || rect.bottom > bounding.bottom ||
                rect.left < bounding.left || rect.right > bounding.right)
                rect = { left: Math.max(rect.left, bounding.left), right: Math.min(rect.right, bounding.right),
                    top: Math.max(rect.top, bounding.top), bottom: Math.min(rect.bottom, bounding.bottom) };
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) {
            cur = cur.host;
        }
        else {
            break;
        }
    }
}
function scrollableParents(dom) {
    let doc = dom.ownerDocument, x, y;
    for (let cur = dom.parentNode; cur;) {
        if (cur == doc.body || (x && y)) {
            break;
        }
        else if (cur.nodeType == 1) {
            if (!y && cur.scrollHeight > cur.clientHeight)
                y = cur;
            if (!x && cur.scrollWidth > cur.clientWidth)
                x = cur;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) {
            cur = cur.host;
        }
        else {
            break;
        }
    }
    return { x, y };
}
class DOMSelectionState {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
        let { anchorNode, focusNode } = range;
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
    }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive();
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft);
        if (cur == cur.ownerDocument)
            break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i = 0; i < stack.length;) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
                elt.scrollTop = top;
            if (elt.scrollLeft != left)
                elt.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}
function dispatchKey(elt, name, code, mods) {
    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
    if (mods)
        ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
    while (node) {
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
        node = node.assignedSlot || node.parentNode;
    }
    return null;
}
function clearAttributes(node) {
    while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
        return false;
    offset = Math.min(offset, maxOffset(node));
    for (;;) {
        if (offset) {
            if (node.nodeType != 1)
                return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
                offset--;
            else {
                node = prev;
                offset = maxOffset(node);
            }
        }
        else if (node == doc) {
            return true;
        }
        else {
            offset = domIndex(node);
            node = node.parentNode;
        }
    }
}
function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset > 0) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset > 0) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node);
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}
function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset < node.nodeValue.length) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset < node.childNodes.length) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset];
            offset = 0;
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node) + 1;
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}
class DOMPos {
    constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
}
const noChildren = [];
class ContentView {
    constructor() {
        this.parent = null;
        this.dom = null;
        this.flags = 2;
    }
    get overrideDOMText() { return null; }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
            if (child == view)
                return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    sync(view, track) {
        if (this.flags & 2) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
                if (child.flags & 7) {
                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                        let contentView = ContentView.get(next);
                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                            child.reuseDOM(next);
                    }
                    child.sync(view, track);
                    child.flags &= ~7;
                }
                next = prev ? prev.nextSibling : parent.firstChild;
                if (track && !track.written && track.node == parent && next != child.dom)
                    track.written = true;
                if (child.dom.parentNode == parent) {
                    while (next && next != child.dom)
                        next = rm$1(next);
                }
                else {
                    parent.insertBefore(child.dom, next);
                }
                prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
                track.written = true;
            while (next)
                next = rm$1(next);
        }
        else if (this.flags & 1) {
            for (let child of this.children)
                if (child.flags & 7) {
                    child.sync(view, track);
                    child.flags &= ~7;
                }
        }
    }
    reuseDOM(_dom) { }
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        }
        else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (;;) {
                let parent = node.parentNode;
                if (parent == this.dom)
                    break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild)
                        bias = -1;
                    else
                        bias = 1;
                }
                node = parent;
            }
            if (bias < 0)
                after = node;
            else
                after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
            return 0;
        while (after && !ContentView.get(after))
            after = after.nextSibling;
        if (!after)
            return this.length;
        for (let i = 0, pos = 0;; i++) {
            let child = this.children[i];
            if (child.dom == after)
                return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
                return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i;
                fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
                toI = i;
                toEnd = prevEnd;
                break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
        }
        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };
    }
    markDirty(andParent = false) {
        this.flags |= 2;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
                parent.flags |= 2;
            if (parent.flags & 1)
                return;
            parent.flags |= 1;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.flags & 7)
                this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        if (this.dom == dom)
            return;
        if (this.dom)
            this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for (let v = this;;) {
            let parent = v.parent;
            if (!parent)
                return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = noChildren) {
        this.markDirty();
        for (let i = from; i < to; i++) {
            let child = this.children[i];
            if (child.parent == this && children.indexOf(child) < 0)
                child.destroy();
        }
        if (children.length < 250)
            this.children.splice(from, to - from, ...children);
        else
            this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
        for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
    }
    ignoreMutation(_rec) { return false; }
    ignoreEvent(_event) { return false; }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" :
            this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
            (this.breakAfter ? "#" : "");
    }
    static get(node) { return node.cmView; }
    get isEditable() { return true; }
    get isWidget() { return false; }
    get isHidden() { return false; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
    }
    become(other) { return false; }
    canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
    }
    getSide() { return 0; }
    destroy() {
        for (let child of this.children)
            if (child.parent == this)
                child.destroy();
        this.parent = null;
    }
}
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
class ChildCursor {
    constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
    }
    findPos(pos, bias = 1) {
        for (;;) {
            if (pos > this.pos || pos == this.pos &&
                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert.length ? insert[insert.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&
        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
    if (toI < children.length) {
        let after = children[toI];
        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                insert[insert.length - 1] = after;
            }
            else {
                if (toOff || after.children.length && !after.children[0].length)
                    after.merge(0, toOff, null, false, 0, openEnd);
                insert.push(after);
            }
        }
        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            if (last)
                last.breakAfter = 1;
            else
                breakAtStart = 1;
        }
        toI++;
    }
    if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                before.breakAfter = insert.shift().breakAfter;
            }
            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
    }
    while (fromI < toI && insert.length) {
        if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
        }
        else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
        }
        else {
            break;
        }
    }
    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&
        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
        fromI--;
    if (fromI < toI || insert.length)
        parent.replaceChildren(fromI, toI, insert);
}
function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert)
        dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
}
let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /MSIE \d/.test(nav.userAgent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
    mac: ios || /Mac/.test(nav.platform),
    windows: /Win/.test(nav.platform),
    linux: /Linux|X11/.test(nav.platform),
    ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const MaxJoinLen = 256;
class TextView extends ContentView {
    constructor(text) {
        super();
        this.text = text;
    }
    get length() { return this.text.length; }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
        if (!this.dom)
            this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
                track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType == 3)
            this.createDOM(dom);
    }
    merge(from, to, source) {
        if ((this.flags & 8) ||
            source && (!(source instanceof TextView) ||
                this.length - (to - from) + source.length > MaxJoinLen ||
                (source.flags & 8)))
            return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        result.flags |= this.flags & 8;
        return result;
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) { return new DOMPos(this.dom, pos); }
    domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
            ch.setParent(this);
    }
    setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
            dom.className = this.mark.class;
        if (this.mark.attrs)
            for (let name in this.mark.attrs)
                dom.setAttribute(name, this.mark.attrs[name]);
        return dom;
    }
    canReuseDOM(other) {
        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
    }
    reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.flags |= 4 | 2;
        }
    }
    sync(view, track) {
        if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.flags & 4)
            this.setAttrs(this.dom);
        super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
            return false;
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = [], off = 0, detachFrom = -1, i = 0;
        for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
                result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
                detachFrom = i;
            off = end;
            i++;
        }
        let length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
        }
        return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
        pos = length;
    let from = pos, to = pos, flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) {
            if (pos) {
                from--;
                flatten = 1;
            }
            else if (to < length) {
                to++;
                flatten = -1;
            }
        }
    }
    else {
        if (side < 0)
            from--;
        else if (to < length)
            to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
        return null;
    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, r => r.width) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect || null;
}
class WidgetView extends ContentView {
    static create(widget, length, side) {
        return new WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
    }
    split(from) {
        let result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
    }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    getSide() { return this.side; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other instanceof WidgetView && other.side == this.side &&
            this.widget.constructor == other.widget.constructor) {
            if (!this.widget.compare(other.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get overrideDOMText() {
        if (this.length == 0)
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;
        let top = this;
        while (top.parent)
            top = top.parent;
        let { view } = top, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;
    }
    domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0)
            ? DOMPos.before(this.dom)
            : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() { return null; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
            return null;
        let fromBack = this.side ? this.side < 0 : pos > 0;
        for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                break;
        }
        return flattenRect(rect, !fromBack);
    }
    get isEditable() { return false; }
    get isWidget() { return true; }
    get isHidden() { return this.widget.isHidden; }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
}
class WidgetBufferView extends ContentView {
    constructor(side) {
        super();
        this.side = side;
    }
    get length() { return 0; }
    merge() { return false; }
    become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() { return new WidgetBufferView(this.side); }
    sync() {
        if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
        }
    }
    getSide() { return this.side; }
    domAtPos(pos) { return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }
    localPosFromDOM() { return 0; }
    domBoundsAround() { return null; }
    coordsAt(pos) {
        return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;
    }
    get isHidden() { return true; }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
        let child = children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
        if (pos <= off)
            break;
        off = end;
    }
    for (let j = i; j > 0; j--) {
        let prev = children[j - 1];
        if (prev.dom.parentNode == dom)
            return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
        let next = children[j];
        if (next.dom.parentNode == dom)
            return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length &&
        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    }
    else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view, pos) {
        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
            let child = view.children[i], end = off + child.length;
            if (end >= pos) {
                if (child.children.length) {
                    scan(child, pos - off);
                }
                else if ((!after || after.isHidden && (side > 0 || onSameLine(after, child))) &&
                    (end > pos || off == end && child.getSide() > 0)) {
                    after = child;
                    afterPos = pos - off;
                }
                else if (off < pos || (off == end && child.getSide() < 0) && !child.isHidden) {
                    before = child;
                    beforePos = pos - off;
                }
            }
            off = end;
        }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
}
function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
        return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
}
function onSameLine(a, b) {
    let posA = a.coordsAt(0, 1), posB = b.coordsAt(0, 1);
    return posA && posB && posB.top < posA.bottom;
}
function combineAttrs(source, target) {
    for (let name in source) {
        if (name == "class" && target.class)
            target.class += " " + source.class;
        else if (name == "style" && target.style)
            target.style += ";" + source.style;
        else
            target[name] = source[name];
    }
    return target;
}
const noAttrs = Object.create(null);
function attrsEq(a, b, ignore) {
    if (a == b)
        return true;
    if (!a)
        a = noAttrs;
    if (!b)
        b = noAttrs;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
        keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
        return false;
    for (let key of keysA) {
        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
            return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev)
        for (let name in prev)
            if (!(attrs && name in attrs)) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = "";
                else
                    dom.removeAttribute(name);
            }
    if (attrs)
        for (let name in attrs)
            if (!(prev && prev[name] == attrs[name])) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = attrs[name];
                else
                    dom.setAttribute(name, attrs[name]);
            }
    return changed;
}
function getAttrs(dom) {
    let attrs = Object.create(null);
    for (let i = 0; i < dom.attributes.length; i++) {
        let attr = dom.attributes[i];
        attrs[attr.name] = attr.value;
    }
    return attrs;
}
class WidgetType {
    eq(widget) { return false; }
    updateDOM(dom, view) { return false; }
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() { return -1; }
    get lineBreaks() { return 0; }
    ignoreEvent(event) { return true; }
    coordsAt(dom, pos, side) { return null; }
    get isHidden() { return false; }
    get editable() { return false; }
    destroy(dom) { }
}
var BlockType = (function (BlockType) {
    BlockType[BlockType["Text"] = 0] = "Text";
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
    return BlockType;
})(BlockType || (BlockType = {}));
class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeValue {
    constructor(startSide, endSide, widget, spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    get heightRelevant() { return false; }
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    static widget(spec) {
        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;
        side += (block && !spec.inlineOrder)
            ? (side > 0 ? 300000000 : -400000000)
            : (side > 0 ? 100000000 : -100000000);
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
            startSide = -500000000;
            endSide = 400000000;
        }
        else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? (block ? -300000000 : -1) : 500000000) - 1;
            endSide = (end ? (block ? 200000000 : 1) : -600000000) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
        return new LineDecoration(spec);
    }
    static set(of, sort = false) {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.of(of, sort);
    }
    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
}
Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;
class MarkDecoration extends Decoration {
    constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 : 500000000, end ? 1 : -600000000, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        var _a, _b;
        return this == other ||
            other instanceof MarkDecoration &&
                this.tagName == other.tagName &&
                (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&
                attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
        if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec) {
        super(-200000000, -200000000, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration &&
            this.spec.class == other.spec.class &&
            attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackAfter;
    }
    get type() {
        return this.startSide != this.endSide ? BlockType.WidgetRange
            : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
        return other instanceof PointDecoration &&
            widgetsEq(this.widget, other.widget) &&
            this.block == other.block &&
            this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
        start = spec.inclusive;
    if (end == null)
        end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
        ranges[last] = Math.max(ranges[last], to);
    else
        ranges.push(from, to);
}
class LineView extends ContentView {
    constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = undefined;
        this.attrs = null;
        this.breakAfter = 0;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView))
                return false;
            if (!this.dom)
                source.transferDOM(this);
        }
        if (hasStart)
            this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
            return end;
        let { i, off } = this.childPos(at);
        if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
        }
        for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom)
            return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
        if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.flags |= 4 | 2;
        }
    }
    sync(view, track) {
        var _a;
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        else if (this.flags & 4) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(view, track);
        let last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
        if (!last || !this.length ||
            last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&
                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let totalWidth = 0, textHeight;
        for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
                return null;
            totalWidth += rects[0].width;
            textHeight = rects[0].height;
        }
        return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length,
            textHeight
        };
    }
    coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side);
        if (!this.children.length && rect && this.parent) {
            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
                let dist = (height - heightOracle.textHeight) / 2;
                return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };
            }
        }
        return rect;
    }
    become(other) {
        return other instanceof LineView && this.children.length == 0 && other.children.length == 0 &&
            attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
    }
    covers() { return true; }
    static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView)
                    return block;
                if (end > pos)
                    break;
            }
            off = end + block.breakAfter;
        }
        return null;
    }
}
class BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
        super();
        this.widget = widget;
        this.length = length;
        this.deco = deco;
        this.breakAfter = 0;
        this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
    }
    get children() { return noChildren; }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;
    }
    domBoundsAround() { return null; }
    become(other) {
        if (other instanceof BlockWidgetView &&
            other.widget.constructor == this.widget.constructor) {
            if (!other.widget.compare(this.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.deco = other.deco;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get isEditable() { return false; }
    get isWidget() { return true; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        if (this.widget instanceof BlockGapWidget)
            return null;
        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
    covers(side) {
        let { startSide, endSide } = this.deco;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
}
class BlockGapWidget extends WidgetType {
    constructor(height) {
        super();
        this.height = height;
    }
    toDOM() {
        let elt = document.createElement("div");
        elt.className = "cm-gap";
        this.updateDOM(elt);
        return elt;
    }
    eq(other) { return other.height == this.height; }
    updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
    }
    get editable() { return true; }
    get estimatedHeight() { return this.height; }
    ignoreEvent() { return false; }
}
class ContentBuilder {
    constructor(doc, pos, end, disallowBlockEffectsFor) {
        this.doc = doc;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0;
        this.bufferMarks = [];
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
        if (!this.curLine) {
            this.content.push(this.curLine = new LineView);
            this.atCursorPos = true;
        }
        return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0;
        }
    }
    addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
    }
    finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
            this.flushBuffer();
        else
            this.pendingBuffer = 0;
        if (!this.posCovered() &&
            !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
            this.getLine();
    }
    buildText(length, active, openStart) {
        while (length > 0) {
            if (this.textOff == this.text.length) {
                let { value, lineBreak, done } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done)
                    throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered())
                        this.getLine();
                    if (this.content.length)
                        this.content[this.content.length - 1].breakAfter = 1;
                    else
                        this.breakAtStart = 1;
                    this.flushBuffer();
                    this.curLine = null;
                    this.atCursorPos = true;
                    length--;
                    continue;
                }
                else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512);
            this.flushBuffer(active.slice(active.length - openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
                throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                if (deco.startSide > 0 && !this.posCovered())
                    this.getLine();
                this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
            }
            else {
                let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length &&
                    (from < to || deco.startSide > 0);
                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
                let line = this.getLine();
                if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
                    this.pendingBuffer = 0;
                this.flushBuffer(active);
                if (cursorBefore) {
                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                    openStart = active.length + Math.max(0, openStart - active.length);
                }
                line.append(wrapMarks(view, active), openStart);
                this.atCursorPos = cursorAfter;
                this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
                if (this.pendingBuffer)
                    this.bufferMarks = active.slice();
            }
        }
        else if (this.doc.lineAt(this.pos).from == this.pos) {
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            }
            else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    static build(text, from, to, decorations, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(decorations, from, to, builder);
        if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
    }
}
function wrapMarks(view, active) {
    for (let mark of active)
        view = new MarkView(mark, [view], view.length);
    return view;
}
class NullWidget extends WidgetType {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    eq(other) { return other.tag == this.tag; }
    toDOM() { return document.createElement(this.tag); }
    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
    get isHidden() { return true; }
}
NullWidget.inline = new NullWidget("span");
NullWidget.block = new NullWidget("div");
var Direction = (function (Direction) {
    Direction[Direction["LTR"] = 0] = "LTR";
    Direction[Direction["RTL"] = 1] = "RTL";
    return Direction;
})(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
        result.push(1 << +str[i]);
    return result;
}
const LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = Object.create(null), BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
    let l = p.charCodeAt(0), r = p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] :
        0x590 <= ch && ch <= 0x5f4 ? 2 :
            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                0x6ee <= ch && ch <= 0x8ac ? 4 :
                    0x2000 <= ch && ch <= 0x200c ? 256 :
                        0xfb50 <= ch && ch <= 0xfdff ? 4 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
    get dir() { return this.level % 2 ? RTL : LTR; }
    constructor(from, to, level) {
        this.from = from;
        this.to = to;
        this.level = level;
    }
    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
    forward(forward, dir) { return forward == (this.dir == dir); }
    static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
                if (span.level == level)
                    return i;
                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                    maybe = i;
            }
        }
        if (maybe < 0)
            throw new RangeError("Index out of range");
        return maybe;
    }
}
function isolatesEq(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        let iA = a[i], iB = b[i];
        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
            return false;
    }
    return true;
}
const types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        let prevType = iI ? 256 : outerType;
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = charType(line.charCodeAt(i));
            if (type == 512)
                type = prev;
            else if (type == 8 && prevStrong == 4)
                type = 16;
            types[i] = type == 4 ? 2 : type;
            if (type & 7)
                prevStrong = type;
            prev = type;
        }
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = types[i];
            if (type == 128) {
                if (i < to - 1 && prev == types[i + 1] && (prev & 24))
                    type = types[i] = prev;
                else
                    types[i] = 256;
            }
            else if (type == 64) {
                let end = i + 1;
                while (end < to && types[end] == 64)
                    end++;
                let replace = (i && prev == 8) || (end < rTo && types[end] == 8) ? (prevStrong == 1 ? 1 : 8) : 256;
                for (let j = i; j < end; j++)
                    types[j] = replace;
                i = end - 1;
            }
            else if (type == 8 && prevStrong == 1) {
                types[i] = 1;
            }
            prev = type;
            if (type & 7)
                prevStrong = type;
        }
    }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 ? 2 : 1;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        for (let i = from, ch, br, type; i < to; i++) {
            if (br = Brackets[ch = line.charCodeAt(i)]) {
                if (br < 0) {
                    for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                        if (BracketStack[sJ + 1] == -br) {
                            let flags = BracketStack[sJ + 2];
                            let type = (flags & 2) ? outerType :
                                !(flags & 4) ? 0 :
                                    (flags & 1) ? oppositeType : outerType;
                            if (type)
                                types[i] = types[BracketStack[sJ]] = type;
                            sI = sJ;
                            break;
                        }
                    }
                }
                else if (BracketStack.length == 189) {
                    break;
                }
                else {
                    BracketStack[sI++] = i;
                    BracketStack[sI++] = ch;
                    BracketStack[sI++] = context;
                }
            }
            else if ((type = types[i]) == 2 || type == 1) {
                let embed = type == outerType;
                context = embed ? 0 : 1;
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    let cur = BracketStack[sJ + 2];
                    if (cur & 2)
                        break;
                    if (embed) {
                        BracketStack[sJ + 2] |= 2;
                    }
                    else {
                        if (cur & 4)
                            break;
                        BracketStack[sJ + 2] |= 4;
                    }
                }
            }
        }
    }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        for (let i = from; i < to;) {
            let type = types[i];
            if (type == 256) {
                let end = i + 1;
                for (;;) {
                    if (end == to) {
                        if (iI == isolates.length)
                            break;
                        end = isolates[iI++].to;
                        to = iI < isolates.length ? isolates[iI].from : rTo;
                    }
                    else if (types[end] == 256) {
                        end++;
                    }
                    else {
                        break;
                    }
                }
                let beforeL = prev == 1;
                let afterL = (end < rTo ? types[end] : outerType) == 1;
                let replace = beforeL == afterL ? (beforeL ? 1 : 2) : outerType;
                for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
                    if (j == fromJ) {
                        j = isolates[--jI].from;
                        fromJ = jI ? isolates[jI - 1].to : rFrom;
                    }
                    types[--j] = replace;
                }
                i = end;
            }
            else {
                prev = type;
                i++;
            }
        }
    }
}
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 : 1;
    if ((level % 2) == (baseLevel % 2)) {
        for (let iCh = from, iI = 0; iCh < to;) {
            let sameDir = true, isNum = false;
            if (iI == isolates.length || iCh < isolates[iI].from) {
                let next = types[iCh];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16;
                }
            }
            let recurse = !sameDir && ourType == 1 ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI < isolates.length && iScan == isolates[iI].from) {
                    if (isNum)
                        break run;
                    let iso = isolates[iI];
                    if (!sameDir)
                        for (let upto = iso.to, jI = iI + 1;;) {
                            if (upto == to)
                                break run;
                            if (jI < isolates.length && isolates[jI].from == upto)
                                upto = isolates[jI++].to;
                            else if (types[upto] == ourType)
                                break run;
                            else
                                break;
                        }
                    iI++;
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.from > iCh)
                            order.push(new BidiSpan(iCh, iso.from, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.to;
                    }
                    iScan = iso.to;
                }
                else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
                    break;
                }
                else {
                    iScan++;
                }
            }
            if (recurse)
                emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
            else if (iCh < iScan)
                order.push(new BidiSpan(iCh, iScan, localLevel));
            iCh = iScan;
        }
    }
    else {
        for (let iCh = to, iI = isolates.length; iCh > from;) {
            let sameDir = true, isNum = false;
            if (!iI || iCh > isolates[iI - 1].to) {
                let next = types[iCh - 1];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16;
                }
            }
            let recurse = !sameDir && ourType == 1 ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI && iScan == isolates[iI - 1].to) {
                    if (isNum)
                        break run;
                    let iso = isolates[--iI];
                    if (!sameDir)
                        for (let upto = iso.from, jI = iI;;) {
                            if (upto == from)
                                break run;
                            if (jI && isolates[jI - 1].to == upto)
                                upto = isolates[--jI].from;
                            else if (types[upto - 1] == ourType)
                                break run;
                            else
                                break;
                        }
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.to < iCh)
                            order.push(new BidiSpan(iso.to, iCh, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.from;
                    }
                    iScan = iso.from;
                }
                else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
                    break;
                }
                else {
                    iScan--;
                }
            }
            if (recurse)
                emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
            else if (iScan < iCh)
                order.push(new BidiSpan(iScan, iCh, localLevel));
            iCh = iScan;
        }
    }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = (level % 2 ? 2 : 1);
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
    if (!line)
        return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
        return trivialOrder(line.length);
    if (isolates.length)
        while (line.length > types.length)
            types[types.length] = 256;
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
}
function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
    var _a;
    let startIndex = start.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    let span = order[spanI], spanEnd = span.side(forward, dir);
    if (startIndex == spanEnd) {
        let nextI = spanI += forward ? 1 : -1;
        if (nextI < 0 || nextI >= order.length)
            return null;
        span = order[spanI = nextI];
        startIndex = span.side(!forward, dir);
        spanEnd = span.side(forward, dir);
    }
    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));
    if (nextIndex < span.from || nextIndex > span.to)
        nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
    for (let i = from; i < to; i++) {
        let type = charType(text.charCodeAt(i));
        if (type == 1)
            return LTR;
        if (type == 2 || type == 4)
            return RTL;
    }
    return LTR;
}
const clickAddsSelectionRange = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const dragMovesSelection$1 = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const mouseSelectionStyle = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const exceptionSink = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const updateListener = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const inputHandler = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const focusChangeEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const clipboardInputFilter = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const clipboardOutputFilter = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const perLineTextDirection = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine: values => values.some(x => x)
});
const nativeSelectionHidden = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine: values => values.some(x => x)
});
const scrollHandler = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
class ScrollTarget {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
        this.isSnapshot = isSnapshot;
    }
    map(changes) {
        return changes.empty ? this :
            new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
        return this.range.to <= state.doc.length ? this :
            new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
}
const scrollIntoView = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({ map: (t, ch) => t.map(ch) });
const setEditContextFormatting = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();
function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
        handler[0](exception);
    else if (window.onerror && window.onerror(String(exception), context, undefined, undefined, exception))
        ;
    else if (context)
        console.error(context + ":", exception);
    else
        console.error(exception);
}
const editable = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({ combine: values => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(plugins) {
        return plugins.filter((p, i) => {
            for (let j = 0; j < i; j++)
                if (plugins[j].plugin == p.plugin)
                    return false;
            return true;
        });
    }
});
class ViewPlugin {
    constructor(id, create, domEventHandlers, domEventObservers, buildExtensions) {
        this.id = id;
        this.create = create;
        this.domEventHandlers = domEventHandlers;
        this.domEventObservers = domEventObservers;
        this.baseExtensions = buildExtensions(this);
        this.extension = this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg: undefined }));
    }
    of(arg) {
        return this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg }));
    }
    static define(create, spec) {
        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin => {
            let ext = [];
            if (deco)
                ext.push(decorations.of(view => {
                    let pluginInst = view.plugin(plugin);
                    return pluginInst ? deco(pluginInst) : Decoration.none;
                }));
            if (provide)
                ext.push(provide(plugin));
            return ext;
        });
    }
    static fromClass(cls, spec) {
        return ViewPlugin.define((view, arg) => new cls(view, arg), spec);
    }
}
class PluginInstance {
    constructor(spec) {
        this.spec = spec;
        this.mustUpdate = null;
        this.value = null;
    }
    get plugin() { return this.spec && this.spec.plugin; }
    update(view) {
        if (!this.value) {
            if (this.spec) {
                try {
                    this.value = this.spec.plugin.create(view, this.spec.arg);
                }
                catch (e) {
                    logException(view.state, e, "CodeMirror plugin crashed");
                    this.deactivate();
                }
            }
        }
        else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
                try {
                    this.value.update(update);
                }
                catch (e) {
                    logException(update.state, e, "CodeMirror plugin crashed");
                    if (this.value.destroy)
                        try {
                            this.value.destroy();
                        }
                        catch (_) { }
                    this.deactivate();
                }
            }
        }
        return this;
    }
    destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
                this.value.destroy();
            }
            catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
    deactivate() {
        this.spec = this.value = null;
    }
}
const editorAttributes = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const contentAttributes = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const decorations = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const outerDecorations = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const atomicRanges = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const bidiIsolatedRanges = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
function getIsolatedRanges(view, line) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
        return isolates;
    let sets = isolates.map(i => i instanceof Function ? i(view) : i);
    let result = [];
    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(sets, line.from, line.to, {
        point() { },
        span(fromDoc, toDoc, active, open) {
            let from = fromDoc - line.from, to = toDoc - line.from;
            let level = result;
            for (let i = active.length - 1; i >= 0; i--, open--) {
                let direction = active[i].spec.bidiIsolate, update;
                if (direction == null)
                    direction = autoDirection(line.text, from, to);
                if (open > 0 && level.length &&
                    (update = level[level.length - 1]).to == from && update.direction == direction) {
                    update.to = to;
                    level = update.inner;
                }
                else {
                    let add = { from, to, direction, inner: [] };
                    level.push(add);
                    level = add.inner;
                }
            }
        }
    });
    return result;
}
const scrollMargins = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
function getScrollMargins(view) {
    let left = 0, right = 0, top = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
        let m = source(view);
        if (m) {
            if (m.left != null)
                left = Math.max(left, m.left);
            if (m.right != null)
                right = Math.max(right, m.right);
            if (m.top != null)
                top = Math.max(top, m.top);
            if (m.bottom != null)
                bottom = Math.max(bottom, m.bottom);
        }
    }
    return { left, right, top, bottom };
}
const styleModule = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
            return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB)
                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end)
                    break;
                else
                    rI += 2;
            }
            if (!next)
                return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
class ViewUpdate {
    constructor(view, state, transactions) {
        this.view = view;
        this.state = state;
        this.transactions = transactions;
        this.flags = 0;
        this.startState = view.state;
        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
    }
    static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
    }
    get viewportChanged() {
        return (this.flags & 4) > 0;
    }
    get viewportMoved() {
        return (this.flags & 8) > 0;
    }
    get heightChanged() {
        return (this.flags & 2) > 0;
    }
    get geometryChanged() {
        return this.docChanged || (this.flags & (16 | 2)) > 0;
    }
    get focusChanged() {
        return (this.flags & 1) > 0;
    }
    get docChanged() {
        return !this.changes.empty;
    }
    get selectionSet() {
        return this.transactions.some(tr => tr.selection);
    }
    get empty() { return this.flags == 0 && this.transactions.length == 0; }
}
class DocView extends ContentView {
    get length() { return this.view.state.doc.length; }
    constructor(view) {
        super();
        this.view = view;
        this.decorations = [];
        this.dynamicDecorationMap = [false];
        this.domChanged = null;
        this.hasComposition = null;
        this.markedForComposition = new Set;
        this.editContextFormatting = Decoration.none;
        this.lastCompositionAfterCursor = false;
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    update(update) {
        var _a;
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            }
            else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        this.updateEditContextFormatting(update);
        let readCompositionAt = -1;
        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)
                readCompositionAt = this.domChanged.newSel.head;
            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
                readCompositionAt = update.state.selection.main.head;
        }
        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
            this.markedForComposition.clear();
            let { from, to } = this.hasComposition;
            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))
                .addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
        if ((browser.ie || browser.chrome) && !composition && update &&
            update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7) && changedRanges.length == 0) {
            return false;
        }
        else {
            this.updateInner(changedRanges, update.startState.doc.length, composition);
            if (update.transactions.length)
                this.lastUpdate = Date.now();
            return true;
        }
    }
    updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        let { observer } = this.view;
        observer.ignore(() => {
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;
            this.sync(this.view, track);
            this.flags &= ~7;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
                this.forceSelection = true;
            this.dom.style.height = "";
        });
        this.markedForComposition.forEach(cView => cView.flags &= ~8);
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let child of this.children)
                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                    gaps.push(child.dom);
        observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        let cursor = this.childCursor(oldLength);
        for (let i = ranges.length - 1;; i--) {
            let next = i >= 0 ? ranges[i] : null;
            if (!next)
                break;
            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
                breakAtStart = before.breakAtStart;
                openStart = before.openStart;
                openEnd = after.openEnd;
                let compLine = this.compositionView(composition);
                if (after.breakAtStart) {
                    compLine.breakAfter = 1;
                }
                else if (after.content.length &&
                    compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
                    compLine.breakAfter = after.content[0].breakAfter;
                    after.content.shift();
                }
                if (before.content.length &&
                    compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
                    before.content.pop();
                }
                content = before.content.concat(compLine).concat(after.content);
            }
            else {
                ({ content, breakAtStart, openStart, openEnd } =
                    ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
            }
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
        if (composition)
            this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update) {
        this.editContextFormatting = this.editContextFormatting.map(update.changes);
        for (let tr of update.transactions)
            for (let effect of tr.effects)
                if (effect.is(setEditContextFormatting)) {
                    this.editContextFormatting = effect.value;
                }
    }
    compositionView(composition) {
        let cur = new TextView(composition.text.nodeValue);
        cur.flags |= 8;
        for (let { deco } of composition.marks)
            cur = new MarkView(deco, [cur], cur.length);
        let line = new LineView;
        line.append(cur, 0);
        return line;
    }
    fixCompositionDOM(composition) {
        let fix = (dom, cView) => {
            cView.flags |= 8 | (cView.children.some(c => c.flags & 7) ? 1 : 0);
            this.markedForComposition.add(cView);
            let prev = ContentView.get(dom);
            if (prev && prev != cView)
                prev.dom = null;
            cView.setDOM(dom);
        };
        let pos = this.childPos(composition.range.fromB, 1);
        let cView = this.children[pos.i];
        fix(composition.line, cView);
        for (let i = composition.marks.length - 1; i >= -1; i--) {
            pos = cView.childPos(pos.off, 1);
            cView = cView.children[pos.i];
            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
        }
    }
    updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) &&
            hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus))
            return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.moveToLine(this.domAtPos(main.anchor));
        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = this.view.observer.selectionRange;
        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
            this.view.observer.ignore(() => {
                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&
                    inUneditable(domSel.focusNode, this.dom)) {
                    this.dom.blur();
                    this.dom.focus({ preventScroll: true });
                }
                let rawSel = getSelection(this.view.root);
                if (!rawSel)
                    ;
                else if (main.empty) {
                    if (browser.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (1 | 2)) {
                            let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                            if (text)
                                anchor = new DOMPos(text.node, text.offset);
                        }
                    }
                    rawSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined)
                        rawSel.caretBidiLevel = main.bidiLevel;
                }
                else if (rawSel.extend) {
                    rawSel.collapse(anchor.node, anchor.offset);
                    try {
                        rawSel.extend(head.node, head.offset);
                    }
                    catch (_) { }
                }
                else {
                    let range = document.createRange();
                    if (main.anchor > main.head)
                        [anchor, head] = [head, anchor];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    rawSel.removeAllRanges();
                    rawSel.addRange(range);
                }
                if (selectionNotFocus && this.view.root.activeElement == this.dom) {
                    this.dom.blur();
                    if (activeElt)
                        activeElt.focus();
                }
            });
            this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    suppressWidgetCursorChange(sel, cursor) {
        return this.hasComposition && cursor.empty &&
            isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) &&
            this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
    }
    enforceCursorAssoc() {
        if (this.hasComposition)
            return;
        let { view } = this, cursor = view.state.selection.main;
        let sel = getSelection(view.root);
        let { anchorNode, anchorOffset } = view.observer.selectionRange;
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
        let line = LineView.find(this, cursor.head);
        if (!line)
            return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top)
            return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
        view.observer.readSelectionRange();
        let newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
            sel.collapse(anchorNode, anchorOffset);
    }
    moveToLine(pos) {
        let dom = this.dom, newPos;
        if (pos.node != dom)
            return pos;
        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(0);
        }
        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(view.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
        for (let cur = dom; cur;) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
                return domView;
            cur = cur.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1;) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
                break;
            i++;
            off = 0;
        }
        return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
        let best = null, bestPos = 0;
        for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
            if (end < pos)
                break;
            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) &&
                (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
                best = child;
                bestPos = start;
            }
            else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
                if (child.deco.startSide < 0)
                    break;
                else if (i)
                    best = null;
            }
            off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
        let { i, off } = this.childPos(pos, 1), child = this.children[i];
        if (!(child instanceof LineView))
            return null;
        while (child.children.length) {
            let { i, off: childOff } = child.childPos(off, 1);
            for (;; i++) {
                if (i == child.children.length)
                    return null;
                if ((child = child.children[i]).length)
                    break;
            }
            off = childOff;
        }
        if (!(child instanceof TextView))
            return null;
        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(child.text, off);
        if (end == off)
            return null;
        let rects = textRange(child.dom, off, end).getClientRects();
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
                return rect;
        }
        return null;
    }
    measureVisibleLineHeights(viewport) {
        let result = [], { from, to } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == Direction.LTR;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
                break;
            if (pos >= from) {
                let childRect = child.dom.getBoundingClientRect();
                result.push(childRect.height);
                if (isWider) {
                    let last = child.dom.lastChild;
                    let rects = last ? clientRectsFor(last) : [];
                    if (rects.length) {
                        let rect = rects[rects.length - 1];
                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                        if (width > widest) {
                            widest = width;
                            this.minWidth = contentWidth;
                            this.minWidthFrom = pos;
                            this.minWidthTo = end;
                        }
                    }
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
        for (let child of this.children) {
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure)
                    return measure;
            }
        }
        let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            textHeight = rect ? rect.height : lineHeight;
            dummy.remove();
        });
        return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
        let i = this.children.length;
        if (i)
            pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0;; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
                deco.push(Decoration.replace({
                    widget: new BlockGapWidget(height),
                    block: true,
                    inclusive: true,
                    isBlockGap: true,
                }).range(pos, end));
            }
            if (!next)
                break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        let i = 1;
        let allDeco = this.view.state.facet(decorations).map(d => {
            let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
            return dynamic ? d(this.view) : d;
        });
        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i) => {
            let dynamic = typeof d == "function";
            if (dynamic)
                dynamicOuter = true;
            return dynamic ? d(this.view) : d;
        });
        if (outerDeco.length) {
            this.dynamicDecorationMap[i++] = dynamicOuter;
            allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.join(outerDeco));
        }
        this.decorations = [
            this.editContextFormatting,
            ...allDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
        ];
        while (i < this.decorations.length)
            this.dynamicDecorationMap[i++] = false;
        return this.decorations;
    }
    scrollIntoView(target) {
        if (target.isSnapshot) {
            let ref = this.view.viewState.lineBlockAt(target.range.head);
            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
            this.view.scrollDOM.scrollLeft = target.xMargin;
            return;
        }
        for (let handler of this.view.state.facet(scrollHandler)) {
            try {
                if (handler(this.view, target.range, target))
                    return true;
            }
            catch (e) {
                logException(this.view.state, e, "scroll handler");
            }
        }
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
            return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),
                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };
        let margins = getScrollMargins(this.view);
        let targetRect = {
            left: rect.left - margins.left, top: rect.top - margins.top,
            right: rect.right + margins.right, bottom: rect.bottom + margins.bottom
        };
        let { offsetWidth, offsetHeight } = this.view.scrollDOM;
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild &&
        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    if (!sel.focusNode)
        return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
        let descAfter = ContentView.get(textAfter.node);
        if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
            textNode = textAfter;
        }
        else if (view.docView.lastCompositionAfterCursor) {
            let descBefore = ContentView.get(textBefore.node);
            if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
                textNode = textAfter;
        }
    }
    view.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode)
        return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
        return null;
    let { node: textNode, from, to } = found, text = textNode.nodeValue;
    if (/[\n\r]/.test(text))
        return null;
    if (view.state.doc.sliceString(found.from, found.to) != text)
        return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks = [];
    for (let parent = textNode.parentNode;; parent = parent.parentNode) {
        let parentView = ContentView.get(parent);
        if (parentView instanceof MarkView)
            marks.push({ node: parent, deco: parentView.mark });
        else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
            return { range, text: textNode, marks, line: parent };
        else if (parent != view.contentDOM)
            marks.push({ node: parent, deco: new MarkDecoration({
                    inclusive: true,
                    attributes: getAttrs(parent),
                    tagName: parent.tagName.toLowerCase()
                }) });
        else
            return null;
    }
}
function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
        return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) |
        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
let DecorationComparator$1 = class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange(from, to) { addRange(from, to, this.changes); }
    comparePoint(from, to) { addRange(from, to, this.changes); }
    boundChange(pos) { addRange(pos, pos, this.changes); }
};
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1;
    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.compare(a, b, diff, comp);
    return comp.changes;
}
function inUneditable(node, inside) {
    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
        if (cur.nodeType == 1 && cur.contentEditable == 'false') {
            return true;
        }
    }
    return false;
}
function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
        changes.iterChangedRanges((from, to) => {
            if (from < composition.to && to > composition.from)
                touched = true;
        });
    return touched;
}
function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos);
    if (linePos == 0)
        bias = 1;
    else if (linePos == line.length)
        bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
        from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos, false);
    else
        to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat)
            break;
        to = next;
    }
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
                closestOverlap = !dx ? true : x < rect.left ? i > 0 : i < rects.length - 1;
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                }
                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            }
            else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            }
            else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    }
    else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest)
        return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
        return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
                continue;
            if (!generalSide)
                generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (browser.chrome || browser.gecko) {
                    let rectBefore = textRange(node, i).getBoundingClientRect();
                    if (rectBefore.left == rect.right)
                        after = !right;
                }
                if (dy <= 0)
                    return { node, offset: i + (after ? 1 : 0) };
                closestOffset = i + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
    var _a, _b;
    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x, y } = coords, yOffset = y - docTop;
    if (yOffset < 0)
        return 0;
    if (yOffset > docHeight)
        return view.state.doc.length;
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
        block = view.elementAtHeight(yOffset);
        if (block.type == BlockType.Text)
            break;
        for (;;) {
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
                break;
            if (bounced)
                return precise ? null : 0;
            bounced = true;
            bias = -bias;
        }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length :
            precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    let doc = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
        element = null;
    if (!element) {
        x = Math.max(content.left + 1, Math.min(content.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
            element = null;
    }
    let node, offset = -1;
    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
        if (doc.caretPositionFromPoint) {
            let pos = doc.caretPositionFromPoint(x, y);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        else if (doc.caretRangeFromPoint) {
            let range = doc.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node, startOffset: offset } = range);
                if (!view.contentDOM.contains(node) ||
                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||
                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                    node = undefined;
            }
        }
        if (node)
            offset = Math.min(maxOffset(node), offset);
    }
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
        return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
        let rect = nearest.dom.getBoundingClientRect();
        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2
            ? nearest.posAtStart : nearest.posAtEnd;
    }
    else {
        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let textHeight = view.viewState.heightOracle.textHeight;
        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
        into += line * view.viewState.heightOracle.lineLength;
    }
    let content = view.state.sliceDoc(block.from, block.to);
    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(content, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node, offset, x) {
    let len, scan = node;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
    for (;;) {
        let next = scan.nextSibling;
        if (next) {
            if (next.nodeName == "BR")
                break;
            return false;
        }
        else {
            let parent = scan.parentNode;
            if (!parent || parent.nodeName == "DIV")
                break;
            scan = parent;
        }
    }
    return textRange(node, len - 1, len).getBoundingClientRect().right > x;
}
function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
        return false;
    for (let cur = node;;) {
        let parent = cur.parentNode;
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
        if (parent.classList.contains("cm-line"))
            break;
        cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect()
        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
}
function blockAt(view, pos, side) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type)) {
        let best;
        for (let l of line.type) {
            if (l.from > pos)
                break;
            if (l.to < pos)
                continue;
            if (l.from < pos && l.to > pos)
                return l;
            if (!best || (l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos))))
                best = l;
        }
        return best || line;
    }
    return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head, start.assoc || -1);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null
        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let direction = view.textDirectionAt(line.from);
        let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2 });
        if (pos != null)
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start, check = null;;) {
        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
                return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = view.visualLineSide(line, !forward);
        }
        if (!check) {
            if (!by)
                return next;
            check = by(char);
        }
        else if (!check(char)) {
            return cur;
        }
        cur = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
        let nextCat = categorize(next);
        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.CharCategory.Space)
            cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
        if (goal == null)
            goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
    }
    else {
        let line = view.viewState.lineBlockAt(startPos);
        if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight >> 1);
    for (let extra = 0;; extra += 10) {
        let curY = startY + (dist + extra) * dir;
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
            let charRect = view.docView.coordsForChar(pos);
            let assoc = !charRect || curY < charRect.top ? -1 : 1;
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, assoc, undefined, goal);
        }
    }
}
function skipAtomicRanges(atoms, pos, bias) {
    for (;;) {
        let moved = 0;
        for (let set of atoms) {
            set.between(pos - 1, pos + 1, (from, to, value) => {
                if (pos > from && pos < to) {
                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);
                    pos = side < 0 ? from : to;
                    moved = side;
                }
            });
        }
        if (!moved)
            return pos;
    }
}
function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
const LineBreakPlaceholder = "\uffff";
class DOMReader {
    constructor(points, state) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.lineSeparator);
    }
    append(text) {
        this.text += text;
    }
    lineBreak() {
        this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
        if (!start)
            return this;
        let parent = start.parentNode;
        for (let cur = start;;) {
            this.findPointBefore(parent, cur);
            let oldLen = this.text.length;
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
                break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter :
                (view ? view.breakAfter : isBlockElement(cur)) ||
                    (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen))
                this.lineBreak();
            cur = next;
        }
        this.findPointBefore(parent, end);
        return this;
    }
    readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
            if (point.node == node)
                point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
                nextBreak = text.indexOf(this.lineSeparator, off);
                breakSize = this.lineSeparator.length;
            }
            else if (m = re.exec(text)) {
                nextBreak = m.index;
                breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
                break;
            this.lineBreak();
            if (breakSize > 1)
                for (let point of this.points)
                    if (point.node == node && point.pos > this.text.length)
                        point.pos -= breakSize - 1;
            off = nextBreak + breakSize;
        }
    }
    readNode(node) {
        if (node.cmIgnore)
            return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done;) {
                if (i.lineBreak)
                    this.lineBreak();
                else
                    this.append(i.value);
            }
        }
        else if (node.nodeType == 3) {
            this.readTextNode(node);
        }
        else if (node.nodeName == "BR") {
            if (node.nextSibling)
                this.lineBreak();
        }
        else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
                point.pos = this.text.length;
    }
    findPointInside(node, length) {
        for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
}
function isAtEnd(parent, node, offset) {
    for (;;) {
        if (!node || offset < maxOffset(node))
            return false;
        if (node == parent)
            return true;
        offset = domIndex(node) + 1;
        node = node.parentNode;
    }
}
class DOMPoint {
    constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
    }
}
class DOMChange {
    constructor(view, start, end, typeOver) {
        this.typeOver = typeOver;
        this.bounds = null;
        this.text = "";
        this.domChanged = start > -1;
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        if (view.state.readOnly && start > -1) {
            this.newSel = null;
        }
        else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
            let reader = new DOMReader(selPoints, view.state);
            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
            this.text = reader.text;
            this.newSel = selectionFromPoints(selPoints, this.bounds.from);
        }
        else {
            let domSel = view.observer.selectionRange;
            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
                !contains(view.contentDOM, domSel.focusNode)
                ? view.state.selection.main.head
                : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
                !contains(view.contentDOM, domSel.anchorNode)
                ? view.state.selection.main.anchor
                : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
            let vp = view.viewport;
            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor &&
                (vp.from > 0 || vp.to < view.state.doc.length)) {
                let from = Math.min(head, anchor), to = Math.max(head, anchor);
                let offFrom = vp.from - from, offTo = vp.to - to;
                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
                    head = 0;
                    anchor = view.state.doc.length;
                }
            }
            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(anchor, head);
        }
    }
}
function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
        let { from, to } = domChange.bounds;
        let preferredPos = sel.from, preferredSide = null;
        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
        if (diff) {
            if (browser.chrome && lastKey == 13 &&
                diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                diff.toB--;
            change = { from: from + diff.from, to: from + diff.toA,
                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };
        }
    }
    else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
        newSel = null;
    }
    if (!change && !newSel)
        return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    }
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&
        /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
        if (newSel && change.insert.length == 2)
            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: change.from, to: change.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([change.insert.toString().replace(".", " ")]) };
    }
    else if (change && change.from >= sel.from && change.to <= sel.to &&
        (change.from != sel.from || change.to != sel.to) &&
        (sel.to - sel.from) - (change.to - change.from) <= 4) {
        change = {
            from: sel.from, to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
        };
    }
    else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&
        change.insert.toString() == "\n " && view.lineWrapping) {
        if (newSel)
            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([" "]) };
    }
    if (change) {
        return applyDOMChangeInner(view, change, newSel, lastKey);
    }
    else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
                scrollIntoView = true;
            userEvent = view.inputState.lastSelectionOrigin;
        }
        view.dispatch({ selection: newSel, scrollIntoView, userEvent });
        return true;
    }
    else {
        return false;
    }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
    if (browser.ios && view.inputState.flushIOSKey(change))
        return true;
    let sel = view.state.selection.main;
    if (browser.android &&
        ((change.to == sel.to &&
            (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") &&
            change.insert.length == 1 && change.insert.lines == 2 &&
            dispatchKey(view.contentDOM, "Enter", 13)) ||
            ((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 ||
                lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) &&
                dispatchKey(view.contentDOM, "Backspace", 8)) ||
            (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                dispatchKey(view.contentDOM, "Delete", 46))))
        return true;
    let text = change.insert.toString();
    if (view.inputState.composing >= 0)
        view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert)))
        view.dispatch(defaultInsert());
    return true;
}
function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
        (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&
        view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
    }
    else {
        let changes = startState.changes(change);
        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&
            change.to <= sel.to && change.to >= sel.to - 10) {
            let replaced = view.state.sliceDoc(change.from, change.to);
            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
            if (composition) {
                let dLen = change.insert.length - (change.to - change.from);
                compositionRange = { from: composition.from, to: composition.to - dLen };
            }
            else {
                compositionRange = view.state.doc.lineAt(sel.head);
            }
            let offset = sel.to - change.to, size = sel.to - sel.from;
            tr = startState.changeByRange(range => {
                if (range.from == sel.from && range.to == sel.to)
                    return { changes, range: mainSel || range.map(changes) };
                let to = range.to - offset, from = to - replaced.length;
                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
                    range.to >= compositionRange.from && range.from <= compositionRange.to)
                    return { range };
                let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                return {
                    changes: rangeChanges,
                    range: !mainSel ? range.map(rangeChanges) :
                        _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                };
            });
        }
        else {
            tr = {
                changes,
                selection: mainSel && startState.selection.replaceRange(mainSel)
            };
        }
    }
    let userEvent = "input.type";
    if (view.composing ||
        view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
        view.inputState.compositionPendingChange = false;
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
            userEvent += ".start";
            view.inputState.compositionFirstChange = false;
        }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
        from++;
    if (from == minLen && a.length == b.length)
        return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    }
    else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return { from, toA, toB };
}
function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
        return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base) {
    if (points.length == 0)
        return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(anchor + base, head + base) : null;
}
class InputState {
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    constructor(view) {
        this.view = view;
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        this.pendingIOSKey = undefined;
        this.tabFocusMode = -1;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.handlers = Object.create(null);
        this.composing = -1;
        this.compositionFirstChange = null;
        this.compositionEndedAt = 0;
        this.compositionPendingKey = false;
        this.compositionPendingChange = false;
        this.mouseSelection = null;
        this.draggedContent = null;
        this.handleEvent = this.handleEvent.bind(this);
        this.notifiedFocused = view.hasFocus;
        if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
        if (browser.gecko)
            firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
            return;
        if (event.type == "keydown" && this.keydown(event))
            return;
        if (this.view.updateState != 0)
            Promise.resolve().then(() => this.runHandlers(event.type, event));
        else
            this.runHandlers(event.type, event);
    }
    runHandlers(type, event) {
        let handlers = this.handlers[type];
        if (handlers) {
            for (let observer of handlers.observers)
                observer(this.view, event);
            for (let handler of handlers.handlers) {
                if (event.defaultPrevented)
                    break;
                if (handler(this.view, event)) {
                    event.preventDefault();
                    break;
                }
            }
        }
    }
    ensureHandlers(plugins) {
        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
        for (let type in handlers)
            if (type != "scroll") {
                let passive = !handlers[type].handlers.length;
                let exists = prev[type];
                if (exists && passive != !exists.handlers.length) {
                    dom.removeEventListener(type, this.handleEvent);
                    exists = null;
                }
                if (!exists)
                    dom.addEventListener(type, this.handleEvent, { passive });
            }
        for (let type in prev)
            if (type != "scroll" && !handlers[type])
                dom.removeEventListener(type, this.handleEvent);
        this.handlers = handlers;
    }
    keydown(event) {
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
            return true;
        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
            this.tabFocusMode = -1;
        if (browser.android && browser.chrome && !event.synthetic &&
            (event.keyCode == 13 || event.keyCode == 8)) {
            this.view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
        }
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&
            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||
                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
            this.pendingIOSKey = pending || event;
            setTimeout(() => this.flushIOSKey(), 250);
            return true;
        }
        if (event.keyCode != 229)
            this.view.observer.forceFlush();
        return false;
    }
    flushIOSKey(change) {
        let key = this.pendingIOSKey;
        if (!key)
            return false;
        if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
            return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type))
            return false;
        if (this.composing > 0)
            return true;
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
            this.compositionPendingKey = false;
            return true;
        }
        return false;
    }
    startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
    }
    update(update) {
        this.view.observer.update(update);
        if (this.mouseSelection)
            this.mouseSelection.update(update);
        if (this.draggedContent && update.docChanged)
            this.draggedContent = this.draggedContent.map(update.changes);
        if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
    }
}
function bindHandler(plugin, handler) {
    return (view, event) => {
        try {
            return handler.call(plugin, event, view);
        }
        catch (e) {
            logException(view.state, e);
        }
    };
}
function computeHandlers(plugins) {
    let result = Object.create(null);
    function record(type) {
        return result[type] || (result[type] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
        let spec = plugin.spec, handlers = spec && spec.plugin.domEventHandlers, observers = spec && spec.plugin.domEventObservers;
        if (handlers)
            for (let type in handlers) {
                let f = handlers[type];
                if (f)
                    record(type).handlers.push(bindHandler(plugin.value, f));
            }
        if (observers)
            for (let type in observers) {
                let f = observers[type];
                if (f)
                    record(type).observers.push(bindHandler(plugin.value, f));
            }
    }
    for (let type in handlers)
        record(type).handlers.push(handlers[type]);
    for (let type in observers)
        record(type).observers.push(observers[type]);
    return result;
}
const PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist) {
    return Math.max(0, dist) * 0.7 + 8;
}
function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
    constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        this.mustSelect = mustSelect;
        this.scrollSpeed = { x: 0, y: 0 };
        this.scrolling = -1;
        this.lastEvent = startEvent;
        this.scrollParents = scrollableParents(view.contentDOM);
        this.atoms = view.state.facet(atomicRanges).map(f => f(view));
        let doc = view.contentDOM.ownerDocument;
        doc.addEventListener("mousemove", this.move = this.move.bind(this));
        doc.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
        if (this.dragging === false)
            this.select(event);
    }
    move(event) {
        if (event.buttons == 0)
            return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
            return;
        this.select(this.lastEvent = event);
        let sx = 0, sy = 0;
        let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
        if (this.scrollParents.x)
            ({ left, right } = this.scrollParents.x.getBoundingClientRect());
        if (this.scrollParents.y)
            ({ top, bottom } = this.scrollParents.y.getBoundingClientRect());
        let margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= left + dragScrollMargin)
            sx = -dragScrollSpeed(left - event.clientX);
        else if (event.clientX + margins.right >= right - dragScrollMargin)
            sx = dragScrollSpeed(event.clientX - right);
        if (event.clientY - margins.top <= top + dragScrollMargin)
            sy = -dragScrollSpeed(top - event.clientY);
        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
            sy = dragScrollSpeed(event.clientY - bottom);
        this.setScrollSpeed(sx, sy);
    }
    up(event) {
        if (this.dragging == null)
            this.select(this.lastEvent);
        if (!this.dragging)
            event.preventDefault();
        this.destroy();
    }
    destroy() {
        this.setScrollSpeed(0, 0);
        let doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy };
        if (sx || sy) {
            if (this.scrolling < 0)
                this.scrolling = setInterval(() => this.scroll(), 50);
        }
        else if (this.scrolling > -1) {
            clearInterval(this.scrolling);
            this.scrolling = -1;
        }
    }
    scroll() {
        let { x, y } = this.scrollSpeed;
        if (x && this.scrollParents.x) {
            this.scrollParents.x.scrollLeft += x;
            x = 0;
        }
        if (y && this.scrollParents.y) {
            this.scrollParents.y.scrollTop += y;
            y = 0;
        }
        if (x || y)
            this.view.win.scrollBy(x, y);
        if (this.dragging === false)
            this.select(this.lastEvent);
    }
    skipAtoms(sel) {
        let ranges = null;
        for (let i = 0; i < sel.ranges.length; i++) {
            let range = sel.ranges[i], updated = null;
            if (range.empty) {
                let pos = skipAtomicRanges(this.atoms, range.from, 0);
                if (pos != range.from)
                    updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, -1);
            }
            else {
                let from = skipAtomicRanges(this.atoms, range.from, -1);
                let to = skipAtomicRanges(this.atoms, range.to, 1);
                if (from != range.from || to != range.to)
                    updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
            }
            if (updated) {
                if (!ranges)
                    ranges = sel.ranges.slice();
                ranges[i] = updated;
            }
        }
        return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
            this.view.dispatch({
                selection,
                userEvent: "select.pointer"
            });
        this.mustSelect = false;
    }
    update(update) {
        if (update.transactions.some(tr => tr.isUserEvent("input.type")))
            this.destroy();
        else if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
        return false;
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
        return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.left <= event.clientX && rect.right >= event.clientX &&
            rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
            return false;
    return true;
}
const handlers = Object.create(null);
const observers = Object.create(null);
const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
    (browser.ios && browser.webkit_version < 604);
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function textFilter(state, facet, text) {
    for (let filter of state.facet(facet))
        text = filter(text, state);
    return text;
}
function doPaste(view, input) {
    input = textFilter(view.state, clipboardInputFilter, input);
    let { state } = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state.changeByRange(range => {
            let line = state.doc.lineAt(range.from);
            if (line.from == lastLine)
                return { range };
            lastLine = line.from;
            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
            return { changes: { from: line.from, insert },
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(range.from + insert.length) };
        });
    }
    else if (byLine) {
        changes = state.changeByRange(range => {
            let line = text.line(i++);
            return { changes: { from: range.from, to: range.to, insert: line.text },
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(range.from + line.length) };
        });
    }
    else {
        changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
    });
}
observers.scroll = view => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
        view.inputState.tabFocusMode = Date.now() + 2000;
    return false;
};
observers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = view => {
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2000)
        return false;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
            break;
    }
    if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
    if (style) {
        let mustFocus = !view.hasFocus;
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        if (mustFocus)
            view.observer.ignore(() => {
                focusPreventScroll(view.contentDOM);
                let active = view.root.activeElement;
                if (active && !active.contains(view.contentDOM))
                    active.blur();
            });
        let mouseSel = view.inputState.mouseSelection;
        if (mouseSel) {
            mouseSel.start(event);
            return mouseSel.dragging === false;
        }
    }
    return false;
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, bias);
    }
    else if (type == 2) {
        return groupAt(view.state, pos, bias);
    }
    else {
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to)
            to++;
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to);
    }
}
let inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
        return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
        return 1;
    if (off == line.length)
        return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
        return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
        return 1;
    return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
    if (!BadMouseDetail)
        return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    return {
        update(update) {
            if (update.docChanged) {
                start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
            }
        },
        get(event, extend, multiple) {
            let cur = queryPos(view, event), removed;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(to, from);
            }
            if (extend)
                return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
                return removed;
            else if (multiple)
                return startSel.addRange(range);
            else
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create([range]);
        }
    };
}
function removeRangeAround(sel, pos) {
    for (let i = 0; i < sel.ranges.length; i++) {
        let { from, to } = sel.ranges[i];
        if (from <= pos && to >= pos)
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
}
handlers.dragstart = (view, event) => {
    let { selection: { main: range } } = view.state;
    if (event.target.draggable) {
        let cView = view.docView.nearest(event.target);
        if (cView && cView.isWidget) {
            let from = cView.posAtStart, to = from + cView.length;
            if (from >= range.to || to <= range.from)
                range = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to);
        }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
        inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
        event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
};
handlers.dragend = view => {
    view.inputState.draggedContent = null;
    return false;
};
function dropText(view, event, text, direct) {
    text = textFilter(view.state, clipboardInputFilter, text);
    if (!text)
        return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event)
        ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
    if (!event.dataTransfer)
        return false;
    if (view.state.readOnly)
        return true;
    let files = event.dataTransfer.files;
    if (files && files.length) {
        let text = Array(files.length), read = 0;
        let finishFile = () => {
            if (++read == files.length)
                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
        };
        for (let i = 0; i < files.length; i++) {
            let reader = new FileReader;
            reader.onerror = finishFile;
            reader.onload = () => {
                if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                    text[i] = reader.result;
                finishFile();
            };
            reader.readAsText(files[i]);
        }
        return true;
    }
    else {
        let text = event.dataTransfer.getData("Text");
        if (text) {
            dropText(view, event, text, true);
            return true;
        }
    }
    return false;
};
handlers.paste = (view, event) => {
    if (view.state.readOnly)
        return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
        return true;
    }
    else {
        capturePaste(view);
        return false;
    }
};
function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state) {
    let content = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
        if (!range.empty) {
            content.push(state.sliceDoc(range.from, range.to));
            ranges.push(range);
        }
    if (!content.length) {
        let upto = -1;
        for (let { from } of state.selection.ranges) {
            let line = state.doc.lineAt(from);
            if (line.number > upto) {
                content.push(line.text);
                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return { text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
        return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
        });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        data.clearData();
        data.setData("text/plain", text);
        return true;
    }
    else {
        captureCopy(view, text);
        return false;
    }
};
const isFocusChange = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Annotation.define();
function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
        let effect = getEffect(state, focus);
        if (effect)
            effects.push(effect);
    }
    return effects.length ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
    setTimeout(() => {
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            let tr = focusChangeTransaction(view.state, focus);
            if (tr)
                view.dispatch(tr);
            else
                view.update([]);
        }
    }, 10);
}
observers.focus = view => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
};
observers.blur = view => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = view => {
    if (view.observer.editContext)
        return;
    if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
    }
};
observers.compositionend = view => {
    if (view.observer.editContext)
        return;
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
        view.observer.flushSoon();
    }
    else if (view.inputState.compositionPendingChange) {
        Promise.resolve().then(() => view.observer.flush());
    }
    else {
        setTimeout(() => {
            if (view.inputState.composing < 0 && view.docView.hasComposition)
                view.update([]);
        }, 50);
    }
};
observers.contextmenu = view => {
    view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
    var _a, _b;
    if (event.inputType == "insertReplacementText" && view.observer.editContext) {
        let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/plain"), ranges = event.getTargetRanges();
        if (text && ranges.length) {
            let r = ranges[0];
            let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
            applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
            return true;
        }
    }
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
            setTimeout(() => {
                var _a;
                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                    view.contentDOM.blur();
                    view.focus();
                }
            }, 100);
        }
    }
    if (browser.ios && event.inputType == "deleteContentForward") {
        view.observer.flushSoon();
    }
    if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
        setTimeout(() => observers.compositionend(view, event), 20);
    }
    return false;
};
const appliedFirefoxHack = new Set;
function firefoxCopyCutHack(doc) {
    if (!appliedFirefoxHack.has(doc)) {
        appliedFirefoxHack.add(doc);
        doc.addEventListener("copy", () => { });
        doc.addEventListener("cut", () => { });
    }
}
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let heightChangeFlag = false;
function clearHeightChangeFlag() { heightChangeFlag = false; }
class HeightOracle {
    constructor(lineWrapping) {
        this.lineWrapping = lineWrapping;
        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;
        this.heightSamples = {};
        this.lineHeight = 14;
        this.charWidth = 7;
        this.textHeight = 14;
        this.lineLength = 30;
    }
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping)
            lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping)
            return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc) { this.doc = doc; return this; }
    mustRefreshForWrapping(whiteSpace) {
        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
                i++;
            }
            else if (!this.heightSamples[Math.floor(h * 10)]) {
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
                let h = knownHeights[i];
                if (h < 0)
                    i++;
                else
                    this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
class MeasuredHeights {
    constructor(from, heights) {
        this.from = from;
        this.heights = heights;
        this.index = 0;
    }
    get more() { return this.index < this.heights.length; }
}
class BlockInfo {
    constructor(from, length, top, height, _content) {
        this.from = from;
        this.length = length;
        this.top = top;
        this.height = height;
        this._content = _content;
    }
    get type() {
        return typeof this._content == "number" ? BlockType.Text :
            Array.isArray(this._content) ? this._content : this._content.type;
    }
    get to() { return this.from + this.length; }
    get bottom() { return this.top + this.height; }
    get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0;
    }
    join(other) {
        let content = (Array.isArray(this._content) ? this._content : [this])
            .concat(Array.isArray(other._content) ? other._content : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
    }
}
var QueryType = (function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType;
})(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
    constructor(length, height, flags = 2) {
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    get outdated() { return (this.flags & 2) > 0; }
    set outdated(value) { this.flags = (value ? 2 : 0) | (this.flags & ~2); }
    setHeight(height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
                heightChangeFlag = true;
            this.height = height;
        }
    }
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) { result.push(this); }
    decomposeRight(_from, result) { result.push(this); }
    applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this, doc = oracle.doc;
        for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
                fromA = changes[i - 1].fromA;
                fromB = changes[i - 1].fromB;
                i--;
                if (fromA < start.from)
                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
            me = replace(me, me.replace(fromA, toA, nodes));
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() { return new HeightMapText(0, 0); }
    static of(nodes) {
        if (nodes.length == 1)
            return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (;;) {
            if (i == j) {
                if (before > after * 2) {
                    let split = nodes[i - 1];
                    if (split.break)
                        nodes.splice(--i, 1, split.left, null, split.right);
                    else
                        nodes.splice(--i, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                }
                else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break)
                        nodes.splice(j, 1, split.left, null, split.right);
                    else
                        nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                }
                else {
                    break;
                }
            }
            else if (before < after) {
                let next = nodes[i++];
                if (next)
                    before += next.size;
            }
            else {
                let next = nodes[--j];
                if (next)
                    after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
            brk = 1;
            i--;
        }
        else if (nodes[i] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
}
function replace(old, val) {
    if (old == val)
        return old;
    if (old.constructor != val.constructor)
        heightChangeFlag = true;
    return val;
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(length, height, deco) {
        super(length, height);
        this.deco = deco;
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top, offset) {
        return this.blockAt(0, oracle, top, offset);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        if (from <= offset + this.length && to >= offset)
            f(this.blockAt(0, oracle, top, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() { return `block(${this.length})`; }
}
class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
        super(length, height, null);
        this.collapsed = 0;
        this.widgetHeight = 0;
        this.breaks = 0;
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4)) &&
            Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
                node = new HeightMapText(node.length, this.height);
            else
                node.height = this.height;
            if (!this.outdated)
                node.outdated = false;
            return node;
        }
        else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        else if (force || this.outdated)
            this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +
                this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length) { super(length, 0); }
    heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
        let lines = lastLine - firstLine + 1;
        let perLine, perChar = 0;
        if (oracle.lineWrapping) {
            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
            perLine = totalPerLine / lines;
            if (this.length > lines + 1)
                perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        }
        else {
            perLine = this.height / lines;
        }
        return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        if (oracle.lineWrapping) {
            let guess = offset + (height < oracle.lineHeight ? 0
                : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));
            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
            let lineTop = Math.max(top, height - lineHeight / 2);
            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        }
        else {
            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
            let { from, length } = oracle.doc.line(firstLine + line);
            return new BlockInfo(from, length, top + perLine * line, perLine, 0);
        }
    }
    lineAt(value, type, oracle, top, offset) {
        if (type == QueryType.ByHeight)
            return this.blockAt(value, oracle, top, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from, to } = oracle.doc.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, 0);
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
        let linesAbove = line.number - firstLine;
        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        from = Math.max(from, offset);
        to = Math.min(to, offset + this.length);
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        for (let pos = from, lineTop = top; pos <= to;) {
            let line = oracle.doc.lineAt(pos);
            if (pos == from) {
                let linesAbove = line.number - firstLine;
                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
            }
            let lineHeight = perLine + perChar * line.length;
            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
            lineTop += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
                nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
                nodes[0] = new HeightMapGap(from + first.length);
            else
                nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            if (measured.from > offset)
                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length)
                    nodes.push(null);
                let height = measured.heights[measured.index++];
                if (singleHeight == -1)
                    singleHeight = height;
                else if (Math.abs(height - singleHeight) >= Epsilon)
                    singleHeight = -2;
                let line = new HeightMapText(len, height);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end)
                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||
                Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
                heightChangeFlag = true;
            return replace(this, result);
        }
        else if (force || this.outdated) {
            this.setHeight(oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() { return `gap(${this.length})`; }
}
class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() { return this.flags & 1; }
    blockAt(height, oracle, top, offset) {
        let mid = top + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top, offset)
            : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, oracle, top, offset) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base = left ? this.left.lineAt(value, type, oracle, top, offset)
            : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
        else
            return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset)
                this.left.forEachLine(from, to, oracle, top, offset, f);
            if (to >= rightOffset)
                this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
        }
        else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
            if (from < mid.from)
                this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
            if (mid.to >= from && mid.from <= to)
                f(mid);
            if (to > mid.to)
                this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0)
            this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)
            result.push(node);
        if (from > 0)
            mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
            return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left)
                result.push(null);
        }
        if (to > left)
            this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right)
            return this.right.decomposeRight(from - right, result);
        if (from < left)
            this.left.decomposeRight(from, result);
        if (this.break && from < right)
            result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = replace(this.left, left);
        this.right = replace(this.right, right);
        this.setHeight(left.height + right.height);
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
            left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
            right.updateHeight(oracle, rightStart, force);
        if (rebalance)
            return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() { return this.left + (this.break ? " " : "-") + this.right; }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
    constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
                last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
                this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            let breaks = deco.widget ? deco.widget.lineBreaks : 0;
            if (height < 0)
                height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco));
            }
            else if (len || breaks || height >= relevantWidgetHeight) {
                this.addLineDeco(height, breaks, len);
            }
        }
        else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let { from, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
            return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        let deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered)
            this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0)
            this.covering = block;
    }
    addLineDeco(height, breaks, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes) {
            if (node instanceof HeightMapText)
                node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle);
        _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange() { }
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
    }
}
function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc.body;) {
        if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&
                style.overflow != "visible") {
                let parentRect = elt.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top = Math.max(top, parentRect.top);
                bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
        }
        else if (parent.nodeType == 11) {
            parent = parent.host;
        }
        else {
            break;
        }
    }
    return { left: left - rect.left, right: Math.max(left, right) - rect.left,
        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };
}
function inWindow(elt) {
    let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;
    return rect.left < win.innerWidth && rect.right > 0 &&
        rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return { left: 0, right: rect.right - rect.left,
        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };
}
class LineGap {
    constructor(from, to, size, displaySize) {
        this.from = from;
        this.to = to;
        this.size = size;
        this.displaySize = displaySize;
    }
    static same(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                return false;
        }
        return true;
    }
    draw(viewState, wrapping) {
        return Decoration.replace({
            widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) { return other.size == this.size && other.vertical == this.vertical; }
    toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
            elt.style.height = this.size + "px";
        }
        else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
        }
        return elt;
    }
    get estimatedHeight() { return this.vertical ? this.size : -1; }
}
class ViewState {
    constructor(state) {
        this.state = state;
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0;
        this.paddingBottom = 0;
        this.contentDOMWidth = 0;
        this.contentDOMHeight = 0;
        this.editorHeight = 0;
        this.editorWidth = 0;
        this.scrollTop = 0;
        this.scrolledToBottom = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.scrollAnchorPos = 0;
        this.scrollAnchorHeight = -1;
        this.scaler = IdScaler;
        this.scrollTarget = null;
        this.printing = false;
        this.mustMeasureContent = true;
        this.defaultTextDirection = Direction.LTR;
        this.visibleRanges = [];
        this.mustEnforceCursorAssoc = false;
        let guessWrapping = state.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
        this.heightOracle = new HeightOracle(guessWrapping);
        this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        for (let i = 0; i < 2; i++) {
            this.viewport = this.getViewport(0, null);
            if (!this.updateForViewport())
                break;
        }
        this.updateViewportLines();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                let { from, to } = this.lineBlockAt(pos);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        return this.updateScaler();
    }
    updateScaler() {
        let scaler = this.scaler;
        this.scaler = this.heightMap.height <= 7000000 ? IdScaler :
            new BigScaler(this.heightOracle, this.heightMap, this.viewports);
        return scaler.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {
            this.viewportLines.push(scaleBlock(block, this.scaler));
        });
    }
    update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        clearHeightChangeFlag();
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight || heightChangeFlag)
            update.flags |= 2;
        if (scrollAnchor) {
            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
            this.scrollAnchorHeight = scrollAnchor.top;
        }
        else {
            this.scrollAnchorPos = -1;
            this.scrollAnchorHeight = prevHeight;
        }
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||
            !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        update.flags |= this.updateForViewport();
        if (viewportChange || !update.changes.empty || (update.flags & 2))
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 << 1))
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges(update.changes);
        if (scrollTarget)
            this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
            update.state.selection.main.empty && update.state.selection.main.assoc &&
            !update.state.facet(nativeSelectionHidden))
            this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let domRect = dom.getBoundingClientRect();
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        if (domRect.width && domRect.height) {
            let { scaleX, scaleY } = getScale(dom, domRect);
            if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 ||
                scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                result |= 16;
                refresh = measureContent = true;
            }
        }
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 16 | 2;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
                measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 16;
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
            this.scrollAnchorHeight = -1;
            this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
            this.inView = inView;
            if (inView)
                measureContent = true;
        }
        if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
            return 0;
        let contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = domRect.width;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 16;
        }
        if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
                refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);
                if (refresh) {
                    view.docView.minWidth = 0;
                    result |= 16;
                }
            }
            if (dTop > 0 && dBottom > 0)
                bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
                bias = Math.min(dTop, dBottom);
            clearHeightChangeFlag();
            for (let vp of this.viewports) {
                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (heightChangeFlag)
                result |= 2;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||
            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from ||
                this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) {
            if (result & 2)
                result |= this.updateScaler();
            this.viewport = this.getViewport(bias, this.scrollTarget);
            result |= this.updateForViewport();
        }
        if ((result & 2) || viewportChange)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 << 1))
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            view.docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }
    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }
    getViewport(bias, scrollTarget) {
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 / 2));
        let map = this.heightMap, oracle = this.heightOracle;
        let { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000, QueryType.ByHeight, oracle, 0, 0).to);
        if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
                if (scrollTarget.y == "center")
                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                    topPos = block.top;
                else
                    topPos = block.bottom - viewHeight;
                viewport = new Viewport(map.lineAt(topPos - 1000 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 / 2, QueryType.ByHeight, oracle, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    viewportIsAppropriate({ from, to }, bias = 0) {
        if (!this.inView)
            return true;
        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from == 0 || top <= visibleTop - Math.max(10, Math.min(-bias, 250))) &&
            (to == this.state.doc.length ||
                bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) &&
            (top > visibleTop - 2 * 1000 && bottom < visibleBottom + 2 * 1000);
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
            return gaps;
        let mapped = [];
        for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
        return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 10000 : 2000, halfMargin = margin >> 1, doubleMargin = margin << 1;
        if (this.defaultTextDirection != Direction.LTR && !wrapping)
            return [];
        let gaps = [];
        let addGap = (from, to, line, structure) => {
            if (to - from < halfMargin)
                return;
            let sel = this.state.selection.main, avoid = [sel.from];
            if (!sel.empty)
                avoid.push(sel.to);
            for (let pos of avoid) {
                if (pos > from && pos < to) {
                    addGap(from, pos - 10, line, structure);
                    addGap(pos + 10, to, line, structure);
                    return;
                }
            }
            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&
                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&
                !avoid.some(pos => gap.from < pos && gap.to > pos));
            if (!gap) {
                if (to < line.to && mayMeasure && wrapping &&
                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(to), false, true).head;
                    if (lineStart > from)
                        to = lineStart;
                }
                let size = this.gapSize(line, from, to, structure);
                let displaySize = wrapping || size < 2000000 ? size : 2000000;
                gap = new LineGap(from, to, size, displaySize);
            }
            gaps.push(gap);
        };
        let checkLine = (line) => {
            if (line.length < doubleMargin || line.type != BlockType.Text)
                return;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin)
                return;
            let target = this.scrollTarget ? this.scrollTarget.range.head : null;
            let viewFrom, viewTo;
            if (wrapping) {
                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
                let top, bot;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                    top = targetFrac - spaceFrac;
                    bot = targetFrac + spaceFrac;
                }
                else {
                    top = (this.visibleTop - line.top - marginHeight) / line.height;
                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                }
                viewFrom = findPosition(structure, top);
                viewTo = findPosition(structure, bot);
            }
            else {
                let totalWidth = structure.total * this.heightOracle.charWidth;
                let marginWidth = margin * this.heightOracle.charWidth;
                let horizOffset = 0;
                if (totalWidth > 2000000)
                    for (let old of current) {
                        if (old.from >= line.from && old.from < line.to && old.size != old.displaySize &&
                            old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                            horizOffset = old.size - old.displaySize;
                    }
                let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
                let left, right;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
                    left = targetFrac - spaceFrac;
                    right = targetFrac + spaceFrac;
                }
                else {
                    left = (pxLeft - marginWidth) / totalWidth;
                    right = (pxRight + marginWidth) / totalWidth;
                }
                viewFrom = findPosition(structure, left);
                viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from)
                addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to)
                addGap(viewTo, line.to, line, structure);
        };
        for (let line of this.viewportLines) {
            if (Array.isArray(line.type))
                line.type.forEach(checkLine);
            else
                checkLine(line);
        }
        return gaps;
    }
    gapSize(line, from, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
        }
        else {
            return structure.total * this.heightOracle.charWidth * fraction;
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));
        }
    }
    computeVisibleRanges(changes) {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) { ranges.push({ from, to }); },
            point() { }
        }, 20);
        let changed = 0;
        if (ranges.length != this.visibleRanges.length) {
            changed = 8 | 4;
        }
        else {
            for (let i = 0; i < ranges.length && !(changed & 8); i++) {
                let old = this.visibleRanges[i], nw = ranges[i];
                if (old.from != nw.from || old.to != nw.to) {
                    changed |= 4;
                    if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
                        changed |= 8;
                }
            }
        }
        this.visibleRanges = ranges;
        return changed;
    }
    lineBlockAt(pos) {
        return (pos >= this.viewport.from && pos <= this.viewport.to &&
            this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||
            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
        return (height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom &&
            this.viewportLines.find(l => l.top <= height && l.bottom >= height)) ||
            scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
    }
}
class Viewport {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(stateDeco, from, to, {
        span() { },
        point(from, to) {
            if (from > pos) {
                ranges.push({ from: pos, to: from });
                total += from - pos;
            }
            pos = to;
        }
    }, 20);
    if (pos < to) {
        ranges.push({ from: pos, to });
        total += to - pos;
    }
    return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
        return ranges[0].from;
    if (ratio >= 1)
        return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0;; i++) {
        let { from, to } = ranges[i], size = to - from;
        if (dist <= size)
            return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function find(array, f) {
    for (let val of array)
        if (f(val))
            return val;
    return undefined;
}
const IdScaler = {
    toDOM(n) { return n; },
    fromDOM(n) { return n; },
    scale: 1,
    eq(other) { return other == this; }
};
class BigScaler {
    constructor(oracle, heightMap, viewports) {
        let vpHeight = 0, base = 0, domBase = 0;
        this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7000000 - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
        }
    }
    toDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
                return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
                return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
                return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
                return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    eq(other) {
        if (!(other instanceof BigScaler))
            return false;
        return this.scale == other.scale && this.viewports.length == other.viewports.length &&
            this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
    }
}
function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
        return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);
}
const theme = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({ combine: strs => strs.join(" ") });
const darkTheme = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({ combine: values => values.indexOf(true) > -1 });
const baseThemeID = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {
        finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                if (m == "&")
                    return main;
                if (!scopes || !scopes[m])
                    throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme$1 = buildTheme("." + baseThemeID, {
    "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
        overflowAnchor: "none",
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only",
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        overflowWrap: "anywhere",
        flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
    },
    ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
            position: "absolute"
        }
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
        position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
    },
    ".cm-iso": {
        unicodeBidi: "isolate"
    },
    ".cm-announced": {
        position: "fixed",
        top: "-10000px"
    },
    "@media print": {
        ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        zIndex: 200,
    },
    ".cm-gutters-before": { insetInlineStart: 0 },
    ".cm-gutters-after": { insetInlineEnd: 0 },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        border: "0px solid #ddd",
        "&.cm-gutters-before": { borderRightWidth: "1px" },
        "&.cm-gutters-after": { borderLeftWidth: "1px" },
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    },
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0,
        zIndex: 300
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-dialog": {
        padding: "2px 19px 4px 6px",
        position: "relative",
        "& label": { fontSize: "80%" },
    },
    ".cm-dialog-close": {
        position: "absolute",
        top: "3px",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        fontSize: "14px",
        padding: "0"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
        userSelect: "none"
    },
    ".cm-highlightSpace": {
        backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
        backgroundPosition: "center",
    },
    ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);
const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
};
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
    constructor(view) {
        this.view = view;
        this.active = false;
        this.editContext = null;
        this.selectionRange = new DOMSelectionState;
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resizeScroll = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        this.printQuery = null;
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver(mutations => {
            for (let mut of mutations)
                this.queue.push(mut);
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                this.flushSoon();
            else
                this.flush();
        });
        if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false &&
            !(browser.chrome && browser.chrome_version < 126)) {
            this.editContext = new EditContextManager(view);
            if (view.state.facet(editable))
                view.contentDOM.editContext = this.editContext.editContext;
        }
        if (useCharData)
            this.onCharData = (event) => {
                this.queue.push({ target: event.target,
                    type: "characterData",
                    oldValue: event.prevValue });
                this.flushSoon();
            };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (window.matchMedia)
            this.printQuery = window.matchMedia("print");
        if (typeof ResizeObserver == "function") {
            this.resizeScroll = new ResizeObserver(() => {
                var _a;
                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
                    this.onResize();
            });
            this.resizeScroll.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver(entries => {
                if (this.parentCheck < 0)
                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView)
                        this.onScrollChanged(document.createEvent("Event"));
                }
            }, { threshold: [0, .001] });
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver(entries => {
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                    this.onScrollChanged(document.createEvent("Event"));
            }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
    }
    onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting)
            this.view.measure();
    }
    onScroll(e) {
        if (this.intersecting)
            this.flush(false);
        if (this.editContext)
            this.view.requestMeasure(this.editContext.measureReq);
        this.onScrollChanged(e);
    }
    onResize() {
        if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = -1;
                this.view.requestMeasure();
            }, 50);
    }
    onPrint(event) {
        if ((event.type == "change" || !event.type) && !event.matches)
            return;
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
        }, 500);
    }
    updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
                this.gapIntersection.observe(gap);
            this.gaps = gaps;
        }
    }
    onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
            return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
            if (!wasChanged)
                this.selectionChanged = false;
            return;
        }
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
        else
            this.flush(false);
    }
    readSelectionRange() {
        let { view } = this;
        let selection = getSelection(view.root);
        if (!selection)
            return false;
        let range = browser.safari && view.root.nodeType == 11 &&
            view.root.activeElement == this.dom &&
            safariSelectionRangeHack(this.view, selection) || selection;
        if (!range || this.selectionRange.eq(range))
            return false;
        let local = hasSelection(this.dom, range);
        if (local && !this.selectionChanged &&
            view.inputState.lastFocusTime > Date.now() - 200 &&
            view.inputState.lastTouchTime < Date.now() - 300 &&
            atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
        }
        this.selectionRange.setRange(range);
        if (local)
            this.selectionChanged = true;
        return true;
    }
    setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom;) {
            if (dom.nodeType == 1) {
                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                    i++;
                else if (!changed)
                    changed = this.scrollTargets.slice(0, i);
                if (changed)
                    changed.push(dom);
                dom = dom.assignedSlot || dom.parentNode;
            }
            else if (dom.nodeType == 11) {
                dom = dom.host;
            }
            else {
                break;
            }
        }
        if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
        if (changed) {
            for (let dom of this.scrollTargets)
                dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
                dom.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active)
            return f();
        try {
            this.stop();
            return f();
        }
        finally {
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active)
            return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active)
            return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
        var _a;
        if (!this.delayedAndroidKey) {
            let flush = () => {
                let key = this.delayedAndroidKey;
                if (key) {
                    this.clearDelayedAndroidKey();
                    this.view.inputState.lastKeyCode = key.keyCode;
                    this.view.inputState.lastKeyTime = Date.now();
                    let flushed = this.flush();
                    if (!flushed && key.force)
                        dispatchKey(this.dom, key.key, key.keyCode);
                }
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = {
                key, keyCode,
                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
            };
    }
    clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
    }
    flushSoon() {
        if (this.delayedFlush < 0)
            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            this.view.win.cancelAnimationFrame(this.delayedFlush);
            this.delayedFlush = -1;
        }
        this.flush();
    }
    pendingRecords() {
        for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
    }
    processRecords() {
        let records = this.pendingRecords();
        if (records.length)
            this.queue = [];
        let from = -1, to = -1, typeOver = false;
        for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
                continue;
            if (range.typeOver)
                typeOver = true;
            if (from == -1) {
                ({ from, to } = range);
            }
            else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        return { from, to, typeOver };
    }
    readChange() {
        let { from, to, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel)
            return null;
        if (from > -1)
            this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let change = new DOMChange(this.view, from, to, typeOver);
        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
        return change;
    }
    flush(readSelection = true) {
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
        if (readSelection)
            this.readSelectionRange();
        let domChange = this.readChange();
        if (!domChange) {
            this.view.requestMeasure();
            return false;
        }
        let startState = this.view.state;
        let handled = applyDOMChange(this.view, domChange);
        if (this.view.state == startState &&
            (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
            this.view.update([]);
        return handled;
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
            return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
            cView.flags |= 4;
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
        }
        else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        }
        else {
            return null;
        }
    }
    setWindow(win) {
        if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
        }
    }
    addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.addEventListener)
                this.printQuery.addEventListener("change", this.onPrint);
            else
                this.printQuery.addListener(this.onPrint);
        }
        else
            win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.removeEventListener)
                this.printQuery.removeEventListener("change", this.onPrint);
            else
                this.printQuery.removeListener(this.onPrint);
        }
        else
            win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update) {
        if (this.editContext) {
            this.editContext.update(update);
            if (update.startState.facet(editable) != update.state.facet(editable))
                update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
        }
    }
    destroy() {
        var _a, _b, _c;
        this.stop();
        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        if (this.editContext) {
            this.view.contentDOM.editContext = null;
            this.editContext.destroy();
        }
    }
}
function findChild(cView, dom, dir) {
    while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
            return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}
function buildSelectionRangeFromRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection) {
    if (selection.getComposedRanges) {
        let range = selection.getComposedRanges(view.root)[0];
        if (range)
            return buildSelectionRangeFromRange(view, range);
    }
    let found = null;
    function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    return found ? buildSelectionRangeFromRange(view, found) : null;
}
class EditContextManager {
    constructor(view) {
        this.from = 0;
        this.to = 0;
        this.pendingContextChange = null;
        this.handlers = Object.create(null);
        this.composing = null;
        this.resetRange(view.state);
        let context = this.editContext = new window.EditContext({
            text: view.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
            selectionEnd: this.toContextPos(view.state.selection.main.head)
        });
        this.handlers.textupdate = e => {
            let main = view.state.selection.main, { anchor, head } = main;
            let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
            if (view.inputState.composing >= 0 && !this.composing)
                this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };
            let change = { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of(e.text.split("\n")) };
            if (change.from == this.from && anchor < this.from)
                change.from = anchor;
            else if (change.to == this.to && anchor > this.to)
                change.to = anchor;
            if (change.from == change.to && !change.insert.length) {
                let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
                if (!newSel.main.eq(main))
                    view.dispatch({ selection: newSel, userEvent: "select" });
                return;
            }
            if ((browser.mac || browser.android) && change.from == head - 1 &&
                /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off")
                change = { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([e.text.replace(".", " ")]) };
            this.pendingContextChange = change;
            if (!view.state.readOnly) {
                let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
                applyDOMChangeInner(view, change, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
            }
            if (this.pendingContextChange) {
                this.revertPending(view.state);
                this.setSelection(view.state);
            }
        };
        this.handlers.characterboundsupdate = e => {
            let rects = [], prev = null;
            for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
                let rect = view.coordsForChar(i);
                prev = (rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top))
                    || prev || new DOMRect;
                rects.push(prev);
            }
            context.updateCharacterBounds(e.rangeStart, rects);
        };
        this.handlers.textformatupdate = e => {
            let deco = [];
            for (let format of e.getTextFormats()) {
                let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
                if (lineStyle != "None" && thickness != "None") {
                    let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
                    if (from < to) {
                        let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
                        deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
                    }
                }
            }
            view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
        };
        this.handlers.compositionstart = () => {
            if (view.inputState.composing < 0) {
                view.inputState.composing = 0;
                view.inputState.compositionFirstChange = true;
            }
        };
        this.handlers.compositionend = () => {
            view.inputState.composing = -1;
            view.inputState.compositionFirstChange = null;
            if (this.composing) {
                let { drifted } = this.composing;
                this.composing = null;
                if (drifted)
                    this.reset(view.state);
            }
        };
        for (let event in this.handlers)
            context.addEventListener(event, this.handlers[event]);
        this.measureReq = { read: view => {
                this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());
                let sel = getSelection(view.root);
                if (sel && sel.rangeCount)
                    this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
            } };
    }
    applyEdits(update) {
        let off = 0, abort = false, pending = this.pendingContextChange;
        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert) => {
            if (abort)
                return;
            let dLen = insert.length - (toA - fromA);
            if (pending && toA >= pending.to) {
                if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {
                    pending = this.pendingContextChange = null;
                    off += dLen;
                    this.to += dLen;
                    return;
                }
                else {
                    pending = null;
                    this.revertPending(update.state);
                }
            }
            fromA += off;
            toA += off;
            if (toA <= this.from) {
                this.from += dLen;
                this.to += dLen;
            }
            else if (fromA < this.to) {
                if (fromA < this.from || toA > this.to || (this.to - this.from) + insert.length > 30000) {
                    abort = true;
                    return;
                }
                this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());
                this.to += dLen;
            }
            off += dLen;
        });
        if (pending && !abort)
            this.revertPending(update.state);
        return !abort;
    }
    update(update) {
        let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
        if (this.composing &&
            (this.composing.drifted ||
                (!update.changes.touchesRange(startSel.from, startSel.to) &&
                    update.transactions.some(tr => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to))))) {
            this.composing.drifted = true;
            this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
        }
        else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
            this.pendingContextChange = null;
            this.reset(update.state);
        }
        else if (update.docChanged || update.selectionSet || reverted) {
            this.setSelection(update.state);
        }
        if (update.geometryChanged || update.docChanged || update.selectionSet)
            update.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
        let { head } = state.selection.main;
        this.from = Math.max(0, head - 10000);
        this.to = Math.min(state.doc.length, head + 10000);
    }
    reset(state) {
        this.resetRange(state);
        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
        this.setSelection(state);
    }
    revertPending(state) {
        let pending = this.pendingContextChange;
        this.pendingContextChange = null;
        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
        let { main } = state.selection;
        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
        let end = this.toContextPos(main.head);
        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
            this.editContext.updateSelection(start, end);
    }
    rangeIsValid(state) {
        let { head } = state.selection.main;
        return !(this.from > 0 && head - this.from < 500 ||
            this.to < state.doc.length && this.to - head < 500 ||
            this.to - this.from > 10000 * 3);
    }
    toEditorPos(contextPos, clipLen = this.to - this.from) {
        contextPos = Math.min(contextPos, clipLen);
        let c = this.composing;
        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
    }
    toContextPos(editorPos) {
        let c = this.composing;
        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
    }
    destroy() {
        for (let event in this.handlers)
            this.editContext.removeEventListener(event, this.handlers[event]);
    }
}
class EditorView {
    get state() { return this.viewState.state; }
    get viewport() { return this.viewState.viewport; }
    get visibleRanges() { return this.viewState.visibleRanges; }
    get inView() { return this.viewState.inView; }
    get composing() { return !!this.inputState && this.inputState.composing > 0; }
    get compositionStarted() { return !!this.inputState && this.inputState.composing >= 0; }
    get root() { return this._root; }
    get win() { return this.dom.ownerDocument.defaultView || window; }
    constructor(config = {}) {
        var _a;
        this.plugins = [];
        this.pluginMap = new Map;
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        this.updateState = 2;
        this.measureScheduled = -1;
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.className = "cm-announced";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        if (config.parent)
            config.parent.appendChild(this.dom);
        let { dispatch } = config;
        this.dispatchTransactions = config.dispatchTransactions ||
            (dispatch && ((trs) => trs.forEach(tr => dispatch(tr, this)))) ||
            ((trs) => this.update(trs));
        this.dispatch = this.dispatch.bind(this);
        this._root = (config.root || getRoot(config.parent) || document);
        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.create(config));
        if (config.scrollTo && config.scrollTo.is(scrollIntoView))
            this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
        for (let plugin of this.plugins)
            plugin.update(this);
        this.observer = new DOMObserver(this);
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0;
        this.requestMeasure();
        if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready)
            document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Transaction ? input
            : input.length == 1 && Array.isArray(input[0]) ? input[0]
                : [this.state.update(...input)];
        this.dispatchTransactions(trs, this);
    }
    update(transactions) {
        if (this.updateState != 0)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state = this.state;
        for (let tr of transactions) {
            if (tr.startState != state)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state = tr.state;
        }
        if (this.destroyed) {
            this.viewState.state = state;
            return;
        }
        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
        if (transactions.some(tr => tr.annotation(isFocusChange))) {
            this.inputState.notifiedFocused = focus;
            focusFlag = 1;
        }
        else if (focus != this.inputState.notifiedFocused) {
            this.inputState.notifiedFocused = focus;
            dispatchFocus = focusChangeTransaction(state, focus);
            if (!dispatchFocus)
                focusFlag = 1;
        }
        let pendingKey = this.observer.delayedAndroidKey, domChange = null;
        if (pendingKey) {
            this.observer.clearDelayedAndroidKey();
            domChange = this.observer.readChange();
            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
                domChange = null;
        }
        else {
            this.observer.clear();
        }
        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.phrases))
            return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        update.flags |= focusFlag;
        let scrollTarget = this.viewState.scrollTarget;
        try {
            this.updateState = 2;
            for (let tr of transactions) {
                if (scrollTarget)
                    scrollTarget = scrollTarget.map(tr.changes);
                if (tr.scrollIntoView) {
                    let { main } = tr.state.selection;
                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
                }
                for (let e of tr.effects)
                    if (e.is(scrollIntoView))
                        scrollTarget = e.value.clip(this.state);
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
                this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
        }
        finally {
            this.updateState = 0;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
        if (redrawn)
            this.docViewUpdate();
        if (!update.empty)
            for (let listener of this.state.facet(updateListener)) {
                try {
                    listener(update);
                }
                catch (e) {
                    logException(this.state, e, "update listener");
                }
            }
        if (dispatchFocus || domChange)
            Promise.resolve().then(() => {
                if (dispatchFocus && this.state == dispatchFocus.startState)
                    this.dispatch(dispatchFocus);
                if (domChange) {
                    if (!applyDOMChange(this, domChange) && pendingKey.force)
                        dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
                }
            });
    }
    setState(newState) {
        if (this.updateState != 0)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = newState;
            return;
        }
        this.updateState = 2;
        let hadFocus = this.hasFocus;
        try {
            for (let plugin of this.plugins)
                plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin of this.plugins)
                plugin.update(this);
            this.docView.destroy();
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        }
        finally {
            this.updateState = 0;
        }
        if (hadFocus)
            this.focus();
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                }
                else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)
                if (plugin.mustUpdate != update)
                    plugin.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
        }
        else {
            for (let p of this.plugins)
                p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
        if (prevSpecs != specs)
            this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
        for (let plugin of this.plugins) {
            let val = plugin.value;
            if (val && val.docViewUpdate) {
                try {
                    val.docViewUpdate(this);
                }
                catch (e) {
                    logException(this.state, e, "doc view update listener");
                }
            }
        }
    }
    measure(flush = true) {
        if (this.destroyed)
            return;
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
            this.measureScheduled = -1;
            this.requestMeasure();
            return;
        }
        this.measureScheduled = 0;
        if (flush)
            this.observer.forceFlush();
        let updated = null;
        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
            scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
            for (let i = 0;; i++) {
                if (scrollAnchorHeight < 0) {
                    if (isScrolledToBottom(sDOM)) {
                        scrollAnchorPos = -1;
                        scrollAnchorHeight = this.viewState.heightMap.height;
                    }
                    else {
                        let block = this.viewState.scrollAnchorAt(scrollTop);
                        scrollAnchorPos = block.from;
                        scrollAnchorHeight = block.top;
                    }
                }
                this.updateState = 1;
                let changed = this.viewState.measure(this);
                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                    break;
                if (i > 5) {
                    console.warn(this.measureRequests.length
                        ? "Measure loop restarted more than 5 times"
                        : "Viewport failed to stabilize");
                    break;
                }
                let measuring = [];
                if (!(changed & 4))
                    [this.measureRequests, measuring] = [measuring, this.measureRequests];
                let measured = measuring.map(m => {
                    try {
                        return m.read(this);
                    }
                    catch (e) {
                        logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = ViewUpdate.create(this, this.state, []), redrawn = false;
                update.flags |= changed;
                if (!updated)
                    updated = update;
                else
                    updated.flags |= changed;
                this.updateState = 2;
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                    this.updateAttrs();
                    redrawn = this.docView.update(update);
                    if (redrawn)
                        this.docViewUpdate();
                }
                for (let i = 0; i < measuring.length; i++)
                    if (measured[i] != BadMeasure) {
                        try {
                            let m = measuring[i];
                            if (m.write)
                                m.write(measured[i], this);
                        }
                        catch (e) {
                            logException(this.state, e);
                        }
                    }
                if (redrawn)
                    this.docView.updateSelection(true);
                if (!update.viewportChanged && this.measureRequests.length == 0) {
                    if (this.viewState.editorHeight) {
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget);
                            this.viewState.scrollTarget = null;
                            scrollAnchorHeight = -1;
                            continue;
                        }
                        else {
                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height :
                                this.viewState.lineBlockAt(scrollAnchorPos).top;
                            let diff = newAnchorHeight - scrollAnchorHeight;
                            if (diff > 1 || diff < -1) {
                                scrollTop = scrollTop + diff;
                                sDOM.scrollTop = scrollTop / this.scaleY;
                                scrollAnchorHeight = -1;
                                continue;
                            }
                        }
                    }
                    break;
                }
            }
        }
        finally {
            this.updateState = 0;
            this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
                listener(updated);
    }
    get themeClasses() {
        return baseThemeID + " " +
            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
            this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            writingsuggestions: "false",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
            for (let effect of tr.effects)
                if (effect.is(EditorView.announce)) {
                    if (first)
                        this.announceDOM.textContent = "";
                    first = false;
                    let div = this.announceDOM.appendChild(document.createElement("div"));
                    div.textContent = effect.value;
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        let nonce = this.state.facet(EditorView.cspNonce);
        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : undefined);
    }
    readMeasured() {
        if (this.updateState == 2)
            throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 && this.measureScheduled > -1)
            this.measure(false);
    }
    requestMeasure(request) {
        if (this.measureScheduled < 0)
            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
            if (this.measureRequests.indexOf(request) > -1)
                return;
            if (request.key != null)
                for (let i = 0; i < this.measureRequests.length; i++) {
                    if (this.measureRequests[i].key === request.key) {
                        this.measureRequests[i] = request;
                        return;
                    }
                }
            this.measureRequests.push(request);
        }
    }
    plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === undefined || known && known.plugin != plugin)
            this.pluginMap.set(plugin, known = this.plugins.find(p => p.plugin == plugin) || null);
        return known && known.update(this).value;
    }
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    get scaleX() { return this.viewState.scaleX; }
    get scaleY() { return this.viewState.scaleY; }
    elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
        return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
    }
    visualLineSide(line, end) {
        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
        let span = order[end ? order.length - 1 : 0];
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
    }
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
            return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));
    }
    coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
    }
    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
    get textDirection() { return this.viewState.defaultTextDirection; }
    textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
    bidiSpans(line) {
        if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from), isolates;
        for (let entry of this.bidiCache) {
            if (entry.from == line.from && entry.dir == dir &&
                (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
                return entry.order;
        }
        if (!isolates)
            isolates = getIsolatedRanges(this, line);
        let order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
    }
    get hasFocus() {
        var _a;
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&
            this.root.activeElement == this.contentDOM;
    }
    focus() {
        this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    setRoot(root) {
        if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
            this.mountStyles();
        }
    }
    destroy() {
        if (this.root.activeElement == this.contentDOM)
            this.contentDOM.blur();
        for (let plugin of this.plugins)
            plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.docView.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM;
        let ref = this.viewState.scrollAnchorAt(scrollTop);
        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    setTabFocusMode(to) {
        if (to == null)
            this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
        else if (typeof to == "boolean")
            this.inputState.tabFocusMode = to ? 0 : -1;
        else if (this.inputState.tabFocusMode != 0)
            this.inputState.tabFocusMode = Date.now() + to;
    }
    static domEventHandlers(handlers) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });
    }
    static domEventObservers(observers) {
        return ViewPlugin.define(() => ({}), { eventObservers: observers });
    }
    static theme(spec, options) {
        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
            result.push(darkTheme.of(true));
        return result;
    }
    static baseTheme(spec) {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
        var _a;
        let content = dom.querySelector(".cm-content");
        let cView = content && ContentView.get(content) || ContentView.get(dom);
        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
    }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({ combine: values => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.isolates = isolates;
        this.fresh = fresh;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty && !cache.some(c => c.fresh))
            return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
    }
}
function attrsFromFacet(view, facet, base) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
        let source = sources[i], value = typeof source == "function" ? source(view) : source;
        if (value)
            combineAttrs(value, base);
    }
    return base;
}
const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name, platform) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
const handleKeyEvents = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.default(EditorView.domEventHandlers({
    keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
}));
const keymap = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({ enables: handleKeyEvents });
const Keymaps = new WeakMap();
function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
}
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name, is) => {
        let current = isPrefix[name];
        if (current == null)
            isPrefix[name] = is;
        else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault, stopPropagation) => {
        var _a, _b;
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
        for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
                scopeObj[prefix] = {
                    preventDefault: true,
                    stopPropagation: false,
                    run: [(view) => {
                            let ourObj = storedPrefix = { view, prefix, scope };
                            setTimeout(() => {
                                if (storedPrefix == ourObj)
                                    storedPrefix = null;
                            }, PrefixTimeout);
                            return true;
                        }]
                };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = {
            preventDefault: false,
            stopPropagation: false,
            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
        });
        if (command)
            binding.run.push(command);
        if (preventDefault)
            binding.preventDefault = true;
        if (stopPropagation)
            binding.stopPropagation = true;
    };
    for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any)
            for (let scope of scopes) {
                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                if (!scopeObj._any)
                    scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
                let { any } = b;
                for (let key in scopeObj)
                    scopeObj[key].run.push(view => any(view, currentKeyEvent));
            }
        let name = b[platform] || b.key;
        if (!name)
            continue;
        for (let scope of scopes) {
            add(scope, name, b.run, b.preventDefault, b.stopPropagation);
            if (b.shift)
                add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
        }
    }
    return bound;
}
let currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
    currentKeyEvent = event;
    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);
    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointSize)(charCode) == name.length && name != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (modifierCodes.indexOf(event.keyCode) < 0) {
            prevented = true;
            storedPrefix = null;
        }
    }
    let ran = new Set;
    let runFor = (binding) => {
        if (binding) {
            for (let cmd of binding.run)
                if (!ran.has(cmd)) {
                    ran.add(cmd);
                    if (cmd(view)) {
                        if (binding.stopPropagation)
                            stopPropagation = true;
                        return true;
                    }
                }
            if (binding.preventDefault) {
                if (binding.stopPropagation)
                    stopPropagation = true;
                prevented = true;
            }
        }
        return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
            handled = true;
        }
        else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&
            !(browser.windows && event.ctrlKey && event.altKey) &&
            !(browser.mac && event.altKey && !event.ctrlKey) &&
            (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
                handled = true;
            }
            else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName &&
                runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
                handled = true;
            }
        }
        else if (isChar && event.shiftKey &&
            runFor(scopeObj[prefix + modifiers(name, event, true)])) {
            handled = true;
        }
        if (!handled && runFor(scopeObj._any))
            handled = true;
    }
    if (prevented)
        handled = true;
    if (handled && stopPropagation)
        event.stopPropagation();
    currentKeyEvent = null;
    return handled;
}
class RectangleMarker {
    constructor(className, left, top, width, height) {
        this.className = className;
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    update(elt, prev) {
        if (prev.className != this.className)
            return false;
        this.adjust(elt);
        return true;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width != null)
            elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
            this.className == p.className;
    }
    static forRange(view, className, range) {
        if (range.empty) {
            let pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (!pos)
                return [];
            let base = getBase(view);
            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
        }
        else {
            return rectanglesForRange(view, className, range);
        }
    }
}
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside) {
    let coords = view.coordsAtPos(pos, side * 2);
    if (!coords)
        return inside;
    let editorRect = view.dom.getBoundingClientRect();
    let y = (coords.top + coords.bottom) / 2;
    let left = view.posAtCoords({ x: editorRect.left + 1, y });
    let right = view.posAtCoords({ x: editorRect.right - 1, y });
    if (left == null || right == null)
        return inside;
    return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
    let lineElt = content.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left +
        (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to, -1);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
        visualStart = wrappedLine(view, from, 1, visualStart);
    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
        visualEnd = wrappedLine(view, to, -1, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
        return pieces(drawForLine(range.from, range.to, visualStart));
    }
    else {
        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
            startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
        return pieces(top).concat(between).concat(pieces(bottom));
    }
    function piece(left, top, right, bottom) {
        return new RectangleMarker(className, left - base.left, top - base.top, right - left, bottom - top);
    }
    function pieces({ top, bottom, horizontal }) {
        let pieces = [];
        for (let i = 0; i < horizontal.length; i += 2)
            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
        return pieces;
    }
    function drawForLine(from, to, line) {
        let top = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));
            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));
            if (!fromCoords || !toCoords)
                return;
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == Direction.LTR)
                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
        for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                    let docLine = view.state.doc.lineAt(pos);
                    for (let span of view.bidiSpans(docLine)) {
                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                        if (spanFrom >= endPos)
                            break;
                        if (spanTo > pos)
                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                    }
                    pos = docLine.to + 1;
                    if (pos >= endPos)
                        break;
                }
            }
        if (horizontal.length == 0)
            addSpan(start, from == null, end, to == null, view.textDirection);
        return { top, bottom, horizontal };
    }
    function drawForWidget(block, top) {
        let y = contentRect.top + (top ? block.top : block.bottom);
        return { top: y, bottom: y, horizontal: [] };
    }
}
function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
}
class LayerView {
    constructor(view, layer) {
        this.view = view;
        this.layer = layer;
        this.drawn = [];
        this.scaleX = 1;
        this.scaleY = 1;
        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
        this.dom = view.scrollDOM.appendChild(document.createElement("div"));
        this.dom.classList.add("cm-layer");
        if (layer.above)
            this.dom.classList.add("cm-layer-above");
        if (layer.class)
            this.dom.classList.add(layer.class);
        this.scale();
        this.dom.setAttribute("aria-hidden", "true");
        this.setOrder(view.state);
        view.requestMeasure(this.measureReq);
        if (layer.mount)
            layer.mount(this.dom, view);
    }
    update(update) {
        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
            this.setOrder(update.state);
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
            this.scale();
            update.view.requestMeasure(this.measureReq);
        }
    }
    docViewUpdate(view) {
        if (this.layer.updateOnDocViewUpdate !== false)
            view.requestMeasure(this.measureReq);
    }
    setOrder(state) {
        let pos = 0, order = state.facet(layerOrder);
        while (pos < order.length && order[pos] != this.layer)
            pos++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
        return this.layer.markers(this.view);
    }
    scale() {
        let { scaleX, scaleY } = this.view;
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
        }
    }
    draw(markers) {
        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
            let old = this.dom.firstChild, oldI = 0;
            for (let marker of markers) {
                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&
                    marker.update(old, this.drawn[oldI])) {
                    old = old.nextSibling;
                    oldI++;
                }
                else {
                    this.dom.insertBefore(marker.draw(), old);
                }
            }
            while (old) {
                let next = old.nextSibling;
                old.remove();
                old = next;
            }
            this.drawn = markers;
        }
    }
    destroy() {
        if (this.layer.destroy)
            this.layer.destroy(this.dom, this.view);
        this.dom.remove();
    }
}
const layerOrder = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
function layer(config) {
    return [
        ViewPlugin.define(v => new LayerView(v, config)),
        layerOrder.of(config)
    ];
}
const selectionConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
        });
    }
});
function drawSelection(config = {}) {
    return [
        selectionConfig.of(config),
        cursorLayer,
        selectionLayer,
        hideNativeSelection,
        nativeSelectionHidden.of(true)
    ];
}
function getDrawSelectionConfig(state) {
    return state.facet(selectionConfig);
}
function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = layer({
    above: true,
    markers(view) {
        let { state } = view, conf = state.facet(selectionConfig);
        let cursors = [];
        for (let r of state.selection.ranges) {
            let prim = r == state.selection.main;
            if (r.empty || conf.drawRangeCursor) {
                let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
                for (let piece of RectangleMarker.forRange(view, className, cursor))
                    cursors.push(piece);
            }
        }
        return cursors;
    },
    update(update, dom) {
        if (update.transactions.some(tr => tr.selection))
            dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        let confChange = configChanged(update);
        if (confChange)
            setBlinkRate(update.state, dom);
        return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view) {
        setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = layer({
    above: false,
    markers(view) {
        return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r))
            .reduce((a, b) => a.concat(b));
    },
    update(update, dom) {
        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
});
const hideNativeSelection = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.highest(EditorView.theme({
    ".cm-line": {
        "& ::selection, &::selection": { backgroundColor: "transparent !important" },
        caretColor: "transparent !important"
    },
    ".cm-content": {
        caretColor: "transparent !important",
        "& :focus": {
            caretColor: "initial !important",
            "&::selection, & ::selection": {
                backgroundColor: "Highlight !important"
            }
        }
    }
}));
const setDropCursorPos = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({
    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }
});
const dropCursorPos = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({
    create() { return null; },
    update(pos, tr) {
        if (pos != null)
            pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
    }
});
const drawDropCursor = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
        var _a;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
            if (this.cursor != null) {
                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                this.cursor = null;
            }
        }
        else {
            if (!this.cursor) {
                this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                this.view.requestMeasure(this.measureReq);
        }
    }
    readPos() {
        let { view } = this;
        let pos = view.state.field(dropCursorPos);
        let rect = pos != null && view.coordsAtPos(pos);
        if (!rect)
            return null;
        let outer = view.scrollDOM.getBoundingClientRect();
        return {
            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
            height: rect.bottom - rect.top
        };
    }
    drawCursor(pos) {
        if (this.cursor) {
            let { scaleX, scaleY } = this.view;
            if (pos) {
                this.cursor.style.left = pos.left / scaleX + "px";
                this.cursor.style.top = pos.top / scaleY + "px";
                this.cursor.style.height = pos.height / scaleY + "px";
            }
            else {
                this.cursor.style.left = "-100000px";
            }
        }
    }
    destroy() {
        if (this.cursor)
            this.cursor.remove();
    }
    setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
}, {
    eventObservers: {
        dragover(event) {
            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                this.setDropPos(null);
        },
        dragend() {
            this.setDropPos(null);
        },
        drop() {
            this.setDropPos(null);
        }
    }
});
function dropCursor() {
    return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
        if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
                f(pos + m.index, m);
    }
}
function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from &&
        visible[0].to == view.viewport.to)
        return visible;
    let result = [];
    for (let { from, to } of visible) {
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
        if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to;
        else
            result.push({ from, to });
    }
    return result;
}
class MatchDecorator {
    constructor(config) {
        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;
        if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
        }
        else if (typeof decoration == "function") {
            this.addMatch = (match, view, from, add) => {
                let deco = decoration(match, view, from);
                if (deco)
                    add(from, from + match[0].length, deco);
            };
        }
        else if (decoration) {
            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
        }
        else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
    }
    createDeco(view) {
        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder(), add = build.add.bind(build);
        for (let { from, to } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
        return build.finish();
    }
    updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
                if (to >= update.view.viewport.from && from <= update.view.viewport.to) {
                    changeFrom = Math.min(from, changeFrom);
                    changeTo = Math.max(to, changeTo);
                }
            });
        if (update.viewportMoved || changeTo - changeFrom > 1000)
            return this.createDeco(update.view);
        if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to >= from) {
                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for (; from > fromLine.from; from--)
                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                            start = from;
                            break;
                        }
                    for (; to < toLine.to; to++)
                        if (this.boundary.test(toLine.text[to - toLine.from])) {
                            end = to;
                            break;
                        }
                }
                let ranges = [], m;
                let add = (from, to, deco) => ranges.push(deco.range(from, to));
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                        this.addMatch(m, view, m.index + fromLine.from, add);
                }
                else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                }
                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });
            }
        }
        return deco;
    }
}
const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    var _a;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(configs) {
        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
        if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
        return config;
    }
});
function highlightSpecialChars(config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                    let { doc } = view.state;
                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(m[0], 0);
                    if (code == 9) {
                        let line = doc.lineAt(pos);
                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, size, pos - line.from);
                        return Decoration.replace({
                            widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)
                        });
                    }
                    return this.decorationCache[code] ||
                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            }
            else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: v => v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
function placeholder$1(code) {
    if (code >= 32)
        return DefaultPlaceholder;
    if (code == 10)
        return "\u2424";
    return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends WidgetType {
    constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
    }
    eq(other) { return other.code == this.code; }
    toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
            return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
    }
    ignoreEvent() { return false; }
}
class TabWidget extends WidgetType {
    constructor(width) {
        super();
        this.width = width;
    }
    eq(other) { return other.width == this.width; }
    toDOM() {
        let span = document.createElement("span");
        span.textContent = "\t";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
    }
    ignoreEvent() { return false; }
}
const plugin = ViewPlugin.fromClass(class {
    constructor() {
        this.height = 1000;
        this.attrs = { style: "padding-bottom: 1000px" };
    }
    update(update) {
        let { view } = update;
        let height = view.viewState.editorHeight -
            view.defaultLineHeight - view.documentPadding.top - 0.5;
        if (height >= 0 && height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
        }
    }
});
function scrollPastEnd() {
    return [plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];
}
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});
class Placeholder extends WidgetType {
    constructor(content) {
        super();
        this.content = content;
    }
    toDOM(view) {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) :
            typeof this.content == "function" ? this.content(view) :
                this.content.cloneNode(true));
        wrap.setAttribute("aria-hidden", "true");
        return wrap;
    }
    coordsAt(dom) {
        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
        if (!rects.length)
            return null;
        let style = window.getComputedStyle(dom.parentNode);
        let rect = flattenRect(rects[0], style.direction != "rtl");
        let lineHeight = parseInt(style.lineHeight);
        if (rect.bottom - rect.top > lineHeight * 1.5)
            return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
        return rect;
    }
    ignoreEvent() { return false; }
}
function placeholder(content) {
    let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.placeholder = content
                ? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)])
                : Decoration.none;
        }
        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }
    }, { decorations: v => v.decorations });
    return typeof content == "string" ? [
        plugin, EditorView.contentAttributes.of({ "aria-placeholder": content })
    ] : plugin;
}
const MaxOff = 2000;
function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            if (line.length <= endOff)
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(line.from + startOff, line.to + endOff));
        }
    }
    else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(line.text, startCol, state.tabSize, true);
            if (start < 0) {
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(line.to));
            }
            else {
                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(line.text, endCol, state.tabSize);
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(line.from + start, line.from + end));
            }
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1
        : off == line.length ? absoluteColumn(view, event.clientX)
            : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
        return null;
    return {
        update(update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                startSel = startSel.map(update.changes);
            }
        },
        get(event, _extend, multiple) {
            let cur = getPos(view, event);
            if (!cur)
                return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
                return startSel;
            if (multiple)
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges.concat(startSel.ranges));
            else
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges);
        }
    };
}
function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
    Alt: [18, e => !!e.altKey],
    Control: [17, e => !!e.ctrlKey],
    Shift: [16, e => !!e.shiftKey],
    Meta: [91, e => !!e.metaKey]
};
const showCrosshair = { style: "cursor: crosshair" };
function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.isDown = false;
        }
        set(isDown) {
            if (this.isDown != isDown) {
                this.isDown = isDown;
                this.view.update([]);
            }
        }
    }, {
        eventObservers: {
            keydown(e) {
                this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
                if (e.keyCode == code || !getter(e))
                    this.set(false);
            },
            mousemove(e) {
                this.set(getter(e));
            }
        }
    });
    return [
        plugin,
        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })
    ];
}
const Outside = "-10000px";
class TooltipViewManager {
    constructor(view, facet, createTooltipView, removeTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.removeTooltipView = removeTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter(t => t);
        let prev = null;
        this.tooltipViews = this.tooltips.map(t => prev = createTooltipView(t, prev));
    }
    update(update, above) {
        var _a;
        let input = update.state.facet(this.facet);
        let tooltips = input.filter(x => x);
        if (input === this.input) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
            return false;
        }
        let tooltipViews = [], newAbove = above ? [] : null;
        for (let i = 0; i < tooltips.length; i++) {
            let tip = tooltips[i], known = -1;
            if (!tip)
                continue;
            for (let i = 0; i < this.tooltips.length; i++) {
                let other = this.tooltips[i];
                if (other && other.create == tip.create)
                    known = i;
            }
            if (known < 0) {
                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
                if (newAbove)
                    newAbove[i] = !!tip.above;
            }
            else {
                let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                if (newAbove)
                    newAbove[i] = above[known];
                if (tooltipView.update)
                    tooltipView.update(update);
            }
        }
        for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0) {
                this.removeTooltipView(t);
                (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
            }
        if (above) {
            newAbove.forEach((val, i) => above[i] = val);
            above.length = newAbove.length;
        }
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
    }
}
function tooltips(config = {}) {
    return tooltipConfig.of(config);
}
function windowSpace(view) {
    let docElt = view.dom.ownerDocument.documentElement;
    return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
}
const tooltipConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine: values => {
        var _a, _b, _c;
        return ({
            position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
        });
    }
});
const knownHeight = new WeakMap();
const tooltipPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.above = [];
        this.inView = true;
        this.madeAbsolute = false;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config = view.state.facet(tooltipConfig);
        this.position = config.position;
        this.parent = config.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
        this.manager = new TooltipViewManager(view, showTooltip, (t, p) => this.createTooltip(t, p), t => {
            if (this.resizeObserver)
                this.resizeObserver.unobserve(t.dom);
            t.dom.remove();
        });
        this.above = this.manager.tooltips.map(t => !!t.above);
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
            if (Date.now() > this.lastTransaction - 50 &&
                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
    }
    createContainer() {
        if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
        }
        else {
            this.container = this.view.dom;
        }
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
                this.intersectionObserver.observe(tooltip.dom);
        }
    }
    measureSoon() {
        if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
                this.measureTimeout = -1;
                this.maybeMeasure();
            }, 50);
    }
    update(update) {
        if (update.transactions.length)
            this.lastTransaction = Date.now();
        let updated = this.manager.update(update, this.above);
        if (updated)
            this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = this.position;
            shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
            if (this.parent)
                this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
                this.container.appendChild(t.dom);
            shouldMeasure = true;
        }
        else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
            this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
        let tooltipView = tooltip.create(this.view);
        let before = prev ? prev.dom : null;
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        tooltipView.dom.style.left = "0px";
        this.container.insertBefore(tooltipView.dom, before);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        if (this.resizeObserver)
            this.resizeObserver.observe(tooltipView.dom);
        return tooltipView;
    }
    destroy() {
        var _a, _b, _c;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let tooltipView of this.manager.tooltipViews) {
            tooltipView.dom.remove();
            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
        }
        if (this.parent)
            this.container.remove();
        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        clearTimeout(this.measureTimeout);
    }
    readMeasure() {
        let scaleX = 1, scaleY = 1, makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let { dom } = this.manager.tooltipViews[0];
            if (browser.gecko) {
                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
            }
            else if (dom.style.top == Outside && dom.style.left == "0px") {
                let rect = dom.getBoundingClientRect();
                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;
            }
        }
        if (makeAbsolute || this.position == "absolute") {
            if (this.parent) {
                let rect = this.parent.getBoundingClientRect();
                if (rect.width && rect.height) {
                    scaleX = rect.width / this.parent.offsetWidth;
                    scaleY = rect.height / this.parent.offsetHeight;
                }
            }
            else {
                ({ scaleX, scaleY } = this.view.viewState);
            }
        }
        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
        return {
            visible: {
                left: visible.left + margins.left, top: visible.top + margins.top,
                right: visible.right - margins.right, bottom: visible.bottom - margins.bottom
            },
            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
            pos: this.manager.tooltips.map((t, i) => {
                let tv = this.manager.tooltipViews[i];
                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
            scaleX, scaleY, makeAbsolute
        };
    }
    writeMeasure(measured) {
        var _a;
        if (measured.makeAbsolute) {
            this.madeAbsolute = true;
            this.position = "absolute";
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = "absolute";
        }
        let { visible, space, scaleX, scaleY } = measured;
        let others = [];
        for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) ||
                pos.top >= Math.min(visible.bottom, space.bottom) ||
                pos.right < Math.max(visible.left, space.left) - .1 ||
                pos.left > Math.min(visible.right, space.right) + .1)) {
                dom.style.top = Outside;
                continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 : 0;
            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
            let left = size.width > space.right - space.left
                ? (ltr ? space.left : space.right - size.width)
                : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width))
                    : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space.right - width);
            let above = this.above[i];
            if (!tooltip.strictSide && (above
                ? pos.top - height - arrowHeight - offset.y < space.top
                : pos.bottom + height + arrowHeight + offset.y > space.bottom) &&
                above == (space.bottom - pos.bottom > pos.top - space.top))
                above = this.above[i] = !above;
            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
            if (spaceVert < height && tView.resize !== false) {
                if (spaceVert < this.view.defaultLineHeight) {
                    dom.style.top = Outside;
                    continue;
                }
                knownHeight.set(tView, height);
                dom.style.height = (height = spaceVert) / scaleY + "px";
            }
            else if (dom.style.height) {
                dom.style.height = "";
            }
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true)
                for (let r of others)
                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            if (this.position == "absolute") {
                dom.style.top = (top - measured.parent.top) / scaleY + "px";
                setLeftStyle(dom, (left - measured.parent.left) / scaleX);
            }
            else {
                dom.style.top = top / scaleY + "px";
                setLeftStyle(dom, left / scaleX);
            }
            if (arrow) {
                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
                arrow.style.left = arrowLeft / scaleX + "px";
            }
            if (tView.overlap !== true)
                others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
                tView.positioned(measured.space);
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length) {
            if (this.view.inView)
                this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
                this.inView = this.view.inView;
                if (!this.inView)
                    for (let tv of this.manager.tooltipViews)
                        tv.dom.style.top = Outside;
            }
        }
    }
}, {
    eventObservers: {
        scroll() { this.maybeMeasure(); }
    }
});
function setLeftStyle(elt, value) {
    let current = parseInt(elt.style.left, 10);
    if (isNaN(current) || Math.abs(value - current) > 1)
        elt.style.left = value + "px";
}
const baseTheme = EditorView.baseTheme({
    ".cm-tooltip": {
        zIndex: 500,
        boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb",
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: `${7}px`,
        width: `${7 * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7}px solid transparent`,
            borderRight: `${7}px solid transparent`,
        },
        ".cm-tooltip-above &": {
            bottom: `-${7}px`,
            "&:before": {
                borderTop: `${7}px solid #bbb`,
            },
            "&:after": {
                borderTop: `${7}px solid #f5f5f5`,
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: `-${7}px`,
            "&:before": {
                borderBottom: `${7}px solid #bbb`,
            },
            "&:after": {
                borderBottom: `${7}px solid #f5f5f5`,
                top: "1px"
            }
        },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
});
const noOffset = { x: 0, y: 0 };
const showTooltip = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    enables: [tooltipPlugin, baseTheme]
});
const showHoverTooltip = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine: inputs => inputs.reduce((a, i) => a.concat(i), [])
});
class HoverTooltipHost {
    static create(view) {
        return new HoverTooltipHost(view);
    }
    constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p) => this.createHostedView(t, p), t => t.dom.remove());
    }
    createHostedView(tooltip, prev) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
        if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
        return hostedView;
    }
    mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
                hostedView.mount(view);
        }
        this.mounted = true;
    }
    positioned(space) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
                hostedView.positioned(space);
        }
    }
    update(update) {
        this.manager.update(update);
    }
    destroy() {
        var _a;
        for (let t of this.manager.tooltipViews)
            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
    }
    passProp(name) {
        let value = undefined;
        for (let view of this.manager.tooltipViews) {
            let given = view[name];
            if (given !== undefined) {
                if (value === undefined)
                    value = given;
                else if (value !== given)
                    return undefined;
            }
        }
        return value;
    }
    get offset() { return this.passProp("offset"); }
    get getCoords() { return this.passProp("getCoords"); }
    get overlap() { return this.passProp("overlap"); }
    get resize() { return this.passProp("resize"); }
}
const showHoverTooltipHost = showTooltip.compute([showHoverTooltip], state => {
    let tooltips = state.facet(showHoverTooltip);
    if (tooltips.length === 0)
        return null;
    return {
        pos: Math.min(...tooltips.map(t => t.pos)),
        end: Math.max(...tooltips.map(t => { var _a; return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos; })),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some(t => t.arrow),
    };
});
class HoverPlugin {
    constructor(view, source, field, setHover, hoverTime) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active.length)
            return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
            this.startHover();
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let { view, lastMove } = this;
        let desc = view.docView.nearest(lastMove.target);
        if (!desc)
            return;
        let pos, side = 1;
        if (desc instanceof WidgetView) {
            pos = desc.posAtStart;
        }
        else {
            pos = view.posAtCoords(lastMove);
            if (pos == null)
                return;
            let posCoords = view.coordsAtPos(pos);
            if (!posCoords ||
                lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||
                lastMove.x < posCoords.left - view.defaultCharacterWidth ||
                lastMove.x > posCoords.right + view.defaultCharacterWidth)
                return;
            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
            side = (lastMove.x < posCoords.left ? -rtl : rtl);
        }
        let open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
            let pending = this.pending = { pos };
            open.then(result => {
                if (this.pending == pending) {
                    this.pending = null;
                    if (result && !(Array.isArray(result) && !result.length))
                        view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
                }
            }, e => logException(view.state, e, "hover tooltip"));
        }
        else if (open && !(Array.isArray(open) && !open.length)) {
            view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
        }
    }
    get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin);
        let index = plugin ? plugin.manager.tooltips.findIndex(t => t.create == HoverTooltipHost.create) : -1;
        return index > -1 ? plugin.manager.tooltipViews[index] : null;
    }
    mousemove(event) {
        var _a, _b;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let { active, tooltip } = this;
        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;
            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {
                this.view.dispatch({ effects: this.setHover.of([]) });
                this.pending = null;
            }
        }
    }
    mouseleave(event) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        let { active } = this;
        if (active.length) {
            let { tooltip } = this;
            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
            if (!inTooltip)
                this.view.dispatch({ effects: this.setHover.of([]) });
            else
                this.watchTooltipLeave(tooltip.dom);
        }
    }
    watchTooltipLeave(tooltip) {
        let watch = (event) => {
            tooltip.removeEventListener("mouseleave", watch);
            if (this.active.length && !this.view.dom.contains(event.relatedTarget))
                this.view.dispatch({ effects: this.setHover.of([]) });
        };
        tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
const tooltipMargin = 4;
function isInTooltip(tooltip, event) {
    let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;
    if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
        let arrowRect = arrow.getBoundingClientRect();
        top = Math.min(arrowRect.top, top);
        bottom = Math.max(arrowRect.bottom, bottom);
    }
    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin &&
        event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x, y, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
        return false;
    let pos = view.posAtCoords({ x, y }, false);
    return pos >= from && pos <= to;
}
function hoverTooltip(source, options = {}) {
    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();
    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({
        create() { return []; },
        update(value, tr) {
            if (value.length) {
                if (options.hideOnChange && (tr.docChanged || tr.selection))
                    value = [];
                else if (options.hideOn)
                    value = value.filter(v => !options.hideOn(tr, v));
                if (tr.docChanged) {
                    let mapped = [];
                    for (let tooltip of value) {
                        let newPos = tr.changes.mapPos(tooltip.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackDel);
                        if (newPos != null) {
                            let copy = Object.assign(Object.create(null), tooltip);
                            copy.pos = newPos;
                            if (copy.end != null)
                                copy.end = tr.changes.mapPos(copy.end);
                            mapped.push(copy);
                        }
                    }
                    value = mapped;
                }
            }
            for (let effect of tr.effects) {
                if (effect.is(setHover))
                    value = effect.value;
                if (effect.is(closeHoverTooltipEffect))
                    value = [];
            }
            return value;
        },
        provide: f => showHoverTooltip.from(f)
    });
    return {
        active: hoverState,
        extension: [
            hoverState,
            ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)),
            showHoverTooltipHost
        ]
    };
}
function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
        return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
}
function hasHoverTooltips(state) {
    return state.facet(showHoverTooltip).some(x => x);
}
const closeHoverTooltipEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();
const closeHoverTooltips = closeHoverTooltipEffect.of(null);
function repositionTooltips(view) {
    let plugin = view.plugin(tooltipPlugin);
    if (plugin)
        plugin.maybeMeasure();
}
const panelConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
    }
});
function panels(config) {
    return config ? [panelConfig.of(config)] : [];
}
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter(s => s);
        this.panels = this.specs.map(spec => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter(p => p.top));
        this.bottom.sync(this.panels.filter(p => !p.top));
        for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
                p.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter(x => x);
            let panels = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                }
                else {
                    panel = this.panels[known];
                    if (panel.update)
                        panel.update(update);
                }
                panels.push(panel);
                (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
                p.dom.classList.add("cm-panel");
                if (p.mount)
                    p.mount();
            }
        }
        else {
            for (let p of this.panels)
                if (p.update)
                    p.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
});
class PanelGroup {
    constructor(view, top, container) {
        this.view = view;
        this.top = top;
        this.container = container;
        this.dom = undefined;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
    }
    sync(panels) {
        for (let p of this.panels)
            if (p.destroy && panels.indexOf(p) < 0)
                p.destroy();
        this.panels = panels;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
                while (curDOM != panel.dom)
                    curDOM = rm(curDOM);
                curDOM = curDOM.nextSibling;
            }
            else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while (curDOM)
            curDOM = rm(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0
            : Math.max(0, this.top ?
                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :
                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
            return;
        for (let cls of this.classes.split(" "))
            if (cls)
                this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
                this.container.classList.add(cls);
    }
}
function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
const showPanel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    enables: panelPlugin
});
function showDialog(view, config) {
    let resolve;
    let promise = new Promise(r => resolve = r);
    let panelCtor = (view) => createDialog(view, config, resolve);
    if (view.state.field(dialogField, false)) {
        view.dispatch({ effects: openDialogEffect.of(panelCtor) });
    }
    else {
        view.dispatch({ effects: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(dialogField.init(() => [panelCtor])) });
    }
    let close = closeDialogEffect.of(panelCtor);
    return { close, result: promise.then(form => {
            let queue = view.win.queueMicrotask || ((f) => view.win.setTimeout(f, 10));
            queue(() => {
                if (view.state.field(dialogField).indexOf(panelCtor) > -1)
                    view.dispatch({ effects: close });
            });
            return form;
        }) };
}
function getDialog(view, className) {
    let dialogs = view.state.field(dialogField, false) || [];
    for (let open of dialogs) {
        let panel = getPanel(view, open);
        if (panel && panel.dom.classList.contains(className))
            return panel;
    }
    return null;
}
const dialogField = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({
    create() { return []; },
    update(dialogs, tr) {
        for (let e of tr.effects) {
            if (e.is(openDialogEffect))
                dialogs = [e.value].concat(dialogs);
            else if (e.is(closeDialogEffect))
                dialogs = dialogs.filter(d => d != e.value);
        }
        return dialogs;
    },
    provide: f => showPanel.computeN([f], state => state.field(f))
});
const openDialogEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();
const closeDialogEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();
function createDialog(view, config, result) {
    let content = config.content ? config.content(view, () => done(null)) : null;
    if (!content) {
        content = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("form");
        if (config.input) {
            let input = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("input", config.input);
            if (/^(text|password|number|email|tel|url)$/.test(input.type))
                input.classList.add("cm-textfield");
            if (!input.name)
                input.name = "input";
            content.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("label", (config.label || "") + ": ", input));
        }
        else {
            content.appendChild(document.createTextNode(config.label || ""));
        }
        content.appendChild(document.createTextNode(" "));
        content.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("button", { class: "cm-button", type: "submit" }, config.submitLabel || "OK"));
    }
    let forms = content.nodeName == "FORM" ? [content] : content.querySelectorAll("form");
    for (let i = 0; i < forms.length; i++) {
        let form = forms[i];
        form.addEventListener("keydown", (event) => {
            if (event.keyCode == 27) {
                event.preventDefault();
                done(null);
            }
            else if (event.keyCode == 13) {
                event.preventDefault();
                done(form);
            }
        });
        form.addEventListener("submit", (event) => {
            event.preventDefault();
            done(form);
        });
    }
    let panel = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("div", content, (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("button", {
        onclick: () => done(null),
        "aria-label": view.state.phrase("close"),
        class: "cm-dialog-close",
        type: "button"
    }, ["×"]));
    if (config.class)
        panel.className = config.class;
    panel.classList.add("cm-dialog");
    function done(form) {
        if (panel.contains(panel.ownerDocument.activeElement))
            view.focus();
        result(form);
    }
    return {
        dom: panel,
        top: config.top,
        mount: () => {
            if (config.focus) {
                let focus;
                if (typeof config.focus == "string")
                    focus = content.querySelector(config.focus);
                else
                    focus = content.querySelector("input") || content.querySelector("button");
                if (focus && "select" in focus)
                    focus.select();
                else if (focus && "focus" in focus)
                    focus.focus();
            }
        }
    };
}
class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeValue {
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) { return false; }
    destroy(dom) { }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
const gutterLineClass = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const gutterWidgetClass = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {},
    side: "before"
};
const activeGutters = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const unfixGutters = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine: values => values.some(x => x)
});
function gutters(config) {
    let result = [
        gutterView,
    ];
    if (config && config.fixed === false)
        result.push(unfixGutters.of(true));
    return result;
}
const gutterView = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.domAfter = null;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters cm-gutters-before";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
        this.fixed = !view.state.facet(unfixGutters);
        for (let gutter of this.gutters) {
            if (gutter.config.side == "after")
                this.getDOMAfter().appendChild(gutter.dom);
            else
                this.dom.appendChild(gutter.dom);
        }
        if (this.fixed) {
            this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    getDOMAfter() {
        if (!this.domAfter) {
            this.domAfter = document.createElement("div");
            this.domAfter.className = "cm-gutters cm-gutters-after";
            this.domAfter.setAttribute("aria-hidden", "true");
            this.domAfter.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
            this.domAfter.style.position = this.fixed ? "sticky" : "";
            this.view.scrollDOM.appendChild(this.domAfter);
        }
        return this.domAfter;
    }
    update(update) {
        if (this.updateGutters(update)) {
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged) {
            let min = (this.view.contentHeight / this.view.scaleY) + "px";
            this.dom.style.minHeight = min;
            if (this.domAfter)
                this.domAfter.style.minHeight = min;
        }
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
            if (this.domAfter)
                this.domAfter.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach) {
            this.dom.remove();
            if (this.domAfter)
                this.domAfter.remove();
        }
        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
            if (classSet.length)
                classSet = [];
            if (Array.isArray(line.type)) {
                let first = true;
                for (let b of line.type) {
                    if (b.type == BlockType.Text && first) {
                        advanceCursor(lineClasses, classSet, b.from);
                        for (let cx of contexts)
                            cx.line(this.view, b, classSet);
                        first = false;
                    }
                    else if (b.widget) {
                        for (let cx of contexts)
                            cx.widget(this.view, b);
                    }
                }
            }
            else if (line.type == BlockType.Text) {
                advanceCursor(lineClasses, classSet, line.from);
                for (let cx of contexts)
                    cx.line(this.view, line, classSet);
            }
            else if (line.widget) {
                for (let cx of contexts)
                    cx.widget(this.view, line);
            }
        }
        for (let cx of contexts)
            cx.finish();
        if (detach) {
            this.view.scrollDOM.insertBefore(this.dom, after);
            if (this.domAfter)
                this.view.scrollDOM.appendChild(this.domAfter);
        }
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged ||
            !_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur) {
            for (let gutter of this.gutters)
                if (gutter.update(update))
                    change = true;
        }
        else {
            change = true;
            let gutters = [];
            for (let conf of cur) {
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters.push(new SingleGutterView(this.view, conf));
                }
                else {
                    this.gutters[known].update(update);
                    gutters.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters) {
                g.dom.remove();
                if (gutters.indexOf(g) < 0)
                    g.destroy();
            }
            for (let g of gutters) {
                if (g.config.side == "after")
                    this.getDOMAfter().appendChild(g.dom);
                else
                    this.dom.appendChild(g.dom);
            }
            this.gutters = gutters;
        }
        return change;
    }
    destroy() {
        for (let view of this.gutters)
            view.destroy();
        this.dom.remove();
        if (this.domAfter)
            this.domAfter.remove();
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
        let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;
        return view.textDirection == Direction.LTR
            ? { left: before, right: after }
            : { right: before, left: after };
    })
});
function asArray(val) { return (Array.isArray(val) ? val : [val]); }
function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
        if (cursor.from == pos)
            collect.push(cursor.value);
        cursor.next();
    }
}
class UpdateContext {
    constructor(gutter, viewport, height) {
        this.gutter = gutter;
        this.height = height;
        this.i = 0;
        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.iter(gutter.markers, viewport.from);
    }
    addElement(view, block, markers) {
        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
        if (this.i == gutter.elements.length) {
            let newElt = new GutterElement(view, height, above, markers);
            gutter.elements.push(newElt);
            gutter.dom.appendChild(newElt.dom);
        }
        else {
            gutter.elements[this.i].update(view, height, above, markers);
        }
        this.height = block.bottom;
        this.i++;
    }
    line(view, line, extraMarkers) {
        let localMarkers = [];
        advanceCursor(this.cursor, localMarkers, line.from);
        if (extraMarkers.length)
            localMarkers = localMarkers.concat(extraMarkers);
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
            localMarkers.unshift(forLine);
        let gutter = this.gutter;
        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
            return;
        this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
        for (let cls of view.state.facet(gutterWidgetClass)) {
            let marker = cls(view, block.widget, block);
            if (marker)
                (markers || (markers = [])).push(marker);
        }
        if (markers)
            this.addElement(view, block, markers);
    }
    finish() {
        let gutter = this.gutter;
        while (gutter.elements.length > this.i) {
            let last = gutter.elements.pop();
            gutter.dom.removeChild(last.dom);
            last.destroy();
        }
    }
}
class SingleGutterView {
    constructor(view, config) {
        this.view = view;
        this.config = config;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
                let target = event.target, y;
                if (target != this.dom && this.dom.contains(target)) {
                    while (target.parentNode != this.dom)
                        target = target.parentNode;
                    let rect = target.getBoundingClientRect();
                    y = (rect.top + rect.bottom) / 2;
                }
                else {
                    y = event.clientY;
                }
                let line = view.lineBlockAtHeight(y - view.documentTop);
                if (config.domEventHandlers[prop](view, line, event))
                    event.preventDefault();
            });
        }
        this.markers = asArray(config.markers(view));
        if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
                this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||
            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
        for (let elt of this.elements)
            elt.destroy();
    }
}
class GutterElement {
    constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height) {
            this.height = height;
            this.dom.style.height = height + "px";
        }
        if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0;;) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
                let c = marker.elementClass;
                if (c)
                    cls += " " + c;
                for (let i = iOld; i < this.markers.length; i++)
                    if (this.markers[i].compare(marker)) {
                        skipTo = i;
                        matched = true;
                        break;
                    }
            }
            else {
                skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
                let next = this.markers[iOld++];
                if (next.toDOM) {
                    next.destroy(domPos);
                    let after = domPos.nextSibling;
                    domPos.remove();
                    domPos = after;
                }
            }
            if (!marker)
                break;
            if (marker.toDOM) {
                if (matched)
                    domPos = domPos.nextSibling;
                else
                    this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
                iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
    }
    destroy() {
        this.setMarkers(null, []);
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].compare(b[i]))
            return false;
    return true;
}
const lineNumberMarkers = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const lineNumberWidgetMarker = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();
const lineNumberConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({
    combine(values) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
                let result = Object.assign({}, a);
                for (let event in b) {
                    let exists = result[event], add = b[event];
                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    constructor(number) {
        super();
        this.number = number;
    }
    eq(other) { return this.number == other.number; }
    toDOM() { return document.createTextNode(this.number); }
}
function formatNumber(view, number) {
    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = activeGutters.compute([lineNumberConfig], state => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) { return view.state.facet(lineNumberMarkers); },
    lineMarker(view, line, others) {
        if (others.some(m => m.toDOM))
            return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: (view, widget, block) => {
        for (let m of view.state.facet(lineNumberWidgetMarker)) {
            let result = m(view, widget, block);
            if (result)
                return result;
        }
        return null;
    },
    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
    side: "before"
}));
function lineNumbers(config = {}) {
    return [
        lineNumberConfig.of(config),
        gutters(),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
        last = last * 10 + 9;
    return last;
}
const activeLineGutterMarker = new class extends GutterMarker {
    constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
    }
};
const activeLineGutterHighlighter = gutterLineClass.compute(["selection"], state => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
        }
    }
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.of(marks);
});
function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
}
function matcher(decorator) {
    return ViewPlugin.define(view => ({
        decorations: decorator.createDeco(view),
        update(u) {
            this.decorations = decorator.updateDeco(u, this.decorations);
        },
    }), {
        decorations: v => v.decorations
    });
}
const tabDeco = Decoration.mark({ class: "cm-highlightTab" });
const spaceDeco = Decoration.mark({ class: "cm-highlightSpace" });
const whitespaceHighlighter = matcher(new MatchDecorator({
    regexp: /\t| /g,
    decoration: match => match[0] == "\t" ? tabDeco : spaceDeco,
    boundary: /\S/,
}));
function highlightWhitespace() {
    return whitespaceHighlighter;
}
const trailingHighlighter = matcher(new MatchDecorator({
    regexp: /\s+$/g,
    decoration: Decoration.mark({ class: "cm-trailingSpace" })
}));
function highlightTrailingWhitespace() {
    return trailingHighlighter;
}
const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder,
    moveVisually, clearHeightChangeFlag, getHeightChangeFlag: () => heightChangeFlag };



/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),
/* harmony export */   IterMode: () => (/* binding */ IterMode),
/* harmony export */   MountedTree: () => (/* binding */ MountedTree),
/* harmony export */   NodeProp: () => (/* binding */ NodeProp),
/* harmony export */   NodeSet: () => (/* binding */ NodeSet),
/* harmony export */   NodeType: () => (/* binding */ NodeType),
/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),
/* harmony export */   Parser: () => (/* binding */ Parser),
/* harmony export */   Tree: () => (/* binding */ Tree),
/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),
/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),
/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),
/* harmony export */   parseMixed: () => (/* binding */ parseMixed)
/* harmony export */ });
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
class NodeProp {
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: value => {
        if (value && value != "rtl" && value != "ltr" && value != "auto")
            throw new RangeError("Invalid value for isolate: " + value);
        return value || "auto";
    } });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
class MountedTree {
    constructor(tree, overlay, parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
    static get(tree) {
        return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
}
const noProps = Object.create(null);
class NodeType {
    constructor(name, props, id, flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) |
            (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    prop(prop) { return this.props[prop.id]; }
    get isTop() { return (this.flags & 1) > 0; }
    get isSkipped() { return (this.flags & 2) > 0; }
    get isError() { return (this.flags & 4) > 0; }
    get isAnonymous() { return (this.flags & 8) > 0; }
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
NodeType.none = new NodeType("", Object.create(null), 0, 8);
class NodeSet {
    constructor(types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
var IterMode;
(function (IterMode) {
    IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
class Tree {
    constructor(type, children, positions, length, props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    toString() {
        let mounted = MountedTree.get(this);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor = new TreeCursor(scope);
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
        return cursor;
    }
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    resolveStack(pos, side = 0) {
        return stackIterator(this, pos, side);
    }
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {
            let entered = false;
            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
                if (c.firstChild())
                    continue;
                entered = true;
            }
            for (;;) {
                if (entered && leave && (anon || !c.type.isAnonymous))
                    leave(c);
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                entered = true;
            }
        }
    }
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    balance(config = {}) {
        return this.children.length <= 8 ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    static build(data) { return buildTree(data); }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
class TreeBuffer {
    constructor(buffer, length, set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    get type() { return NodeType.none; }
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    slice(startI, endI, from) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI), len = 0;
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            let to = copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
            len = Math.max(len, to);
        }
        return new TreeBuffer(copy, len, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2: return from < pos;
        case -1: return to >= pos && from < pos;
        case 0: return from < pos && to > pos;
        case 1: return from <= pos && to > pos;
        case 2: return to > pos;
        case 4: return true;
    }
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, mode);
        if (!inner)
            return node;
        node = inner;
    }
}
class BaseNode {
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
        return matchNodeContext(this.parent, context);
    }
    enterUnfinishedNodesBefore(pos) {
        let scan = this.childBefore(pos), node = this;
        while (scan) {
            let last = scan.lastChild;
            if (!last || last.to != scan.to)
                break;
            if (last.type.isError && last.from == last.to) {
                node = scan;
                scan = last.prevSibling;
            }
            else {
                scan = last;
            }
        }
        return node;
    }
    get node() { return this; }
    get next() { return this.parent; }
}
class TreeNode extends BaseNode {
    constructor(_tree, from, index, _parent) {
        super();
        this._tree = _tree;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this._tree.type; }
    get name() { return this._tree.type.name; }
    get to() { return this.from + this._tree.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & IterMode.ExcludeBuffers)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4); }
    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2); }
    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2); }
    enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    get tree() { return this._tree; }
    toTree() { return this._tree; }
    toString() { return this._tree.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        for (let found = false; !found;) {
            found = cur.type.is(before);
            if (!cur.nextSibling())
                return result;
        }
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node; i >= 0; p = p.parent) {
        if (!p)
            return false;
        if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
                return false;
            i--;
        }
    }
    return true;
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode extends BaseNode {
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    constructor(context, _parent, index) {
        super();
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4); }
    get lastChild() { return this.child(-1, 0, 4); }
    childAfter(pos) { return this.child(1, pos, 2); }
    childBefore(pos) { return this.child(-1, pos, -2); }
    enter(pos, side, mode = 0) {
        if (mode & IterMode.ExcludeBuffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1];
            children.push(buffer.slice(startI, endI, from));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    toString() { return this.context.buffer.childString(this.index); }
}
function iterStack(heads) {
    if (!heads.length)
        return null;
    let pick = 0, picked = heads[0];
    for (let i = 1; i < heads.length; i++) {
        let node = heads[i];
        if (node.from > picked.from || node.to < picked.to) {
            picked = node;
            pick = i;
        }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
        newHeads[pick] = next;
    else
        newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
}
class StackIterator {
    constructor(heads, node) {
        this.heads = heads;
        this.node = node;
    }
    get next() { return iterStack(this.heads); }
}
function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
        if (scan.index < 0) {
            let parent = scan.parent;
            (layers || (layers = [inner])).push(parent.resolve(pos, side));
            scan = parent;
        }
        else {
            let mount = MountedTree.get(scan.tree);
            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
                (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
            }
        }
    }
    return layers ? iterStack(layers) : inner;
}
class TreeCursor {
    get name() { return this.type.name; }
    constructor(node, mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    firstChild() { return this.enterChild(1, 0, 4); }
    lastChild() { return this.enterChild(-1, 0, 4); }
    childAfter(pos) { return this.enterChild(1, pos, 2); }
    childBefore(pos) { return this.enterChild(-1, pos, -2); }
    enter(pos, side, mode = this.mode) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() { return this.sibling(1); }
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                    let child = parent._tree.children[i];
                    if ((this.mode & IterMode.IncludeAnonymous) ||
                        child instanceof TreeBuffer ||
                        !child.type.isAnonymous ||
                        hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    next(enter = true) { return this.move(1, enter); }
    prev(enter = true) { return this.move(-1, enter); }
    moveTo(pos, side = 0) {
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
        return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
        for (let depth = 0;;) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
                if (this.firstChild()) {
                    depth++;
                    continue;
                }
                if (!this.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(this);
                mustLeave = this.type.isAnonymous;
                if (!depth)
                    return;
                if (this.nextSibling())
                    break;
                this.parent();
                depth--;
                mustLeave = true;
            }
        }
    }
    matchContext(context) {
        if (!this.buffer)
            return matchNodeContext(this.node.parent, context);
        let { buffer } = this.buffer, { types } = buffer.set;
        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
            if (d < 0)
                return matchNodeContext(this._tree, context, i);
            let type = types[buffer.buffer[this.stack[d]]];
            if (!type.isAnonymous) {
                if (context[i] && context[i] != type.name)
                    return false;
                i--;
            }
        }
        return true;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
        while (size < 0) {
            cursor.next();
            if (size == -1) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3) {
                contextHash = id;
                return;
            }
            else if (size == -4) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else {
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else if (depth > 2500) {
                    takeFlatNode(start, endPos, localChildren, localPositions);
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type, contextAtStart);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children, positions) {
        let nodes = [];
        let nodeCount = 0, stopAt = -1;
        while (cursor.pos > minPos) {
            let { id, start, end, size } = cursor;
            if (size > 4) {
                cursor.next();
            }
            else if (stopAt > -1 && start < stopAt) {
                break;
            }
            else {
                if (stopAt < 0)
                    stopAt = end - maxBufferLength;
                nodes.push(id, start, end);
                nodeCount++;
                cursor.next();
            }
        }
        if (nodeCount) {
            let buffer = new Uint16Array(nodeCount * 4);
            let start = nodes[nodes.length - 2];
            for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
                buffer[j++] = nodes[i];
                buffer[j++] = nodes[i + 1] - start;
                buffer[j++] = nodes[i + 2] - start;
                buffer[j++] = j;
            }
            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));
            positions.push(start - parentStart);
        }
    }
    function makeBalanced(type, contextHash) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead, contextHash);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            if (fork.id == inRepeat && nodeSize >= 0) {
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3) {
            contextHash = id;
        }
        else if (size == -4) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom];
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}
class NodeWeakMap {
    constructor() {
        this.map = new WeakMap();
    }
    setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer);
        if (!inner)
            this.map.set(buffer, inner = new Map);
        inner.set(index, value);
    }
    getBuffer(buffer, index) {
        let inner = this.map.get(buffer);
        return inner && inner.get(index);
    }
    set(node, value) {
        if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
        else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
    }
    get(node) {
        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)
            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
    }
    cursorSet(cursor, value) {
        if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
        else
            this.map.set(cursor.tree, value);
    }
    cursorGet(cursor) {
        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
}
class TreeFragment {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() { return (this.open & 1) > 0; }
    get openEnd() { return (this.open & 2) > 0; }
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
class Parser {
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, from) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.from = from;
    }
}
function checkRanges(ranges) {
    if (!ranges.length || ranges.some(r => r.from >= r.to))
        throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
        scan: for (let nest, isCovered;;) {
            let enter = true, range;
            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {
                enter = false;
            }
            else if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2;
            }
            else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) &&
                (cursor.from < cursor.to || !nest.overlay)) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay ||
                        (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));
                    if (ranges.length)
                        checkRanges(ranges);
                    if (ranges.length || !nest.overlay)
                        this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)
                            : nest.parser.startParse(""), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to) {
                    let last = overlay.ranges.length - 1;
                    if (last >= 0 && overlay.ranges[last].to == range.from)
                        overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to };
                    else
                        overlay.ranges.push(range);
                }
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length) {
                            checkRanges(ranges);
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));
                        }
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 : 1;
    }
    return 0;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1];
        nodes.push(buf.slice(startI, endI, from));
        positions.push(from - off);
    }
}
function materialize(cursor) {
    let { node } = cursor, stack = [];
    let buffer = node.context.buffer;
    do {
        stack.push(cursor.index);
        cursor.parent();
    } while (!cursor.tree);
    let base = cursor.tree, i = base.children.indexOf(buffer);
    let buf = base.children[i], b = buf.buffer, newStack = [i];
    function split(startI, endI, type, innerOffset, length, stackPos) {
        let targetI = stack[stackPos];
        let children = [], positions = [];
        sliceBuf(buf, startI, targetI, children, positions, innerOffset);
        let from = b[targetI + 1], to = b[targetI + 2];
        newStack.push(children.length);
        let child = stackPos
            ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)
            : node.toTree();
        children.push(child);
        positions.push(from - innerOffset);
        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);
    for (let index of newStack) {
        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];
        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));
    }
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers))
                ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
        }
    }
    return result;
}



/***/ }),

/***/ "./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tag: () => (/* binding */ Tag),
/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),
/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),
/* harmony export */   highlightCode: () => (/* binding */ highlightCode),
/* harmony export */   highlightTree: () => (/* binding */ highlightTree),
/* harmony export */   styleTags: () => (/* binding */ styleTags),
/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),
/* harmony export */   tags: () => (/* binding */ tags)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.js");

let nextTagID = 0;
class Tag {
    constructor(name, set, base, modified) {
        this.name = name;
        this.set = set;
        this.base = base;
        this.modified = modified;
        this.id = nextTagID++;
    }
    toString() {
        let { name } = this;
        for (let mod of this.modified)
            if (mod.name)
                name = `${mod.name}(${name})`;
        return name;
    }
    static define(nameOrParent, parent) {
        let name = typeof nameOrParent == "string" ? nameOrParent : "?";
        if (nameOrParent instanceof Tag)
            parent = nameOrParent;
        if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
        let tag = new Tag(name, [], null, []);
        tag.set.push(tag);
        if (parent)
            for (let t of parent.set)
                tag.set.push(t);
        return tag;
    }
    static defineModifier(name) {
        let mod = new Modifier(name);
        return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
                return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    constructor(name) {
        this.name = name;
        this.instances = [];
        this.id = nextModifierID++;
    }
    static get(base, mods) {
        if (!mods.length)
            return base;
        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
        if (exists)
            return exists;
        let set = [], tag = new Tag(base.name, set, base, mods);
        for (let m of mods)
            m.instances.push(tag);
        let configs = powerSet(mods);
        for (let parent of base.set)
            if (!parent.modified.length)
                for (let config of configs)
                    set.push(Modifier.get(parent, config));
        return tag;
    }
}
function sameArray(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
        for (let j = 0, e = sets.length; j < e; j++) {
            sets.push(sets[j].concat(array[i]));
        }
    }
    return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
        let tags = spec[prop];
        if (!Array.isArray(tags))
            tags = [tags];
        for (let part of prop.split(" "))
            if (part) {
                let pieces = [], mode = 2, rest = part;
                for (let pos = 0;;) {
                    if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                        mode = 1;
                        break;
                    }
                    let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                    if (!m)
                        throw new RangeError("Invalid path: " + part);
                    pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                    pos += m[0].length;
                    if (pos == part.length)
                        break;
                    let next = part[pos++];
                    if (pos == part.length && next == "!") {
                        mode = 0;
                        break;
                    }
                    if (next != "/")
                        throw new RangeError("Invalid path: " + part);
                    rest = part.slice(pos);
                }
                let last = pieces.length - 1, inner = pieces[last];
                if (!inner)
                    throw new RangeError("Invalid path: " + part);
                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                byName[inner] = rule.sort(byName[inner]);
            }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();
class Rule {
    constructor(tags, mode, context, next) {
        this.tags = tags;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    get opaque() { return this.mode == 0; }
    get inherit() { return this.mode == 1; }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() { return this.context ? this.context.length : 0; }
}
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags, options) {
    let map = Object.create(null);
    for (let style of tags) {
        if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
        else
            for (let tag of style.tag)
                map[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
        style: (tags) => {
            let cls = all;
            for (let tag of tags) {
                for (let sub of tag.set) {
                    let tagClass = map[sub.id];
                    if (tagClass) {
                        cls = cls ? cls + " " + tagClass : tagClass;
                        break;
                    }
                }
            }
            return cls;
        },
        scope
    };
}
function highlightTags(highlighters, tags) {
    let result = null;
    for (let highlighter of highlighters) {
        let value = highlighter.style(tags);
        if (value)
            result = result ? result + " " + value : value;
    }
    return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
}
function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {
    let pos = from;
    function writeTo(p, classes) {
        if (p <= pos)
            return;
        for (let text = code.slice(pos, p), i = 0;;) {
            let nextBreak = text.indexOf("\n", i);
            let upto = nextBreak < 0 ? text.length : nextBreak;
            if (upto > i)
                putText(text.slice(i, upto), classes);
            if (nextBreak < 0)
                break;
            putBreak();
            i = nextBreak + 1;
        }
        pos = p;
    }
    highlightTree(tree, highlighter, (from, to, classes) => {
        writeTo(from, "");
        writeTo(to, classes);
    }, from, to);
    writeTo(to, "");
}
class HighlightBuilder {
    constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
    }
    startSpan(at, cls) {
        if (cls != this.class) {
            this.flush(at);
            if (at > this.at)
                this.at = at;
            this.class = cls;
        }
    }
    flush(to) {
        if (to > this.at && this.class)
            this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor;
        if (start >= to || end <= from)
            return;
        if (type.isTop)
            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = getStyleTags(cursor) || Rule.empty;
        let tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
            if (cls)
                cls += " ";
            cls += tagCls;
            if (rule.mode == 1)
                inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(Math.max(from, start), cls);
        if (rule.opaque)
            return;
        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);
        if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start;; i++) {
                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                let nextPos = next ? next.from + start : end;
                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                if (rangeFrom < rangeTo && hasChild) {
                    while (cursor.from < rangeTo) {
                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                        this.startSpan(Math.min(rangeTo, cursor.to), cls);
                        if (cursor.to >= nextPos || !cursor.nextSibling())
                            break;
                    }
                }
                if (!next || nextPos > to)
                    break;
                pos = next.to + start;
                if (pos > from) {
                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
                    this.startSpan(Math.min(to, pos), cls);
                }
            }
            if (hasChild)
                cursor.parent();
        }
        else if (cursor.firstChild()) {
            if (mounted)
                inheritedClass = "";
            do {
                if (cursor.to <= from)
                    continue;
                if (cursor.from >= to)
                    break;
                this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                this.startSpan(Math.min(to, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
        }
    }
}
function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
        rule = rule.next;
    return rule || null;
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
const tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName: typeName,
    tagName: t(typeName),
    propertyName: propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier("definition"),
    constant: Tag.defineModifier("constant"),
    function: Tag.defineModifier("function"),
    standard: Tag.defineModifier("standard"),
    local: Tag.defineModifier("local"),
    special: Tag.defineModifier("special")
};
for (let name in tags) {
    let val = tags[name];
    if (val instanceof Tag)
        val.name = name;
}
const classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
]);



/***/ }),

/***/ "./node_modules/@liqvid/keymap/dist/esm/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@liqvid/keymap/dist/esm/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Keymap: () => (/* binding */ Keymap)
/* harmony export */ });
/* harmony import */ var _mixedCaseVals_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mixedCaseVals.mjs */ "./node_modules/@liqvid/keymap/dist/esm/mixedCaseVals.mjs");

const modifierMap = {
    Control: "Ctrl",
    Alt: "Alt",
    Shift: "Shift",
    Meta: "Meta",
};
const mixedCase = {};
for (const key of _mixedCaseVals_mjs__WEBPACK_IMPORTED_MODULE_0__.mixedCaseVals) {
    mixedCase[key.toLowerCase()] = key;
}
const modifierOrder = Object.keys(modifierMap).map((k) => modifierMap[k]);
const useCode = ["Backspace", "Enter", "Space", "Tab"];
/** Maps keyboard shortcuts to actions */
class Keymap {
    constructor() {
        this.__bindings = {};
    }
    /** Given a KeyboardEvent, returns a shortcut sequence matching that event. */
    static identify(e) {
        const parts = [];
        for (const modifier in modifierMap) {
            if (e.getModifierState(modifier)) {
                parts.push(modifierMap[modifier]);
            }
        }
        if (e.key in modifierMap) {
        }
        else if (e.code.startsWith("Digit")) {
            parts.push(e.code.slice(5));
        }
        else if (e.code.startsWith("Key")) {
            parts.push(e.code.slice(3));
        }
        else if (useCode.includes(e.code)) {
            parts.push(e.code);
        }
        else {
            parts.push(e.key);
        }
        return parts.join("+");
    }
    /** Returns a canonical form of the shortcut sequence. */
    static normalize(seq) {
        return seq
            .split("+")
            .map((str) => {
            const lower = str.toLowerCase();
            if (str === "")
                return "";
            if (mixedCase[lower]) {
                return mixedCase[lower];
            }
            return str[0].toUpperCase() + lower.slice(1);
        })
            .sort((a, b) => {
            if (modifierOrder.includes(a)) {
                if (modifierOrder.includes(b)) {
                    return modifierOrder.indexOf(a) - modifierOrder.indexOf(b);
                }
                else {
                    return -1;
                }
            }
            else if (modifierOrder.includes(b)) {
                return 1;
            }
            else {
                return cmp(a, b);
            }
        })
            .join("+");
    }
    /**
     * Bind a handler to be called when the shortcut sequence is pressed.
     * @param seq Shortcut sequence
     * @param cb Callback function
     */
    bind(seq, cb) {
        if (seq.indexOf(",") > -1) {
            for (const atomic of seq.split(",")) {
                this.bind(atomic, cb);
            }
            return;
        }
        seq = Keymap.normalize(seq);
        if (!this.__bindings.hasOwnProperty(seq)) {
            this.__bindings[seq] = [];
        }
        this.__bindings[seq].push(cb);
    }
    /**
     * Unbind a handler from a shortcut sequence.
     * @param seq Shortcut sequence
     * @param cb Handler to unbind
     */
    unbind(seq, cb) {
        if (seq.indexOf(",") > -1) {
            for (const atomic of seq.split(",")) {
                this.unbind(atomic, cb);
            }
            return;
        }
        seq = Keymap.normalize(seq);
        if (!this.__bindings.hasOwnProperty(seq)) {
            return;
        }
        const index = this.__bindings[seq].indexOf(cb);
        if (index < 0) {
            return;
        }
        this.__bindings[seq].splice(index, 1);
        if (this.__bindings[seq].length === 0) {
            delete this.__bindings[seq];
        }
    }
    /** Return all shortcut sequences with handlers bound to them. */
    getKeys() {
        return Object.keys(this.__bindings);
    }
    /** Get the list of handlers for a given shortcut sequence. */
    getHandlers(seq) {
        if (!this.__bindings.hasOwnProperty(seq))
            return [];
        return this.__bindings[seq].slice();
    }
    /** Dispatches all handlers matching the given event. */
    handle(e) {
        const seq = Keymap.identify(e);
        if (!this.__bindings[seq] && !this.__bindings["*"])
            return;
        if (this.__bindings[seq]) {
            e.preventDefault();
            for (const cb of this.__bindings[seq]) {
                cb(e);
            }
        }
        if (this.__bindings["*"]) {
            for (const cb of this.__bindings["*"]) {
                cb(e);
            }
        }
    }
}
/**
 * Returns -1 if a < b, 0 if a === b, and 1 if a > b.
 */
function cmp(a, b) {
    if (a < b)
        return -1;
    else if (a === b)
        return 0;
    return 1;
}


/***/ }),

/***/ "./node_modules/@liqvid/keymap/dist/esm/mixedCaseVals.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liqvid/keymap/dist/esm/mixedCaseVals.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mixedCaseVals: () => (/* binding */ mixedCaseVals)
/* harmony export */ });
const mixedCaseVals = [
    "AltGraph",
    "CapsLock",
    "FnLock",
    "NumLock",
    "ScrollLock",
    "SymbolLock",
    "ArrowDown",
    "ArrowLeft",
    "ArrowRight",
    "ArrowUp",
    "PageDown",
    "PageUp",
    "CrSel",
    "EraseEof",
    "ExSel",
    "ContextMenu",
    "ZoomIn",
    "ZoomOut",
    "BrightnessDown",
    "BrightnessUp",
    "LogOff",
    "PowerOff",
    "PrintScreen",
    "WakeUp",
    "AllCandidates",
    "CodeInput",
    "FinalMode",
    "GroupFirst",
    "GroupLast",
    "GroupNext",
    "GroupPrevious",
    "ModeChange",
    "NextCandidate",
    "NonConvert",
    "PreviousCandidate",
    "SingleCandidate",
    "HangulMode",
    "HanjaMode",
    "JunjaMode",
    "HiraganaKatakana",
    "KanaMode",
    "KanjiMode",
    "ZenkakuHanaku",
    "AppSwitch",
    "CameraFocus",
    "EndCall",
    "GoBack",
    "GoHome",
    "HeadsetHook",
    "LastNumberRedial",
    "MannerMode",
    "VoiceDial",
    "ChannelDown",
    "ChannelUp",
    "MediaFastForward",
    "MediaPause",
    "MediaPlay",
    "MediaPlayPause",
    "MediaRecord",
    "MediaRewind",
    "MediaStop",
    "MediaTrackNext",
    "MediaTrackPrevious",
    "AudioBalanceLeft",
    "AudioBalanceRight",
    "AudioBassDown",
    "AudioBassBoostDown",
    "AudioBassBoostToggle",
    "AudioBassBoostUp",
    "AudioBassUp",
    "AudioFaderFront",
    "AudioFaderRear",
    "AudioSurroundModeNext",
    "AudioTrebleDown",
    "AudioTrebleUp",
    "AudioVolumeDown",
    "AudioVolumeMute",
    "AudioVolumeUp",
    "MicrophoneToggle",
    "MicrophoneVolumeDown",
    "MicrophoneVolumeMute",
    "MicrophoneVolumeUp",
    "TV",
    "TVAntennaCable",
    "TVAudioDescription",
    "TVAudioDescriptionMixDown",
    "TVAudioDescriptionMixUp",
    "TVContentsMenu",
    "TVDataService",
    "TVInput",
    "TVMediaContext",
    "TVNetwork",
    "TVNumberEntry",
    "TVPower",
    "TVRadioService",
    "TVSatellite",
    "TVSatelliteBS",
    "TVSatelliteCS",
    "TVSatelliteToggle",
    "TVTerrestrialAnalog",
    "TVTerrestrialDigital",
    "TVTimer",
    "AVRInput",
    "AVRPower",
    "ClosedCaptionToggle",
    "DisplaySwap",
    "DVR",
    "GuideNextDay",
    "GuidePreviousDay",
    "InstantReplay",
    "ListProgram",
    "LiveContent",
    "MediaApps",
    "MediaAudioTrack",
    "MediaLast",
    "MediaSkipBackward",
    "MediaSkipForward",
    "MediaStepBackward",
    "MediaStepForward",
    "MediaTopMenu",
    "NavigateIn",
    "NavigateNext",
    "NavigateOut",
    "NavigatePrevious",
    "NextFavoriteChannel",
    "NextUserProfile",
    "OnDemand",
    "PinPDown",
    "PinPMove",
    "PinPToggle",
    "PinPUp",
    "PlaySpeedDown",
    "PlaySpeedReset",
    "PlaySpeedUp",
    "RandomToggle",
    "RcLowBattery",
    "RecordSpeedNext",
    "RfBypass",
    "ScanChannelsToggle",
    "ScreenModeNext",
    "SplitScreenToggle",
    "STBInput",
    "STBPower",
    "VideoModeNext",
    "ZoomToggle",
    "SpeechCorrectionList",
    "SpeechInputToggle",
    "SpellCheck",
    "MailForward",
    "MailReply",
    "MailSend",
    "LaunchCalculator",
    "LaunchCalendar",
    "LaunchContacts",
    "LaunchMail",
    "LaunchMediaPlayer",
    "LaunchMusicPlayer",
    "LaunchMyComputer",
    "LaunchPhone",
    "LaunchScreenSaver",
    "LaunchSpreadsheet",
    "LaunchWebBrowser",
    "LaunchWebCam",
    "LaunchWordProcessor",
    "BrowserBack",
    "BrowserFavorites",
    "BrowserForward",
    "BrowserHome",
    "BrowserRefresh",
    "BrowserSearch",
    "BrowserStop",
];


/***/ }),

/***/ "./node_modules/@liqvid/keymap/dist/esm/react.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@liqvid/keymap/dist/esm/react.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeymapContext: () => (/* binding */ KeymapContext),
/* harmony export */   useKeyboardShortcut: () => (/* binding */ useKeyboardShortcut),
/* harmony export */   useKeymap: () => (/* binding */ useKeymap)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
"use client";

const symbol = Symbol.for("@lqv/keymap");
if (!(symbol in globalThis)) {
    globalThis[symbol] = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
}
/**
 * {@link React.Context} used to access ambient Keymap
 */
const KeymapContext = globalThis[symbol];
KeymapContext.displayName = "Keymap";
/** Access the ambient {@link Keymap} */
function useKeymap() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(KeymapContext);
}
/** Register a keyboard shortcut for the duration of the component. */
function useKeyboardShortcut(
/** Keyboard sequence to bind to */
seq, 
/** Callback to handle the shortcut */
callback) {
    const keymap = useKeymap();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        keymap.bind(seq, callback);
        return () => keymap.unbind(seq, callback);
    }, [callback, keymap, seq]);
}


/***/ }),

/***/ "./node_modules/@liqvid/playback/dist/esm/animation.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@liqvid/playback/dist/esm/animation.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Playback: () => (/* binding */ Playback)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_ssr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/utils/ssr */ "./node_modules/@liqvid/utils/dist/esm/ssr.mjs");
/* harmony import */ var _core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.mjs */ "./node_modules/@liqvid/playback/dist/esm/core.mjs");


/** Extended {@link CorePlayback Playback} supporting the Web Animation API */
class Playback extends _core_mjs__WEBPACK_IMPORTED_MODULE_0__.Playback {
    constructor(options) {
        super(options);
        this.__animations = [];
        this.__delays = new WeakMap();
        if (_liqvid_utils_ssr__WEBPACK_IMPORTED_MODULE_1__.isClient) {
            this.__createTimeline();
        }
    }
    /**
     * Create an {@link Animation} (factory) synced to this playback
     * @param keyframes A [keyframes object](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats) or `null`
     * @param options Either an integer representing the animation's duration (in milliseconds), or {@link KeyframeEffectOptions}
     * @returns A callback to attach the animation to a target
     */
    newAnimation(keyframes, options) {
        let anim;
        return (target) => {
            if (target === null) {
                anim.cancel();
                anim = undefined;
                return;
            }
            else if (anim !== undefined) {
                console.warn("Animations should not be reused as they will not cancel properly. Check animations attached to ", target);
            }
            // create animation
            anim = new Animation(new KeyframeEffect(target, keyframes, options), this.timeline);
            if (typeof options === "object" &&
                (options.fill === "forwards" || options.fill === "both")) {
                anim.persist();
            }
            /* adopt animation */
            const delay = anim.effect.getTiming().delay;
            this.__delays.set(anim.effect, delay);
            anim.currentTime = (this.currentTime - delay) / this.playbackRate;
            anim.startTime = null;
            anim.pause();
            if (delay !== 0) {
                anim.effect.updateTiming({ delay: 0.1 });
            }
            this.__animations.push(anim);
            anim.addEventListener("cancel", () => {
                this.__animations.splice(this.__animations.indexOf(anim), 1);
            });
            // return
            return anim;
        };
    }
    /**
     * Create our timeline
     *
     * @listens pause
     * @listens play
     * @listens ratechange
     * @listens seek
     */
    __createTimeline() {
        // don't crash old browsers when not polyfilled
        if (typeof window.DocumentTimeline === "undefined") {
            return;
        }
        this.timeline = new DocumentTimeline();
        // pause
        this.on("pause", () => {
            for (const anim of this.__animations) {
                anim.pause();
            }
        });
        // play
        this.on("play", () => {
            for (const anim of this.__animations) {
                anim.startTime = null;
                anim.play();
                anim.startTime =
                    this.timeline.currentTime +
                        (this.__delays.get(anim.effect) - this.currentTime) /
                            this.playbackRate;
            }
        });
        // ratechange
        this.on("ratechange", () => {
            for (const anim of this.__animations) {
                anim.playbackRate = this.playbackRate;
            }
        });
        // seek
        this.on("seek", () => {
            for (const anim of this.__animations) {
                const offset = (this.__delays.get(anim.effect) - this.currentTime) /
                    this.playbackRate;
                if (this.paused) {
                    // anim.startTime = this.timeline.currentTime + offset
                    anim.currentTime = -offset;
                    anim.pause();
                }
                else {
                    anim.startTime = this.timeline.currentTime + offset;
                }
            }
        });
    }
}


/***/ }),

/***/ "./node_modules/@liqvid/playback/dist/esm/core.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@liqvid/playback/dist/esm/core.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Playback: () => (/* binding */ Playback)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _liqvid_utils_ssr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/ssr */ "./node_modules/@liqvid/utils/dist/esm/ssr.mjs");



/**
 * Class pretending to be a media element advancing in time.
 *
 * Imitates {@link HTMLMediaElement} to a certain extent, although it does not implement that interface.
 */
class Playback extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(options) {
        super();
        /**
          The current playback time in milliseconds.
          
          **Warning:** {@link HTMLMediaElement.currentTime} measures this property in *seconds*.
        */
        this.currentTime = 0;
        /** Flag indicating whether playback is currently paused. */
        this.paused = true;
        /* private fields exposed by getters */
        this.__captions = [];
        this.__playbackRate = 1;
        this.__muted = false;
        this.__seeking = false;
        this.__volume = 1;
        this.duration = options.duration;
        this.__playingFrom = 0;
        this.__startTime = performance.now();
        // we will have lots of listeners, turn off warning
        this.setMaxListeners(0);
        // bind methods
        (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_1__.bind)(this, ["pause", "play"]);
        this.__advance = this.__advance.bind(this);
        // browser-only
        if (_liqvid_utils_ssr__WEBPACK_IMPORTED_MODULE_2__.isClient) {
            // audio
            this.__initAudio();
            // initiate playback loop
            requestAnimationFrame(this.__advance);
        }
    }
    /* magic properties */
    /** Gets or sets the current captions */
    get captions() {
        return this.__captions;
    }
    /** @emits cuechange */
    set captions(captions) {
        this.__captions = captions;
        this.emit("cuechange");
    }
    /**
     * Length of the playback in milliseconds.
     *
     * **Warning:** {@link HTMLMediaElement.duration} measures this in *seconds*.
     */
    get duration() {
        return this.__duration;
    }
    /** @emits durationchange */
    set duration(duration) {
        if (duration === this.__duration)
            return;
        this.__duration = duration;
        this.emit("durationchange");
    }
    /** Gets or sets a flag that indicates whether playback is muted. */
    get muted() {
        return this.__muted;
    }
    /** @emits volumechange */
    set muted(val) {
        if (val === this.__muted)
            return;
        this.__muted = val;
        if (this.audioNode) {
            if (this.__muted) {
                this.audioNode.gain.value = 0;
            }
            else {
                this.audioNode.gain.setValueAtTime(this.volume, this.audioContext.currentTime);
            }
        }
        this.emit("volumechange");
    }
    /** Gets or sets the current rate of speed for the playback. */
    get playbackRate() {
        return this.__playbackRate;
    }
    /** @emits ratechange */
    set playbackRate(val) {
        if (val === this.__playbackRate)
            return;
        this.__playbackRate = val;
        this.__playingFrom = this.currentTime;
        this.__startTime = performance.now();
        this.emit("ratechange");
    }
    /** Gets or sets a flag that indicates whether the playback is currently moving to a new position. */
    get seeking() {
        return this.__seeking;
    }
    /**
     * @emits seeking
     * @emits seeked
     */
    set seeking(val) {
        if (val === this.__seeking)
            return;
        this.__seeking = val;
        if (this.__seeking)
            this.emit("seeking");
        else
            this.emit("seeked");
    }
    /**
     * Pause playback.
     *
     * @emits pause
     */
    pause() {
        this.paused = true;
        this.__playingFrom = this.currentTime;
        this.emit("pause");
    }
    /**
     * Start or resume playback.
     *
     * @emits play
     */
    play() {
        this.paused = false;
        // this is necessary for currentTime to be correct when playing from stop state
        this.currentTime = this.__playingFrom;
        this.__startTime = performance.now();
        this.emit("play");
    }
    /**
     * Seek playback to a specific time.
     *
     * @emits seek
     */
    seek(t) {
        t = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_1__.constrain)(0, t, this.duration);
        this.currentTime = this.__playingFrom = t;
        this.__startTime = performance.now();
        this.emit("seek", t);
        if (this.currentTime >= this.duration) {
            this.stop();
        }
    }
    /** Gets or sets the volume level for the playback. */
    get volume() {
        return this.__volume;
    }
    /** @emits volumechange */
    set volume(volume) {
        this.muted = false;
        const prevVolume = this.__volume;
        this.__volume = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_1__.constrain)(0, volume, 1);
        if (this.audioNode) {
            if (prevVolume === 0 || this.__volume === 0) {
                this.audioNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            }
            else {
                this.audioNode.gain.exponentialRampToValueAtTime(this.__volume, this.audioContext.currentTime + 2);
            }
        }
        this.emit("volumechange");
    }
    /**
     * Stop playback and reset pointer to start
     *
     * @emits stop
     */
    stop() {
        this.paused = true;
        this.__playingFrom = 0;
        this.emit("stop");
    }
    /* private methods */
    /**
     * @emits timeupdate
     */
    __advance(t) {
        // paused
        if (this.paused || this.__seeking) {
            this.__startTime = t;
        }
        else {
            // playing
            this.currentTime =
                this.__playingFrom +
                    Math.max((t - this.__startTime) * this.__playbackRate, 0);
            if (this.currentTime >= this.duration) {
                this.currentTime = this.duration;
                this.stop();
            }
            this.emit("timeupdate", this.currentTime);
        }
        requestAnimationFrame(this.__advance);
    }
    /**
     * Try to initiate audio
     *
     * @listens click
     * @listens keydown
     * @listens touchstart
     */
    __initAudio() {
        const requestAudioContext = () => {
            try {
                this.audioContext = new (window.AudioContext || webkitAudioContext)();
                this.audioNode = this.audioContext.createGain();
                this.audioNode.connect(this.audioContext.destination);
                window.removeEventListener("click", requestAudioContext);
                window.removeEventListener("keydown", requestAudioContext);
                window.removeEventListener("touchstart", requestAudioContext);
            }
            catch (e) {
                // console.log("Failed to create audio context");
            }
        };
        window.addEventListener("click", requestAudioContext);
        window.addEventListener("keydown", requestAudioContext);
        window.addEventListener("touchstart", requestAudioContext);
    }
}


/***/ }),

/***/ "./node_modules/@liqvid/playback/dist/esm/react.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@liqvid/playback/dist/esm/react.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlaybackContext: () => (/* binding */ PlaybackContext),
/* harmony export */   usePlayback: () => (/* binding */ usePlayback),
/* harmony export */   useTime: () => (/* binding */ useTime)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");

const symbol = Symbol.for("@lqv/playback");
if (!(symbol in globalThis)) {
    globalThis[symbol] = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
}
/**
 * {@link React.Context} used to access ambient {@link Playback}
 */
const PlaybackContext = globalThis[symbol];
/** Access the ambient {@link Playback} */
function usePlayback() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PlaybackContext);
}
function useTime(callback, transform, deps) {
    const playback = usePlayback();
    const prev = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        const listener = typeof transform === "function"
            ? (t) => {
                const value = transform(t);
                if (value !== prev.current)
                    callback(value);
                prev.current = value;
            }
            : (t) => {
                if (t !== prev.current)
                    callback(t);
                prev.current = t;
            };
        // subscriptions
        playback.on("seek", listener);
        playback.on("timeupdate", listener);
        // initial call
        listener(playback.currentTime);
        // unsubscriptions
        return () => {
            playback.off("seek", listener);
            playback.off("timeupdate", listener);
        };
    }, typeof transform === "function" ? deps : transform);
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/animation.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/animation.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   animate: () => (/* binding */ animate),
/* harmony export */   bezier: () => (/* binding */ bezier),
/* harmony export */   easings: () => (/* binding */ easings),
/* harmony export */   replay: () => (/* binding */ replay)
/* harmony export */ });
/* harmony import */ var bezier_easing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bezier-easing */ "./node_modules/bezier-easing/src/index.js");
/* harmony import */ var _misc_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.mjs */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");


/**
 * Returns a function that takes in a time and returns a numeric value.
 * The function will return `startValue` whenever t is less than `startTime`, and similarly
 * will return `endValue` whenever t is greater than `startTime + duration`.
 *
 * You can use any time unit (seconds, milliseconds, days, …), as long as you
 * are consistent: `startTime`, `duration`, and the time parameter `t` must all
 * use the same units.
 *
 * If an array is passed, the functions are combined.
 */
function animate(options) {
    if (options instanceof Array) {
        options.sort((a, b) => a.startTime - b.startTime);
        const fns = options.map(animate);
        return (t) => {
            let i = 0;
            for (; i < fns.length; ++i) {
                if (options[i].startTime > t) {
                    if (i === 0)
                        return options[0].startValue;
                    return fns[i - 1](t);
                }
            }
            return fns[options.length - 1](t);
        };
    }
    if (!("startValue" in options))
        options.startValue = 0;
    if (!("endValue" in options))
        options.endValue = 1;
    if (!("easing" in options))
        options.easing = (x) => x;
    const { startValue, endValue, startTime, duration, easing } = options;
    return (t) => (0,_misc_mjs__WEBPACK_IMPORTED_MODULE_1__.lerp)(startValue, endValue, easing((0,_misc_mjs__WEBPACK_IMPORTED_MODULE_1__.clamp)(0, (t - startTime) / duration, 1)));
}
/** Cubic Bezier curve function */
const bezier = bezier_easing__WEBPACK_IMPORTED_MODULE_0__;
/** Parameters for common Bezier curves. */
const easings = {
    easeInSine: [0.47, 0, 0.745, 0.715],
    easeOutSine: [0.39, 0.575, 0.565, 1],
    easeInOutSine: [0.445, 0.05, 0.55, 0.95],
    easeInQuad: [0.55, 0.085, 0.68, 0.53],
    easeOutQuad: [0.25, 0.46, 0.45, 0.94],
    easeInOutQuad: [0.455, 0.03, 0.515, 0.955],
    easeInCubic: [0.55, 0.055, 0.675, 0.19],
    easeOutCubic: [0.215, 0.61, 0.355, 1],
    easeInOutCubic: [0.645, 0.045, 0.355, 1],
    easeInQuart: [0.895, 0.03, 0.685, 0.22],
    easeOutQuart: [0.165, 0.84, 0.44, 1],
    easeInOutQuart: [0.77, 0, 0.175, 1],
    easeInQuint: [0.755, 0.05, 0.855, 0.06],
    easeOutQuint: [0.23, 1, 0.32, 1],
    easeInOutQuint: [0.86, 0, 0.07, 1],
    easeInExpo: [0.95, 0.05, 0.795, 0.035],
    easeOutExpo: [0.19, 1, 0.22, 1],
    easeInOutExpo: [1, 0, 0, 1],
    easeInCirc: [0.6, 0.04, 0.98, 0.335],
    easeOutCirc: [0.075, 0.82, 0.165, 1],
    easeInOutCirc: [0.785, 0.135, 0.15, 0.86],
    easeInBack: [0.6, -0.28, 0.735, 0.045],
    easeOutBack: [0.175, 0.885, 0.32, 1.275],
    easeInOutBack: [0.68, -0.55, 0.265, 1.55],
};
/**
 * Returns a function that takes in a time (in milliseconds) and returns the "active" replay datum. Useful for writing replay plugins.
 */
function replay({ data, start, end, active, inactive, compressed, units = 1, }) {
    if (typeof compressed === "undefined")
        compressed = false;
    if (typeof start === "undefined")
        start = 0;
    const times = data.map(compressed ? (d) => d[0] / units : (d) => d[0]);
    if (compressed) {
        for (let i = 1; i < times.length; ++i) {
            times[i] += times[i - 1];
        }
    }
    if (typeof end === "undefined")
        end = start + times[times.length - 1];
    let lastTime = 0, i = 0, isActive = true;
    function listener(t) {
        // don't call inactive() repeatedly
        if (t < start || t >= end) {
            if (isActive) {
                isActive = false;
                return inactive();
            }
            return;
        }
        isActive = true;
        if (t < lastTime)
            i = 0;
        lastTime = t;
        let maxI = Math.min(i, times.length - 1);
        for (; i < times.length; i++) {
            if (start + times[i] < t)
                maxI = i;
            else
                break;
        }
        const [, current] = data[maxI];
        active(current, maxI);
    }
    return listener;
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/interaction.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/interaction.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anyHover: () => (/* binding */ anyHover),
/* harmony export */   onClick: () => (/* binding */ onClick),
/* harmony export */   onDrag: () => (/* binding */ onDrag)
/* harmony export */ });
/**
  Whether any available input mechanism can hover over elements. This is used as a standin for desktop/mobile.
*/
const anyHover = typeof window !== "undefined"
    ? window.matchMedia?.("(any-hover: hover)")?.matches
    : undefined;
/**
 * Helper for implementing drag functionality, abstracting over mouse vs touch events.
 * @returns An event listener which should be added to both `mousedown` and `touchstart` events.
 */
function onDrag(
/** Callback for dragging (pointer is moved while down). */
move, 
/** Callback for when dragging begins (pointer is touched). */
down = () => { }, 
/** Callback for when dragging ends (pointer is lifted). */
up = () => { }) {
    return (e) => {
        /* click events */
        if (e instanceof MouseEvent) {
            if (e.button !== 0)
                return;
            let lastX = e.clientX, lastY = e.clientY;
            // up
            const upHandler = (e) => {
                const dx = e.clientX - lastX, dy = e.clientY - lastY;
                document.body.removeEventListener("mousemove", moveHandler);
                window.removeEventListener("mouseup", upHandler);
                return up(e, { x: e.clientX, y: e.clientY, dx, dy });
            };
            // move
            const moveHandler = (e) => {
                const dx = e.clientX - lastX, dy = e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                return move(e, { x: e.clientX, y: e.clientY, dx, dy });
            };
            document.body.addEventListener("mousemove", moveHandler, {
                passive: false,
            });
            window.addEventListener("mouseup", upHandler, { passive: false });
            return down(e, { x: lastX, y: lastY }, upHandler, moveHandler);
        }
        else {
            /* touch events */
            e.preventDefault();
            const touches = e.changedTouches;
            const touchId = touches[0].identifier;
            let lastX = touches[0].clientX, lastY = touches[0].clientY;
            // up
            const upHandler = (e) => {
                e.preventDefault();
                for (const touch of Array.from(e.changedTouches)) {
                    if (touch.identifier !== touchId)
                        continue;
                    const dx = touch.clientX - lastX, dy = touch.clientY - lastY;
                    window.removeEventListener("touchend", upHandler, {
                        capture: false,
                        passive: false,
                    });
                    window.removeEventListener("touchcancel", upHandler, {
                        capture: false,
                        passive: false,
                    });
                    window.removeEventListener("touchmove", moveHandler, {
                        capture: false,
                        passive: false,
                    });
                    return up(e, { x: touch.clientX, y: touch.clientY, dx, dy });
                }
            };
            // move
            const moveHandler = (e) => {
                e.preventDefault();
                for (const touch of Array.from(e.changedTouches)) {
                    if (touch.identifier !== touchId)
                        continue;
                    const dx = touch.clientX - lastX, dy = touch.clientY - lastY;
                    lastX = touch.clientX;
                    lastY = touch.clientY;
                    return move(e, { x: touch.clientX, y: touch.clientY, dx, dy });
                }
            };
            window.addEventListener("touchend", upHandler, {
                capture: false,
                passive: false,
            });
            window.addEventListener("touchcancel", upHandler, {
                capture: false,
                passive: false,
            });
            window.addEventListener("touchmove", moveHandler, {
                capture: false,
                passive: false,
            });
            return down(e, { x: lastX, y: lastY }, upHandler, moveHandler);
        }
    };
}
/**
 * Replacement for addEventListener("click") which works better on mobile.
 * @param node Event target.
 * @param callback Event listener.
 * @returns A function to remove the event listener.
 */
function onClick(node, callback) {
    if (anyHover) {
        node.addEventListener("click", callback);
        return () => {
            node.removeEventListener("click", callback);
        };
    }
    let touchId;
    // touchstart handler
    const touchStart = (e) => {
        if (typeof touchId === "number")
            return;
        touchId = e.changedTouches[0].identifier;
    };
    // touchend handler
    const touchEnd = (e) => {
        if (typeof touchId !== "number")
            return;
        for (const touch of Array.from(e.changedTouches)) {
            if (touch.identifier !== touchId)
                continue;
            if (node.contains(document.elementFromPoint(touch.clientX, touch.clientY))) {
                callback(e);
            }
            touchId = undefined;
        }
    };
    node.addEventListener("touchstart", touchStart);
    node.addEventListener("touchend", touchEnd);
    return () => {
        node.removeEventListener("touchstart", touchStart);
        node.removeEventListener("touchend", touchEnd);
    };
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/json.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/json.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getJSON: () => (/* binding */ getJSON),
/* harmony export */   loadAllJSON: () => (/* binding */ loadAllJSON),
/* harmony export */   loadJSON: () => (/* binding */ loadJSON)
/* harmony export */ });
const results = {};
/**
 * Preload all JSON resources.
 */
function loadAllJSON() {
    return Promise.all(Array.from(document.querySelectorAll("link[data-name][rel='preload'][type='application/json']")).map((link) => fetch(link.href)
        .then((res) => res.json())
        .then((json) => (results[link.dataset.name] = json)))).then();
}
/**
 * Load a JSON record asynchronously.
 */
function loadJSON(key) {
    return new Promise((resolve, reject) => {
        // check for cached result
        if (results[key]) {
            return resolve(results[key]);
        }
        const link = document.querySelector(`link[data-name="${key}"][rel='preload'][type='application/json']`);
        if (!link) {
            return reject(`JSON record "${key}" not found`);
        }
        return fetch(link.href)
            .then((res) => res.json())
            .then((data) => {
            // cache result
            results[key] = data;
            resolve(data);
        })
            .catch(reject);
    });
}
/**
 * Access a preloaded JSON record synchronously.
 */
function getJSON(key) {
    if (!results[key]) {
        throw new Error(`JSON record "${key}" not loaded`);
    }
    return results[key];
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/misc.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/misc.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   between: () => (/* binding */ between),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   constrain: () => (/* binding */ constrain),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   wait: () => (/* binding */ wait),
/* harmony export */   waitFor: () => (/* binding */ waitFor)
/* harmony export */ });
/** Equivalent to `(min <= val) && (val < max)`. */
function between(min, val, max) {
    return min <= val && val < max;
}
/**
 * Bind methods on an object.
 * @param o Object on which to bind methods
 * @param methods Method names to bind
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function bind(o, methods) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    for (const method of methods)
        o[method] = o[method].bind(o);
}
/**
 * Linear interpolation from a to b.
 */
function lerp(a, b, t) {
    return a + t * (b - a);
}
/**
 * Clamps a value between a lower and upper bound. Aliased as {@link constrain}.
 * @param min Lower bound
 * @param val Value to clamp
 * @param max Upper bound
 */
function clamp(min, val, max) {
    return Math.min(max, Math.max(min, val));
}
/**
 * Clamps a value between a lower and upper bound. Alias for {@link clamp}.
 * @param min Lower bound
 * @param val Value to clamp
 * @param max Upper bound
 */
function constrain(min, val, max) {
    return clamp(min, val, max);
}
/**
  Returns [a, b). For backwards compatibility, returns [0, a) if passed a single argument.
*/
function range(a, b) {
    if (b === void 0) {
        return range(0, a);
    }
    return new Array(b - a).fill(null).map((_, i) => a + i);
}
/** Returns a Promise that resolves in `time` milliseconds. */
function wait(time) {
    return new Promise((resolve) => {
        setTimeout(resolve, time);
    });
}
/** Returns a Promise that resolves once `callback` returns true. */
function waitFor(callback, interval = 10) {
    return new Promise((resolve) => {
        const checkCondition = () => {
            if (callback()) {
                resolve();
            }
            else {
                setTimeout(checkCondition, interval);
            }
        };
        checkCondition();
    });
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/react.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/react.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   captureRef: () => (/* binding */ captureRef),
/* harmony export */   combineRefs: () => (/* binding */ combineRefs),
/* harmony export */   createUniqueContext: () => (/* binding */ createUniqueContext),
/* harmony export */   onClick: () => (/* binding */ onClick),
/* harmony export */   onDrag: () => (/* binding */ onDrag),
/* harmony export */   recursiveMap: () => (/* binding */ recursiveMap),
/* harmony export */   useForceUpdate: () => (/* binding */ useForceUpdate),
/* harmony export */   usePromise: () => (/* binding */ usePromise)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _interaction_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interaction.mjs */ "./node_modules/@liqvid/utils/dist/esm/interaction.mjs");


/**
  Helper for the https://github.com/facebook/react/issues/2043 workaround. Use to intercept refs and
  attach events.
*/
const captureRef = (callback, innerRef) => (ref) => {
    if (ref !== null) {
        callback(ref);
    }
    if (innerRef === null) {
        return;
    }
    else if (typeof innerRef === "function") {
        innerRef(ref);
    }
    else if (typeof innerRef === "object") {
        innerRef.current = ref;
    }
};
/**
 * Create a context guaranteed to be unique. Useful in case multiple versions of package are accidentally loaded.
 * @param name Unique key for context.
 * @param defaultValue Initial value for context.
 * @returns React context which is guaranteed to be stable.
 */
function createUniqueContext(key, defaultValue = undefined, displayName) {
    const symbol = Symbol.for(key);
    if (!(symbol in globalThis)) {
        const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue);
        context.displayName = displayName;
        globalThis[symbol] = context;
    }
    return globalThis[symbol];
}
/**
 * Combine multiple refs into one
 * @param args Refs to combine
 * @returns A ref which applies all the passed refs
 */
function combineRefs(...args) {
    return (o) => {
        for (const ref of args) {
            if (typeof ref === "function") {
                ref(o);
            }
            else if (ref === null) {
            }
            else if (typeof ref === "object" && ref.hasOwnProperty("current")) {
                ref.current = o;
            }
        }
    };
}
/**
 * Drop-in replacement for onClick handlers which works better on mobile.
 * @param callback Event listener.
 * @returns Props to attach to event target.
 */
function onClick(callback) {
    if (_interaction_mjs__WEBPACK_IMPORTED_MODULE_1__.anyHover) {
        return { onClick: callback };
    }
    else {
        let touchId, target;
        // touchstart handler
        const onTouchStart = (e) => {
            if (typeof touchId === "number")
                return;
            target = e.currentTarget;
            touchId = e.changedTouches[0].identifier;
        };
        // touchend handler
        const onTouchEnd = (e) => {
            if (typeof touchId !== "number")
                return;
            for (const touch of Array.from(e.changedTouches)) {
                if (touch.identifier !== touchId)
                    continue;
                if (target.contains(document.elementFromPoint(touch.clientX, touch.clientY))) {
                    callback(e);
                }
                touchId = undefined;
                break;
            }
        };
        return { onTouchStart, onTouchEnd };
    }
}
/**
 * Helper for implementing drag functionality, abstracting over mouse vs touch events.
 * @returns An object of event handlers which should be added to a React element with {...}
 */
function onDrag(move, down, up) {
    const listener = (0,_interaction_mjs__WEBPACK_IMPORTED_MODULE_1__.onDrag)(move, down, up);
    return {
        "data-affords": "click",
        onMouseDown: (e) => listener(e.nativeEvent),
        onTouchStart: (e) => listener(e.nativeEvent),
    };
}
/**
 * Recursive version of {@link React.Children.map}
 * @param children Children to iterate over
 * @param fn Callback function
 * @returns Transformed nodes
 */
function recursiveMap(children, fn) {
    return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (child) => {
        if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child)) {
            return child;
        }
        if ("children" in child.props) {
            child = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, {
                // @ts-expect-error TODO this used to work
                children: recursiveMap(child.props.children, fn),
            });
        }
        return fn(child);
    });
}
/**
 * Get a function to force the component to update
 * @returns A forceUpdate() function
 */
function useForceUpdate() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((c) => c + 1, 0)[1];
}
/**
 * Get a promise and resolver
 * @param deps React dependency list
 * @returns [promise, resolve, reject]
 */
function usePromise(deps = []) {
    const resolve = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    const reject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    const promise = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => new Promise((res, rej) => {
        resolve.current = res;
        reject.current = rej;
    }), deps);
    return [promise, resolve.current, reject.current];
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/replay-data.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/replay-data.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   length: () => (/* binding */ length)
/* harmony export */ });
/**
 * Concatenate several ReplayData together, with delays.
 * @param args [ReplayData, delay] objects to join
 * @returns Concatenated replay data
 */
function concat(...args) {
    const [head, ...tail] = args;
    const ret = [...head[0]];
    let ptr = head[1] + length(head[0]);
    for (const [data, start] of tail) {
        const copy = data.slice();
        copy[0][0] += start - ptr;
        ret.push(...copy);
        ptr += length(copy);
    }
    return ret;
}
/**
 * Get the total duration of replay data.
 * @param data ReplayData item
 * @returns Duration of replay data
 */
function length(data) {
    return data.map((_) => _[0]).reduce((a, b) => a + b, 0);
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/ssr.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/ssr.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isClient: () => (/* binding */ isClient)
/* harmony export */ });
const isClient = typeof globalThis.window !== "undefined";


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/svg.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/svg.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   screenToSVG: () => (/* binding */ screenToSVG),
/* harmony export */   screenToSVGVector: () => (/* binding */ screenToSVGVector)
/* harmony export */ });
/**
 * Convert screen coordinates to SVG coordinates.
 * @param elt SVG Element
 * @param x Screen x coordinate
 * @param y Screen y coordinate
 * @returns [x, y] in SVG coordinates
 */
function screenToSVG(elt, x, y) {
    let graphicsElt = elt;
    while (!(graphicsElt instanceof SVGGraphicsElement))
        graphicsElt = graphicsElt.parentNode;
    const svgElt = elt instanceof SVGSVGElement ? elt : elt.ownerSVGElement;
    const transform = graphicsElt.getScreenCTM().inverse();
    let pt = svgElt.createSVGPoint();
    (pt.x = x), (pt.y = y);
    pt = pt.matrixTransform(transform);
    return [pt.x, pt.y];
    // const rect = svg.getBoundingClientRect(),
    //       viewBox = svg.viewBox.baseVal,
    //       aspectX = rect.width / viewBox.width,
    //       aspectY = rect.height / viewBox.height,
    //       svgX = (x - rect.left) / aspectX + viewBox.x,
    //       svgY = (y - rect.top) / aspectY + viewBox.y;
    // return [svgX, svgY];
}
/**
 * Convert screen vector coordinates to SVG vector coordinates.
 * @param svg SVG element
 * @param dx Relative screen x coordinate
 * @param dy Relative screen y coordinate
 * @returns [dx, dy] in SVG coordinates
 */
function screenToSVGVector(svg, dx, dy) {
    const rect = svg.getBoundingClientRect(), viewBox = svg.viewBox.baseVal, aspectX = rect.width / viewBox.width, aspectY = rect.height / viewBox.height, svgDx = dx / aspectX, svgDy = dy / aspectY;
    return [svgDx, svgDy];
}


/***/ }),

/***/ "./node_modules/@liqvid/utils/dist/esm/time.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liqvid/utils/dist/esm/time.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatTime: () => (/* binding */ formatTime),
/* harmony export */   formatTimeDuration: () => (/* binding */ formatTimeDuration),
/* harmony export */   formatTimeMs: () => (/* binding */ formatTimeMs),
/* harmony export */   parseTime: () => (/* binding */ parseTime),
/* harmony export */   timeRegexp: () => (/* binding */ timeRegexp)
/* harmony export */ });
/* time constants */
const SECONDS = 1000;
const MINUTES = 60 * SECONDS;
const HOURS = 60 * MINUTES;
const DAYS = 24 * HOURS;
// nice minus sign
const MINUS_SIGN = "\u2212";
/**
 * Regular expression used to match times
 */
const timeRegexp = new RegExp("^" + "(?:(\\d+):)?".repeat(3) + "(\\d+)(?:\\.(\\d+))?$");
/**
 * Parse a time string like "3:43" into milliseconds
 * @param str String to parse
 * @returns Time in milliseconds
 */
function parseTime(str) {
    if (str[0] === MINUS_SIGN || str[0] === "-") {
        return -parseTime(str.slice(1));
    }
    // d, h, m, s
    const parts = str.split(":").map((x) => parseInt(x, 10));
    while (parts.length < 4) {
        parts.unshift(0);
    }
    // ms
    const $_ = str.match(/\.(\d{0,3})/);
    if ($_) {
        parts.push(parseInt($_[1].padEnd(3, "0")));
    }
    else {
        parts.push(0);
    }
    const [days, hours, minutes, seconds, milliseconds] = parts;
    return (milliseconds + 1000 * (seconds + 60 * (minutes + 60 * (hours + 24 * days))));
}
/**
 * Format a duration as a {@link https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-duration-string time duration string}
 * for use as a {@link https://html.spec.whatwg.org/multipage/text-level-semantics.html#attr-time-datetime datetime} attribute.
 * @param time Duration in milliseconds.
 * @returns A duration string such as "PT4H18M3S".
 * @since 1.7.0
 */
function formatTimeDuration(time) {
    const parts = ["P"];
    const timeParts = [];
    const days = Math.floor(time / DAYS), hours = Math.floor((time / HOURS) % 24), minutes = Math.floor((time / MINUTES) % 60), seconds = (time / SECONDS) % 60;
    if (days > 0) {
        parts.push(`${days}D`);
    }
    if (hours > 0) {
        timeParts.push(`${hours}H`);
    }
    if (minutes > 0) {
        timeParts.push(`${minutes}M`);
    }
    if (seconds > 0) {
        timeParts.push(`${seconds.toFixed(3).replace(/\.?0+$/, "")}S`);
    }
    if (timeParts.length > 0) {
        parts.push("T", ...timeParts);
    }
    return parts.join("");
}
/**
 * Format a time as "mm:ss"
 * @param time Time in milliseconds
 * @returns Formatted time
 */
function formatTime(time) {
    if (time < 0) {
        return MINUS_SIGN + formatTime(-time);
    }
    const days = Math.floor(time / DAYS), hours = Math.floor((time / HOURS) % 24), minutes = Math.floor((time / MINUTES) % 60), seconds = Math.floor((time / SECONDS) % 60);
    let firstNonzero = true;
    let str = "";
    for (const part of [days, hours, minutes]) {
        if (firstNonzero) {
            if (part !== 0) {
                firstNonzero = false;
                str += part.toString() + ":";
            }
        }
        else {
            str += part.toString().padStart(2, "0") + ":";
        }
    }
    // display 0:ss
    if (firstNonzero) {
        str += "0:";
    }
    str += seconds.toString().padStart(2, "0");
    return str;
}
/**
 * Format a time as "mm:ss.ms"
 * @param time Time in milliseconds
 * @returns Formatted time
 */
function formatTimeMs(time) {
    if (time < 0) {
        return MINUS_SIGN + formatTimeMs(-time);
    }
    const milliseconds = Math.floor(time % 1000);
    if (milliseconds === 0) {
        return formatTime(time);
    }
    return (formatTime(time) +
        "." +
        String(milliseconds).padStart(3, "0").replace(/0+$/, ""));
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/Console.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/Console.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Console: () => (/* binding */ Console)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand */ "./node_modules/zustand/esm/react.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");




/** Component for displaying console logs. */
function Console({ className }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_2__.useBoothStore)();
    const messages = (0,zustand__WEBPACK_IMPORTED_MODULE_3__.useStore)(store, (state) => state.messages);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("section", { className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-console", className), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("header", { children: "Console" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("output", { children: messages })] }));
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/Editor.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/Editor.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Editor: () => (/* binding */ Editor)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _extensions_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extensions.mjs */ "./node_modules/@lqv/codebooth/dist/esm/extensions.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");






/** Compartment for toggling extensions in CodeMirror. */
const editorCompartment = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Compartment();
/** CodeMirror editor. */
function Editor({ content = "", editable = true, extensions, filename, group: groupId = "default", ...props }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
    const [view, setView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
    // initialize the view
    // biome-ignore lint/correctness/useExhaustiveDependencies: changing `content` is an error
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        if (!ref.current)
            return;
        // create editor
        const view = new _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView({
            parent: ref.current,
            state: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create({
                doc: content,
                extensions: [
                    _extensions_mjs__WEBPACK_IMPORTED_MODULE_5__.recording.of([]),
                    _extensions_mjs__WEBPACK_IMPORTED_MODULE_5__.shortcuts.of([]),
                    ...(editable ? [] : [_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.editable.of(false)]),
                    ...(extensions ?? []),
                ],
            }),
        });
        setView(view);
        // insert into state
        store.setState((prev) => {
            const group = prev.groups[groupId] ?? {
                activeFile: filename,
                files: [],
            };
            return {
                activeGroup: prev.activeGroup || groupId,
                groups: {
                    ...prev.groups,
                    [groupId]: {
                        activeFile: group.activeFile,
                        files: [
                            ...group.files,
                            {
                                editable,
                                filename,
                                view,
                            },
                        ],
                    },
                },
            };
        });
        return () => {
            view.destroy();
            store.setState((prev) => {
                return {
                    ...prev,
                    groups: {
                        ...prev.groups,
                        ...(prev.groups[groupId]
                            ? {
                                [groupId]: {
                                    ...prev.groups[groupId],
                                    files: prev.groups[groupId].files.filter((file) => file.filename !== filename),
                                },
                            }
                            : {}),
                    },
                };
            });
        };
    }, []);
    // configure extensions
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        view?.dispatch({
            effects: editorCompartment.reconfigure([
                ...(editable ? [] : [_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.editable.of(false)]),
                ...(extensions ?? []),
            ]),
        });
    }, [editable, extensions, view]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { ref: ref, ...props });
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/EditorGroup.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/EditorGroup.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditorGroup: () => (/* binding */ EditorGroup)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand */ "./node_modules/zustand/esm/react.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils.mjs */ "./node_modules/@lqv/codebooth/dist/esm/utils.mjs");






/** Holds a group of editors. */
function EditorGroup({ children, className, id, ...attrs }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    const active = (0,zustand__WEBPACK_IMPORTED_MODULE_4__.useStore)(store, (state) => state.activeGroup === id);
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
        const state = store.getState();
        if (!state.activeGroup) {
            store.setState({ activeGroup: id });
        }
        return () => {
            store.setState((prev) => {
                const newGroups = Object.fromEntries(Object.entries(prev.groups).filter(([key]) => key !== id));
                return {
                    ...prev,
                    activeGroup: prev.activeGroup === id
                        ? Object.keys(newGroups)[0]
                        : prev.activeGroup,
                    groups: newGroups,
                };
            });
        };
    }, [id, store]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { "aria-expanded": active, "aria-labelledby": _utils_mjs__WEBPACK_IMPORTED_MODULE_5__.ids.groupTab({ group: id }), hidden: !active, className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-editor-group", className), id: _utils_mjs__WEBPACK_IMPORTED_MODULE_5__.ids.editorGroup({ group: id }), role: "tabpanel", ...attrs, children: react__WEBPACK_IMPORTED_MODULE_2__.Children.map(children, (node) => {
            if (typeof node === "object" && node !== null && "props" in node) {
                return (0,react__WEBPACK_IMPORTED_MODULE_2__.cloneElement)(node, { group: id });
            }
            return node;
        }) }));
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/EditorPanel.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/EditorPanel.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditorPanel: () => (/* binding */ EditorPanel)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand */ "./node_modules/zustand/esm/react.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils.mjs */ "./node_modules/@lqv/codebooth/dist/esm/utils.mjs");






/**
 * Tabpanel containing a single editor.
 */
function EditorPanel({ children, className, filename, group = "default", ...props }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    const active = (0,zustand__WEBPACK_IMPORTED_MODULE_4__.useStore)(store, (state) => state.groups[group]?.activeFile === filename);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { "aria-expanded": active, "aria-labelledby": _utils_mjs__WEBPACK_IMPORTED_MODULE_5__.ids.fileTab({ filename, group }), className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-editor-panel", className), hidden: !active, id: _utils_mjs__WEBPACK_IMPORTED_MODULE_5__.ids.editorPanel({ filename, group }), role: "tabpanel", ...props, children: react__WEBPACK_IMPORTED_MODULE_2__.Children.map(children, (node) => {
            if (typeof node === "object" && node !== null && "props" in node) {
                return (0,react__WEBPACK_IMPORTED_MODULE_2__.cloneElement)(node, { filename, group });
            }
            return node;
        }) }));
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/FileTabs.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/FileTabs.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FileTabs: () => (/* binding */ FileTabs)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var _lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lqv/codemirror */ "./node_modules/@lqv/codemirror/dist/esm/index.mjs");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ "./node_modules/zustand/esm/react.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.mjs */ "./node_modules/@lqv/codebooth/dist/esm/utils.mjs");








const selector = (state) => [
    state.activeGroup,
    state.groups[state.activeGroup]?.activeFile,
];
/**
 * File selector component.
 */
function FileTabs({ className, classNames: propClassNames, }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_4__.useBoothStore)();
    const [activeGroup, activeFilename] = (0,zustand__WEBPACK_IMPORTED_MODULE_5__.useStore)(store, selector);
    const group = store.getState().groups[activeGroup];
    const { recorder } = store.getState();
    const select = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((filename) => {
        // record event
        // @ts-expect-error TODO fix this
        if (recorder?.manager?.active) {
            recorder.capture(undefined, _lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.selectCmd + filename);
        }
        // set state
        store.setState((state) => ({
            groups: {
                ...state.groups,
                [state.activeGroup]: {
                    ...state.groups[state.activeGroup],
                    activeFile: filename,
                },
            },
        }));
        // focus editor
        const state = store.getState();
        const view = state.groups[state.activeGroup]?.files.find((_) => _.filename === filename)?.view;
        if (view) {
            // XXX yikes
            setTimeout(() => view.focus());
        }
    }, [recorder, store.getState, store.setState]);
    const events = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_6__.onClick)((e) => {
        select(e.currentTarget.textContent.trim());
    }), [select]);
    // set class
    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {
        // keyboard shortcuts
        const selectShortcuts = {};
        for (let i = 1; i <= 9; ++i) {
            selectShortcuts[`Mod-${i}`] = {
                key: `Mod-${i}`,
                run: () => {
                    const state = store.getState();
                    const group = state.groups[state.activeGroup];
                    if (group.files.length < i)
                        return false;
                    select(group.files[i - 1].filename);
                    return true;
                },
            };
        }
        // set class
        store.setState((prev) => ({
            // set class
            classNames: prev.classNames.concat("multifile"),
            // shortcuts
            shortcuts: {
                ...prev.shortcuts,
                ...selectShortcuts,
            },
        }));
        return () => {
            store.setState((prev) => ({
                // set class
                classNames: prev.classNames.filter((_) => _ !== "multifile"),
                // shortcuts
                shortcuts: Object.fromEntries(Object.entries(prev.shortcuts).filter(([key]) => !("Mod-1" <= key && key <= "Mod-9"))),
            }));
        };
    }, [select, store.getState, store.setState]);
    if (!group)
        return null;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: classnames__WEBPACK_IMPORTED_MODULE_2__("lqv-file-tabs", propClassNames?.container ?? className), role: "tablist", children: group.files.map(({ filename }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { "aria-controls": _utils_mjs__WEBPACK_IMPORTED_MODULE_7__.ids.editorPanel({ filename, group: activeGroup }), "aria-selected": activeFilename === filename, className: classnames__WEBPACK_IMPORTED_MODULE_2__(`lqv-filetype-${getFileType(filename)}`, propClassNames?.tab), id: _utils_mjs__WEBPACK_IMPORTED_MODULE_7__.ids.fileTab({ filename, group: activeGroup }), role: "tab", ...events, children: filename }, filename))) }));
}
/**
 * Get file extension.
 * @param filename Name of file.
 * @returns File extension.
 */
function getFileType(filename) {
    return filename.slice(filename.lastIndexOf(".") + 1);
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/Record.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/Record.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Record: () => (/* binding */ Record)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @liqvid/keymap/react */ "./node_modules/@liqvid/keymap/dist/esm/react.mjs");
/* harmony import */ var _lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lqv/codemirror */ "./node_modules/@lqv/codemirror/dist/esm/index.mjs");
/* harmony import */ var _lqv_codemirror_extensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lqv/codemirror/extensions */ "./node_modules/@lqv/codemirror/dist/esm/extensions.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _extensions_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../extensions.mjs */ "./node_modules/@lqv/codebooth/dist/esm/extensions.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");
/* harmony import */ var _Editor_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Editor.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/Editor.mjs");









/** Recording editor. */
const Record = (props) => {
    const { captureKeys = {
        "Mod-Enter": "run",
        "Mod-K": "clear",
        "Mod-L": "clear",
    }, extensions = [], group = "default", passKeys = ["Mod-Alt-2", "Mod-Alt-3", "Mod-Alt-4"], ...attrs } = props;
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_4__.useBoothStore)();
    const lqvKeymap = (0,_liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_5__.useKeymap)();
    const newExtensions = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lqvKeymap
        ? [_codemirror_view__WEBPACK_IMPORTED_MODULE_6__.keymap.of((0,_lqv_codemirror_extensions__WEBPACK_IMPORTED_MODULE_2__.passThrough)(lqvKeymap, passKeys)), ...extensions]
        : extensions, [extensions, lqvKeymap, passKeys]);
    // attach recording extensions --- this has to be done this way because
    // the `shortcuts` Compartment will abort further handling of the sequence
    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {
        const state = store.getState();
        const { view } = state.groups[group].files.find((file) => file.filename === props.filename);
        view.dispatch({
            effects: _extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.recording.reconfigure([
                ..._extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.recording.get(view.state),
                [state.recorder.extension(captureKeys)],
            ]),
        });
        includeFilenameInRecording(state);
    }, [captureKeys, group, props.filename, store.getState]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Editor_mjs__WEBPACK_IMPORTED_MODULE_8__.Editor, { content: props.content, extensions: newExtensions, ...attrs }));
};
/* NOOOOOOOOOO */
const modifiedRecorder = Symbol();
function includeFilenameInRecording(state) {
    // only do this if we are recording in multiple files
    let recordingExtensions = 0;
    outer: for (const group of Object.values(state.groups)) {
        for (const { view } of group.files) {
            const extnState = _extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.recording.get(view.state);
            if (Array.isArray(extnState) && extnState.length > 0) {
                recordingExtensions++;
                if (recordingExtensions > 1)
                    break outer;
            }
        }
    }
    if (recordingExtensions < 2) {
        return;
    }
    // be idempotent
    if (state.recorder[modifiedRecorder]) {
        return;
    }
    // intercept beginRecording
    const beginRecording = state.recorder.beginRecording.bind(state.recorder);
    state.recorder.beginRecording = (...args) => {
        // have to call existing beginRecording() FIRST in order to
        // set state.recorder.duration, otherwise we get negative times!
        beginRecording(...args);
        state.recorder.capture(0, _lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.selectCmd + state.getActiveFile().filename);
    };
    state.recorder[modifiedRecorder] = true;
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/Replay.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/Replay.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Replay: () => (/* binding */ Replay),
/* harmony export */   ReplayMultiple: () => (/* binding */ ReplayMultiple)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lqv/codemirror */ "./node_modules/@lqv/codemirror/dist/esm/index.mjs");
/* harmony import */ var _lqv_playback_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lqv/playback/react */ "./node_modules/@lqv/playback/dist/esm/react.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");
/* harmony import */ var _Editor_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Editor.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/Editor.mjs");







/**
 * Editor to replay recorded coding.
 */
function Replay({ extensions = [], handle, replay, scrollBehavior, selectionConfig, didScroll, shouldScroll, start = 0, ...props }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_4__.useBoothStore)();
    const playback = (0,_lqv_playback_react__WEBPACK_IMPORTED_MODULE_2__.useME)();
    const __handle = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((cmd, doc) => {
        if (cmd === "run") {
            // run command
            store.setState((state) => ({ run: state.run + 1 }));
        }
        else if (cmd === "clear") {
            // clear console
            store.setState(() => ({ messages: [] }));
        }
        // userspace handler
        handle?.(store, cmd, doc);
    }, [handle, store]);
    const __extensions = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => [
        (0,_lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.fakeSelection)(selectionConfig),
        _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.ViewPlugin.define((view) => {
            if (replay) {
                if (replay instanceof Promise) {
                    replay.then((data) => (0,_lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.cmReplay)({
                        data,
                        didScroll,
                        handle: __handle,
                        playback,
                        scrollBehavior,
                        shouldScroll,
                        start,
                        view,
                    }));
                }
                else {
                    (0,_lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.cmReplay)({
                        data: replay,
                        didScroll,
                        handle: __handle,
                        playback,
                        scrollBehavior,
                        shouldScroll,
                        start,
                        view,
                    });
                }
            }
            return {};
        }),
        ...extensions,
    ], [
        __handle,
        didScroll,
        extensions,
        playback,
        replay,
        scrollBehavior,
        selectionConfig,
        shouldScroll,
        start,
    ]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Editor_mjs__WEBPACK_IMPORTED_MODULE_6__.Editor, { editable: false, extensions: __extensions, ...props });
}
/**
 * Replay coding to multiple editors.
 */
function ReplayMultiple({ didScroll, group, handle: propsHandle, replay, scrollBehavior, shouldScroll, start = 0, }) {
    const playback = (0,_lqv_playback_react__WEBPACK_IMPORTED_MODULE_2__.useME)();
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_4__.useBoothStore)();
    /* Handle callback */
    const handle = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((cmd, docs) => {
        // file selection change
        if (cmd.startsWith(_lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.selectCmd)) {
            store.setState((state) => ({
                groups: {
                    ...state.groups,
                    [group]: {
                        ...state.groups[group],
                        activeFile: cmd.slice(_lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.selectCmd.length),
                    },
                },
            }));
        }
        else if (cmd === "run") {
            // run command
            store.setState((state) => ({ run: state.run + 1 }));
        }
        else if (cmd === "clear") {
            // clear console
            store.setState(() => ({ messages: [] }));
        }
        // userspace handler
        propsHandle?.(store, cmd, docs);
    }, [group, propsHandle, store]);
    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {
        const state = store.getState();
        const views = {};
        for (const file of state.groups[group].files) {
            views[file.filename] = file.view;
        }
        if (replay instanceof Promise) {
            replay.then((data) => (0,_lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.cmReplayMultiple)({
                data,
                didScroll,
                handle,
                playback,
                scrollBehavior,
                shouldScroll,
                start,
                views,
            }));
        }
        else {
            (0,_lqv_codemirror__WEBPACK_IMPORTED_MODULE_1__.cmReplayMultiple)({
                data: replay,
                didScroll,
                handle,
                playback,
                scrollBehavior,
                shouldScroll,
                start,
                views,
            });
        }
    }, [
        didScroll,
        group,
        handle,
        playback,
        replay,
        scrollBehavior,
        shouldScroll,
        start,
        store,
    ]);
    return null;
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/Resize.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/Resize.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Resize: () => (/* binding */ Resize)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");




/**
 * Component for adjusting the vertical editor/console split.
 */
function Resize({ dir = "ew", max = 0.75, min = 0.25, }) {
    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
    /* event handlers */
    const resizeEvents = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
        let container;
        return (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onDrag)((_e, { x, y }) => {
            const rect = container.getBoundingClientRect();
            if (dir === "ew") {
                const split = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__.clamp)(min, (x - rect.left) / rect.width, max) * 100;
                container.style.setProperty("--split", `${split}%`);
            }
            else if (dir === "ns") {
                const split = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__.clamp)(min, (rect.bottom - y) / rect.height, max) * 100;
                container.style.setProperty("--v-split", `${split}%`);
            }
        }, () => {
            container = ref.current.closest(".lqv-codebooth");
            container.classList.add("dragging");
        }, () => {
            container.classList.remove("dragging");
        });
    }, [dir, max, min]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { ...resizeEvents, ref: ref, className: `ui-resizable-handle ui-resizable-${dir}` }));
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/components/buttons.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/components/buttons.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Buttons: () => (/* binding */ Buttons),
/* harmony export */   Clear: () => (/* binding */ Clear),
/* harmony export */   Copy: () => (/* binding */ Copy),
/* harmony export */   Reset: () => (/* binding */ Reset),
/* harmony export */   Run: () => (/* binding */ Run),
/* harmony export */   Tab: () => (/* binding */ Tab),
/* harmony export */   TabList: () => (/* binding */ TabList)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ "./node_modules/zustand/esm/react.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.mjs */ "./node_modules/@lqv/codebooth/dist/esm/utils.mjs");







/** Div to hold buttons. */
function Buttons({ className, ...props }) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-cb-buttons", className), ...props });
}
/** Button for clearing the output/console. */
function Clear({ className, children = "Clear", shortcut = "Mod-L", title = "Clear", ...attrs }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    const clear = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {
        store.setState({ messages: [] });
    }, [store.setState]);
    const events = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__.onClick)(clear), [clear]);
    /* add keyboard shortcuts */
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
        store.setState((prev) => ({
            shortcuts: {
                ...prev.shortcuts,
                [shortcut]: {
                    key: shortcut,
                    run: () => {
                        clear();
                        return true;
                    },
                },
            },
        }));
        return () => {
            store.setState((prev) => ({
                shortcuts: {
                    ...prev.shortcuts,
                    [shortcut]: undefined,
                },
            }));
        };
    }, [clear, shortcut, store.setState]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-cb-clear", className), title: title, type: "button", ...events, ...attrs, children: children }));
}
/** Button for copying the contents of one group to another. */
function Copy({ children = "Copy", className, from: fromGroup, to: toGroup, ...attrs }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    const copy = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {
        const { groups } = store.getState();
        const from = groups[fromGroup];
        const to = groups[toGroup];
        if (!(from && to)) {
            console.error(`Could not copy from ${fromGroup} to ${toGroup}`);
            return;
        }
        for (const file of from.files) {
            const source = file.view;
            const target = to.files.find((_) => _.filename === file.filename).view;
            target.dispatch(target.state.update({
                changes: {
                    from: 0,
                    to: target.state.doc.length,
                    insert: source.state.doc,
                },
            }));
        }
    }, [fromGroup, store.getState, toGroup]);
    const events = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__.onClick)(copy), [copy]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-cb-copy", className), ...events, ...attrs, children: children }));
}
/** Button for resetting editor contents to initial state. */
function Reset({ className, children = "Reset", title = "Reset", ...attrs }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    const contents = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)({});
    /* get contents */
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
        const state = store.getState();
        for (const key in state.groups) {
            contents.current[key] = {};
            for (const file of state.groups[key].files) {
                contents.current[key][file.filename] = file.view.state.doc.toString();
            }
        }
    }, [store]);
    /* reset */
    const reset = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {
        const state = store.getState();
        for (const groupName in contents.current) {
            for (const file of state.groups[groupName].files) {
                if (file.filename in contents.current[groupName]) {
                    file.view.dispatch(file.view.state.update({
                        changes: {
                            from: 0,
                            to: file.view.state.doc.length,
                            insert: contents.current[groupName][file.filename],
                        },
                    }));
                }
            }
        }
    }, [store]);
    const resetEvents = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__.onClick)(reset), [reset]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-cb-reset", className), title: title, ...resetEvents, ...attrs, children: children }));
}
/** Button for running the code. */
function Run({ className, children = "Run", shortcut = "Mod-Enter", title = "Run", ...props }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    // run callback
    const run = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {
        store.setState((prev) => ({ run: prev.run + 1 }));
    }, [store.setState]);
    /* add keyboard shortcuts */
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
        store.setState((prev) => ({
            shortcuts: {
                ...prev.shortcuts,
                [shortcut]: {
                    key: shortcut,
                    run: () => {
                        run();
                        return true;
                    },
                },
            },
        }));
    }, [run, shortcut, store.setState]);
    // click events
    const events = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__.onClick)(run), [run]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: classnames__WEBPACK_IMPORTED_MODULE_1__("lqv-cb-run", className), title: title, type: "button", ...events, ...props, children: children }));
}
/** Group selection tab. */
function Tab({ id, ...props }) {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_3__.useBoothStore)();
    const active = (0,zustand__WEBPACK_IMPORTED_MODULE_5__.useStore)(store, (state) => state.activeGroup === id);
    const events = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__.onClick)(() => {
        store.setState({ activeGroup: id });
    }), [id, store.setState]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { "aria-controls": _utils_mjs__WEBPACK_IMPORTED_MODULE_6__.ids.editorGroup({ group: id }), "aria-selected": active, id: _utils_mjs__WEBPACK_IMPORTED_MODULE_6__.ids.groupTab({ group: id }), role: "tab", type: "button", ...events, ...props }));
}
/** Holds a list of {@link Tab}s. */
function TabList(props) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { role: "tablist", ...props });
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/extensions.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/extensions.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basicSetup: () => (/* binding */ basicSetup),
/* harmony export */   recording: () => (/* binding */ recording),
/* harmony export */   shortcuts: () => (/* binding */ shortcuts)
/* harmony export */ });
/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/autocomplete */ "./node_modules/@codemirror/autocomplete/dist/index.js");
/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/commands */ "./node_modules/@codemirror/commands/dist/index.js");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.js");
/* harmony import */ var _codemirror_lint__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/lint */ "./node_modules/@codemirror/lint/dist/index.js");
/* harmony import */ var _codemirror_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/search */ "./node_modules/@codemirror/search/dist/index.js");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");







const basicSetup = [
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.lineNumbers)(),
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.highlightActiveLineGutter)(),
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.highlightSpecialChars)(),
    (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.history)(),
    (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldGutter)(),
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.drawSelection)(),
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.dropCursor)(),
    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.allowMultipleSelections.of(true),
    (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentOnInput)(),
    (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.defaultHighlightStyle, { fallback: true }),
    (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.bracketMatching)(),
    (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_4__.closeBrackets)(),
    (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_4__.autocompletion)(),
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.rectangularSelection)(),
    // crosshairCursor(),
    (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.highlightActiveLine)(),
    (0,_codemirror_search__WEBPACK_IMPORTED_MODULE_5__.highlightSelectionMatches)(),
    _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.keymap.of([
        ..._codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_4__.closeBracketsKeymap,
        ..._codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.defaultKeymap,
        ..._codemirror_search__WEBPACK_IMPORTED_MODULE_5__.searchKeymap,
        ..._codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.historyKeymap,
        ..._codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldKeymap,
        ..._codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_4__.completionKeymap,
        {
            key: "Tab",
            run: _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_4__.acceptCompletion,
        },
        _codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.indentWithTab,
        ..._codemirror_lint__WEBPACK_IMPORTED_MODULE_6__.lintKeymap,
    ]),
];
const recording = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Compartment();
const shortcuts = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Compartment();


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Buttons: () => (/* reexport safe */ _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__.Buttons),
/* harmony export */   Clear: () => (/* reexport safe */ _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__.Clear),
/* harmony export */   CodeBooth: () => (/* binding */ CodeBooth),
/* harmony export */   Console: () => (/* reexport safe */ _components_Console_mjs__WEBPACK_IMPORTED_MODULE_5__.Console),
/* harmony export */   Copy: () => (/* reexport safe */ _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__.Copy),
/* harmony export */   Editor: () => (/* reexport safe */ _components_Editor_mjs__WEBPACK_IMPORTED_MODULE_6__.Editor),
/* harmony export */   EditorGroup: () => (/* reexport safe */ _components_EditorGroup_mjs__WEBPACK_IMPORTED_MODULE_7__.EditorGroup),
/* harmony export */   EditorPanel: () => (/* reexport safe */ _components_EditorPanel_mjs__WEBPACK_IMPORTED_MODULE_8__.EditorPanel),
/* harmony export */   FileTabs: () => (/* reexport safe */ _components_FileTabs_mjs__WEBPACK_IMPORTED_MODULE_9__.FileTabs),
/* harmony export */   Record: () => (/* reexport safe */ _components_Record_mjs__WEBPACK_IMPORTED_MODULE_10__.Record),
/* harmony export */   Replay: () => (/* reexport safe */ _components_Replay_mjs__WEBPACK_IMPORTED_MODULE_11__.Replay),
/* harmony export */   ReplayMultiple: () => (/* reexport safe */ _components_Replay_mjs__WEBPACK_IMPORTED_MODULE_11__.ReplayMultiple),
/* harmony export */   Reset: () => (/* reexport safe */ _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__.Reset),
/* harmony export */   Resize: () => (/* reexport safe */ _components_Resize_mjs__WEBPACK_IMPORTED_MODULE_12__.Resize),
/* harmony export */   Run: () => (/* reexport safe */ _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__.Run),
/* harmony export */   Tab: () => (/* reexport safe */ _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__.Tab),
/* harmony export */   TabList: () => (/* reexport safe */ _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__.TabList),
/* harmony export */   basicSetup: () => (/* reexport safe */ _extensions_mjs__WEBPACK_IMPORTED_MODULE_13__.basicSetup),
/* harmony export */   recording: () => (/* reexport safe */ _extensions_mjs__WEBPACK_IMPORTED_MODULE_13__.recording),
/* harmony export */   shortcuts: () => (/* reexport safe */ _extensions_mjs__WEBPACK_IMPORTED_MODULE_13__.shortcuts),
/* harmony export */   useBoothStore: () => (/* reexport safe */ _store_mjs__WEBPACK_IMPORTED_MODULE_14__.useBoothStore)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");
/* harmony import */ var _lqv_playback_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lqv/playback/react */ "./node_modules/@lqv/playback/dist/esm/react.mjs");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! zustand */ "./node_modules/zustand/esm/react.mjs");
/* harmony import */ var _extensions_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./extensions.mjs */ "./node_modules/@lqv/codebooth/dist/esm/extensions.mjs");
/* harmony import */ var _store_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./store.mjs */ "./node_modules/@lqv/codebooth/dist/esm/store.mjs");
/* harmony import */ var _components_buttons_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/buttons.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/buttons.mjs");
/* harmony import */ var _components_Console_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/Console.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/Console.mjs");
/* harmony import */ var _components_Editor_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/Editor.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/Editor.mjs");
/* harmony import */ var _components_EditorGroup_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/EditorGroup.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/EditorGroup.mjs");
/* harmony import */ var _components_EditorPanel_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/EditorPanel.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/EditorPanel.mjs");
/* harmony import */ var _components_FileTabs_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/FileTabs.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/FileTabs.mjs");
/* harmony import */ var _components_Record_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/Record.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/Record.mjs");
/* harmony import */ var _components_Replay_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/Replay.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/Replay.mjs");
/* harmony import */ var _components_Resize_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/Resize.mjs */ "./node_modules/@lqv/codebooth/dist/esm/components/Resize.mjs");








// buttons











/**
 * Container for code editing/recording/replaying.
 */
const CodeBooth = ({ children, className, recorder, ...attrs }) => {
    const store = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();
    if (!store.current) {
        store.current = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_14__.makeStore)({ recorder });
    }
    const stateClassNames = (0,zustand__WEBPACK_IMPORTED_MODULE_15__.useStore)(store.current, (state) => state.classNames);
    /* render */
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: classnames__WEBPACK_IMPORTED_MODULE_2__(stateClassNames, className), "data-affords": "click", ...attrs, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_store_mjs__WEBPACK_IMPORTED_MODULE_14__.BoothStore.Provider, { value: store.current, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_lqv_playback_react__WEBPACK_IMPORTED_MODULE_1__.PlaybackContext.Provider, { value: (0,_lqv_playback_react__WEBPACK_IMPORTED_MODULE_1__.useME)(), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(KeyboardShortcuts, {}), children] }) }) }));
};
function KeyboardShortcuts() {
    const store = (0,_store_mjs__WEBPACK_IMPORTED_MODULE_14__.useBoothStore)();
    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {
        // this is somewhat wasteful but oh well
        function reconfigure() {
            const state = store.getState();
            for (const groupName in state.groups) {
                for (const { view } of state.groups[groupName].files) {
                    view.dispatch({
                        effects: _extensions_mjs__WEBPACK_IMPORTED_MODULE_13__.shortcuts.reconfigure([
                            _codemirror_view__WEBPACK_IMPORTED_MODULE_16__.keymap.of(Object.values(state.shortcuts)),
                        ]),
                    });
                }
            }
        }
        const unsubs = [];
        // update with new shortcuts
        unsubs.push(store.subscribe((state) => state.shortcuts, reconfigure));
        // update with new editors
        unsubs.push(store.subscribe((state) => state.groups, reconfigure));
        return () => {
            for (const unsub of unsubs) {
                unsub();
            }
        };
    }, [store]);
    return null;
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/store.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/store.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BoothStore: () => (/* binding */ BoothStore),
/* harmony export */   makeStore: () => (/* binding */ makeStore),
/* harmony export */   useBoothStore: () => (/* binding */ useBoothStore)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ "./node_modules/zustand/esm/vanilla.mjs");
/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ "./node_modules/zustand/esm/middleware.mjs");
"use client";



// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
const makeStore = (state = {}) => (0,zustand__WEBPACK_IMPORTED_MODULE_1__.createStore)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.subscribeWithSelector)((_set, get) => ({
    // default values
    activeGroup: undefined,
    classNames: ["lqv-codebooth"],
    getActiveFile() {
        const state = get();
        const group = state.groups[state.activeGroup];
        return group?.files?.find((_) => _.filename === group.activeFile);
    },
    getActiveView() {
        return get().getActiveFile().view;
    },
    groups: {},
    messages: [],
    recorder: undefined,
    run: 0,
    shortcuts: {},
    ...state,
})));
const BoothStore = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
/** Get a reference to the Zustand store for this CodeBooth. See {@link State} for store shape. */
function useBoothStore() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BoothStore);
}


/***/ }),

/***/ "./node_modules/@lqv/codebooth/dist/esm/utils.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lqv/codebooth/dist/esm/utils.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ids: () => (/* binding */ ids),
/* harmony export */   sanitize: () => (/* binding */ sanitize)
/* harmony export */ });
/**
 * Sanitize a string for use as a CSS class or ID
 */
function sanitize(str) {
    return str.replace(/[^A-Za-z0-9_-]/g, "_");
}
const ids = {
    fileTab: ({ filename, group }) => `lqv-tab-${group}-${sanitize(filename)}`,
    groupTab: ({ group }) => `lqv-grouptab-${group}`,
    editorGroup: ({ group }) => `lqv-group-${group}`,
    editorPanel: ({ filename, group }) => `lqv-panel-${group}-${sanitize(filename)}`,
};


/***/ }),

/***/ "./node_modules/@lqv/codemirror/dist/esm/extensions.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lqv/codemirror/dist/esm/extensions.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   passThrough: () => (/* binding */ passThrough)
/* harmony export */ });
/* harmony import */ var _liqvid_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liqvid/keymap */ "./node_modules/@liqvid/keymap/dist/esm/index.mjs");

/**
 * Handle key sequences in `seqs` even if key capture is suspended.
 * @param keymap {@link Keymap} to handle key sequences.
 * @param seqs Key sequences to handle.
 */
function passThrough(keymap, seqs = []) {
    return seqs.map((key) => {
        const can = cm2lv(key);
        // argh
        const fake = typeof window === "undefined" ? null : new KeyboardEvent("keydown");
        return {
            key,
            run: () => {
                const handlers = keymap.getHandlers(can);
                for (const cb of handlers) {
                    cb(fake);
                }
                return false;
            },
        };
    });
}
/**
 * Convert CodeMirror key sequences to Liqvid format.
 */
function cm2lv(seq) {
    const isMac = typeof globalThis.navigator !== "undefined" &&
        navigator.platform === "MacIntel";
    // biome-ignore lint/style/noParameterAssign: this is fine
    seq = seq.replace("Mod", isMac ? "Meta" : "Ctrl");
    // biome-ignore lint/style/noParameterAssign: this is fine
    seq = seq.replace(/-/g, "+");
    return _liqvid_keymap__WEBPACK_IMPORTED_MODULE_0__.Keymap.normalize(seq);
}


/***/ }),

/***/ "./node_modules/@lqv/codemirror/dist/esm/fake-selection.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lqv/codemirror/dist/esm/fake-selection.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FakeSelection: () => (/* binding */ FakeSelection),
/* harmony export */   fakeSelection: () => (/* binding */ fakeSelection),
/* harmony export */   getDrawFakeSelectionConfig: () => (/* binding */ getDrawFakeSelectionConfig)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.js");


const FakeSelection = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();
const fakeSelectionConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.combineConfig)(configs, {
            cursorBlinkRate: 1200,
            cursorStyle: "block",
            drawRangeCursor: true,
        }, {
            cursorBlinkRate: (a, b) => a ?? b,
            cursorStyle: (a, b) => a ?? b,
            drawRangeCursor: (a, b) => a ?? b,
        });
    },
});
/**
 * CodeMirror extension to imitate selections in replay.
 */
function fakeSelection(config = {}) {
    return [
        fakeSelectionConfig.of(config),
        fakeCursorLayer,
        fakeSelectionLayer,
        style,
    ];
}
/// Retrieve the [`drawSelection`](#view.drawSelection) configuration
/// for this state. (Note that this will return a set of defaults even
/// if `drawSelection` isn't enabled.)
function getDrawFakeSelectionConfig(state) {
    return state.facet(fakeSelectionConfig);
}
function configChanged(update) {
    return (update.startState.facet(fakeSelectionConfig) !==
        update.state.facet(fakeSelectionConfig));
}
const fakeCursorLayer = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.layer)({
    above: true,
    markers(view) {
        const { state } = view;
        const conf = state.facet(fakeSelectionConfig);
        const cursors = [];
        if (!this.range)
            return [];
        for (const r of [this.range]) {
            if (r.empty || conf.drawRangeCursor) {
                const className = conf.cursorStyle === "block"
                    ? "lqv-fakeCursorBlock"
                    : "lqv-fakeCursorColumn";
                const cursor = r.empty
                    ? r
                    : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
                for (const piece of _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.RectangleMarker.forRange(view, className, cursor))
                    cursors.push(piece);
            }
        }
        return cursors;
    },
    update(update, dom) {
        const effects = update.transactions
            .map((tr) => tr.effects.filter((e) => e.is(FakeSelection)))
            .reduce((a, b) => a.concat(b), []);
        const confChange = configChanged(update);
        if (confChange)
            setBlinkRate(update.state, dom);
        if (effects.length === 0) {
            return update.docChanged || update.selectionSet || confChange;
        }
        if (effects.length > 0) {
            dom.style.animationName =
                dom.style.animationName === "lqv-blink" ? "lqv-blink2" : "lqv-blink";
            this.range = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange.fromJSON(effects[effects.length - 1].value);
            return true;
        }
    },
    mount(dom, view) {
        setBlinkRate(view.state, dom);
    },
    class: "lqv-fakeCursorLayer",
});
function setBlinkRate(state, dom) {
    dom.style.animationDuration = `${state.facet(fakeSelectionConfig).cursorBlinkRate}ms`;
}
const fakeSelectionLayer = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.layer)({
    above: false,
    markers(view) {
        if (!this.range) {
            return [];
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.RectangleMarker.forRange(view, "lqv-fakeSelectionBackground", this.range);
    },
    update(update) {
        const effects = update.transactions
            .map((tr) => tr.effects.filter((e) => e.is(FakeSelection)))
            .reduce((a, b) => a.concat(b), []);
        if (effects.length === 0) {
            return (update.docChanged ||
                update.selectionSet ||
                update.viewportChanged ||
                configChanged(update));
        }
        if (effects.length > 0) {
            this.range = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange.fromJSON(effects[effects.length - 1].value);
            return true;
        }
    },
    class: "lqv-fakeSelectionLayer",
});
const themeSpec = {
    ".lqv-fakeSelectionBackground": {
        background: "#d7d4f0",
    },
    ".lqv-fakeCursorLayer": {
        animation: "steps(1) lqv-blink 1.2s infinite",
        pointerEvents: "none",
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes lqv-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes lqv-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".lqv-fakeCursorBlock": {
        background: "#f00a",
        width: "1ch",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
    ".lqv-fakeCursorColumn": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
};
const style = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Prec.highest(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme(themeSpec));


/***/ }),

/***/ "./node_modules/@lqv/codemirror/dist/esm/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@lqv/codemirror/dist/esm/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cmReplay: () => (/* binding */ cmReplay),
/* harmony export */   cmReplayMultiple: () => (/* binding */ cmReplayMultiple),
/* harmony export */   defaultViewName: () => (/* binding */ defaultViewName),
/* harmony export */   fakeSelection: () => (/* reexport safe */ _fake_selection_mjs__WEBPACK_IMPORTED_MODULE_0__.fakeSelection),
/* harmony export */   scrollCmd: () => (/* binding */ scrollCmd),
/* harmony export */   selectCmd: () => (/* binding */ selectCmd)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.js");
/* harmony import */ var _fake_selection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fake-selection.mjs */ "./node_modules/@lqv/codemirror/dist/esm/fake-selection.mjs");



/** Reserved command for specifying file. */
const selectCmd = "file:";
/** Reserved string for specifying scroll actions. */
const scrollCmd = "s";
/** Key for the default view (in single-file mode). */
const defaultViewName = "default";
/**
 * Replay typing in CodeMirror.
 * @returns Unsubscription function.
 */
function cmReplay({ data, handle, playback, scrollBehavior, didScroll, shouldScroll = () => true, start, view, }) {
    return cmReplayMultiple({
        data: [[0, selectCmd + defaultViewName], ...data],
        handle: (key, docs) => handle(key, docs.default),
        playback,
        scrollBehavior,
        didScroll: (_filename, scrollToOptions) => {
            didScroll?.(scrollToOptions);
        },
        shouldScroll,
        start,
        views: {
            [defaultViewName]: view,
        },
    });
}
/**
 * Replay typing to several CodeMirror instances in parallel.
 * @returns Unsubscription function.
 */
function cmReplayMultiple({ data, didScroll, handle, playback, scrollBehavior = "auto", shouldScroll = () => true, start = 0, views, }) {
    /** Current file being replayed into */
    let file = undefined;
    // validation
    if (!(data.length > 0 &&
        data[0][0] === 0 &&
        typeof data[0][1] === "string" &&
        data[0][1].startsWith(selectCmd))) {
        throw new Error("First command must have time 0 and select the file");
    }
    // we're going to mess with data, clone it
    data = JSON.parse(JSON.stringify(data));
    /* unpackage */
    // decompress times
    const times = data.map((_) => _[0]);
    for (let i = 1; i < times.length; ++i)
        times[i] += times[i - 1];
    // deserialize changesets
    for (const [, action] of data) {
        // changeset
        if (Array.isArray(action) && Array.isArray(action[0])) {
            action[0] = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(action[0]);
        }
    }
    // for scrolling in legacy recordings
    const hasScroll = {};
    for (const key in views) {
        hasScroll[key] = false;
    }
    // initialize inverses
    const inverses = {};
    const lastScroll = {};
    for (const key in views) {
        inverses[key] = [];
        lastScroll[key] = [0, 0];
    }
    // compute inverses
    {
        const docs = {};
        for (const key in views) {
            docs[key] = views[key].state.doc;
        }
        for (let i = 0; i < data.length; ++i) {
            const action = data[i][1];
            if (Array.isArray(action)) {
                if (action[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet) {
                    // editor change
                    inverses[file][i] = action[0].invert(docs[file]);
                    docs[file] = action[0].apply(docs[file]);
                }
                else if (action[0] === scrollCmd) {
                    // scroll
                    hasScroll[file] = true;
                    inverses[file][i] = lastScroll[file];
                    lastScroll[file] = [action[1], action[2] ?? 0];
                }
            }
            else if (action.startsWith(selectCmd)) {
                file = action.slice(selectCmd.length);
            }
        }
    }
    /* main logic */
    let index = 0;
    let lastTime = 0;
    const repaint = () => {
        const t = playback.currentTime;
        const progress = (t - start) * 1000;
        const changes = {};
        for (const key in views) {
            changes[key] = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.empty(views[key].state.doc.length);
        }
        const selections = {};
        // apply / revert changes
        if (lastTime <= t && index < data.length) {
            // forward
            let i = index;
            for (; i < data.length && times[i] <= progress; ++i) {
                const action = data[i][1];
                if (typeof action === "string") {
                    if (action.startsWith(selectCmd)) {
                        file = action.slice(selectCmd.length);
                    }
                    // handle action
                    const docs = {};
                    for (const key in views) {
                        docs[key] = changes[key].apply(views[key].state.doc);
                    }
                    handle(action, docs);
                }
                else {
                    if (action[0] === scrollCmd) {
                        if (shouldScroll(file)) {
                            // scroll
                            const [, y, x = 0] = action;
                            const fontSize = getFontSize(views[file]);
                            if (!Number.isNaN(fontSize)) {
                                const scrollToOptions = {
                                    left: x * fontSize,
                                    top: y * fontSize,
                                    behavior: scrollBehavior,
                                };
                                views[file].scrollDOM.scrollTo(scrollToOptions);
                                didScroll?.(file, scrollToOptions);
                            }
                        }
                    }
                    else {
                        // editor change
                        changes[file] = changes[file].compose(action[0]);
                        // handle selection
                        if (action[1]) {
                            const [anchor, head] = action[1];
                            selections[file] = { anchor, head };
                        }
                    }
                }
            }
            index = i;
        }
        else if (t < lastTime && 0 < index) {
            // revert
            let i = index - 1;
            for (; 0 <= i && progress < times[i]; --i) {
                if (inverses[file][i]) {
                    const inverse = inverses[file][i];
                    // editor change
                    if (inverse instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet) {
                        changes[file] = changes[file].compose(inverses[file][i]);
                    }
                    // scroll
                    else if (inverses[file][i].length === 2) {
                        if (shouldScroll(file)) {
                            const [y, x] = inverses[file][i];
                            const fontSize = getFontSize(views[file]);
                            if (!Number.isNaN(fontSize)) {
                                const scrollToOptions = {
                                    left: x * fontSize,
                                    top: y * fontSize,
                                    behavior: scrollBehavior,
                                };
                                views[file].scrollDOM.scrollTo(scrollToOptions);
                                didScroll?.(file, scrollToOptions);
                            }
                        }
                    }
                }
                else if (data[i][1] === selectCmd + file) {
                    // find file to replay into
                    for (let j = i - 1; 0 <= j; --j) {
                        const action = data[j][1];
                        if (typeof action === "string" && action.startsWith(selectCmd)) {
                            file = action.slice(selectCmd.length);
                            // XXX figure out how to handle more general actions
                            handle(action, {});
                            break;
                        }
                    }
                }
            }
            index = i + 1;
        }
        for (const key in views) {
            const effects = selections[key]
                ? [_fake_selection_mjs__WEBPACK_IMPORTED_MODULE_0__.FakeSelection.of(selections[key])]
                : undefined;
            const view = views[key];
            view.dispatch(view.state.update({
                changes: changes[key],
                effects,
            }));
            // scrolling for legacy recordings
            const scrollIntoView = !hasScroll[key] && shouldScroll(key);
            if (scrollIntoView) {
                // get position of last change
                let pos;
                changes[key].iterChangedRanges((_fromA, _toA, _fromB, toB) => {
                    pos = toB;
                });
                // changes can be empty
                if (pos === undefined) {
                    return;
                }
                const { scrollDOM } = view;
                const rect = scrollDOM.getBoundingClientRect();
                // it isn't possible to measure things that are offscreen
                const line = view.state.doc.lineAt(pos);
                const wordTop = view.defaultLineHeight * (line.number - 1);
                if (wordTop < scrollDOM.scrollTop) {
                    const scrollToOptions = {
                        behavior: scrollBehavior,
                        top: wordTop,
                    };
                    scrollDOM.scrollTo(scrollToOptions);
                    didScroll?.(key, scrollToOptions);
                }
                else if (wordTop > scrollDOM.scrollTop + rect.height) {
                    const scrollToOptions = {
                        behavior: scrollBehavior,
                        top: wordTop - rect.height + view.defaultLineHeight,
                    };
                    scrollDOM.scrollTo(scrollToOptions);
                    didScroll?.(key, scrollToOptions);
                }
            }
        }
        lastTime = t;
    };
    /* subscribe */
    playback.addEventListener("seeking", repaint);
    playback.addEventListener("timeupdate", repaint);
    return () => {
        playback.removeEventListener("seeking", repaint);
        playback.removeEventListener("timeupdate", repaint);
    };
}
/** Get the fontSize of a view's scrollDOM. */
function getFontSize(view) {
    return Number.parseFloat(getComputedStyle(view.scrollDOM).fontSize);
}


/***/ }),

/***/ "./node_modules/@lqv/playback/dist/esm/hack.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@lqv/playback/dist/esm/hack.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlaybackMEProxy: () => (/* binding */ PlaybackMEProxy)
/* harmony export */ });
/** Hack to make Liqvid behave like {@link MediaElement}. */
const PlaybackMEProxy = {
    get(target, p) {
        switch (p) {
            case "currentTime":
                return target.currentTime / 1000;
            case "duration":
                return target.duration / 1000;
            case "addEventListener":
                return (type, listener) => {
                    switch (type) {
                        case "seeking":
                            return target.on("seek", listener);
                        default:
                            return target.on(type, listener);
                    }
                };
            case "removeEventListener":
                return (type, listener) => {
                    switch (type) {
                        case "seeking":
                            return target.off("seek", listener);
                        default:
                            return target.off(type, listener);
                    }
                };
            default:
                return target[p];
        }
    },
    set(target, p, value) {
        switch (p) {
            case "currentTime":
                target.seek(value * 1000);
                break;
            case "duration":
                target.duration = value * 1000;
                break;
            default:
                target[p] = value;
        }
        return true;
    },
    // this is important so that we don't Proxy our Proxy
    has(target, p) {
        switch (p) {
            case "currentTime":
            case "duration":
            case "muted":
            case "pause":
            case "paused":
            case "play":
            case "playbackRate":
            case "seeking":
            case "volume":
            case "addEventListener":
            case "removeEventListener":
                return true;
            default:
                return false;
        }
    },
};


/***/ }),

/***/ "./node_modules/@lqv/playback/dist/esm/react.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@lqv/playback/dist/esm/react.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlaybackContext: () => (/* binding */ PlaybackContext),
/* harmony export */   useME: () => (/* binding */ useME),
/* harmony export */   usePlayback: () => (/* binding */ usePlayback),
/* harmony export */   useTime: () => (/* binding */ useTime)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _hack_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hack.mjs */ "./node_modules/@lqv/playback/dist/esm/hack.mjs");
"use client";


const symbol = Symbol.for("@lqv/playback");
if (!(symbol in globalThis)) {
    globalThis[symbol] = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
}
/**
 * Access the ambient {@link MediaElement}
 */
function useME() {
    const playback = usePlayback();
    // do not use playback.constructor.name === "Playback"
    // because minimization can mangle that
    if (playback && "__advance" in playback) {
        return new Proxy(usePlayback(), _hack_mjs__WEBPACK_IMPORTED_MODULE_1__.PlaybackMEProxy);
    }
    return playback;
}
/**
 * {@link React.Context} used to access ambient {@link MediaElement} or (deprecated) {@link Playback}
 */
const PlaybackContext = globalThis[symbol];
PlaybackContext.displayName = "Playback";
/**
 * Access the ambient {@link Playback}.
 *
 * @deprecated This function is only kept for backwards compatibility with
 * Liqvid. New code should target the {@link MediaElement} interface. You
 * probably want {@link useME}.
 */
function usePlayback() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PlaybackContext);
}
function useTime(callback, transform, deps) {
    const playback = useME();
    const prev = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        const listener = typeof transform === "function"
            ? () => {
                const value = transform(playback.currentTime);
                if (value !== prev.current)
                    callback(value);
                prev.current = value;
            }
            : () => {
                const t = playback.currentTime;
                if (t !== prev.current)
                    callback(t);
                prev.current = t;
            };
        // subscriptions
        playback.addEventListener("seeking", listener);
        playback.addEventListener("timeupdate", listener);
        // initial call
        listener();
        // unsubscriptions
        return () => {
            playback.removeEventListener("seeking", listener);
            playback.removeEventListener("timeupdate", listener);
        };
    }, typeof transform === "function" ? deps : transform);
}


/***/ }),

/***/ "./node_modules/@marijn/find-cluster-break/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@marijn/find-cluster-break/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),
/* harmony export */   isExtendingChar: () => (/* binding */ isExtendingChar)
/* harmony export */ });
let rangeFrom = [], rangeTo = [];
(() => {
    let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
    for (let i = 0, n = 0; i < numbers.length; i++)
        (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i]);
})();
function isExtendingChar(code) {
    if (code < 768)
        return false;
    for (let from = 0, to = rangeFrom.length;;) {
        let mid = (from + to) >> 1;
        if (code < rangeFrom[mid])
            to = mid;
        else if (code >= rangeTo[mid])
            from = mid + 1;
        else
            return true;
        if (from == to)
            return false;
    }
}
function isRegionalIndicator(code) {
    return code >= 0x1F1E6 && code <= 0x1F1FF;
}
function check(code) {
    for (let i = 0; i < rangeFrom.length; i++) {
        if (rangeTo[i] > code)
            return rangeFrom[i] <= code;
    }
    return false;
}
const ZWJ = 0x200d;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
        return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
        pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
        let next = codePointAt(str, pos);
        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
        }
        else if (isRegionalIndicator(next)) {
            let countBefore = 0, i = pos - 2;
            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
                countBefore++;
                i -= 2;
            }
            if (countBefore % 2 == 0)
                break;
            else
                pos += 2;
        }
        else {
            break;
        }
    }
    return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
        let found = nextClusterBreak(str, pos - 2, includeExtending);
        if (found < pos)
            return found;
        pos--;
    }
    return 0;
}
function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
        return code0;
    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
}
function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
function codePointSize(code) { return code < 0x10000 ? 1 : 2; }


/***/ }),

/***/ "./node_modules/bezier-easing/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/bezier-easing/src/index.js ***!
  \*************************************************/
/***/ ((module) => {


var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === 'function';
function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C(aA1) { return 3.0 * aA1; }
function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }
function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        }
        else {
            aA = currentT;
        }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
function LinearEasing(x) {
    return x;
}
module.exports = function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
    }
    if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
    }
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        }
        else if (initialSlope === 0.0) {
            return guessForT;
        }
        else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function BezierEasing(x) {
        if (x === 0) {
            return 0;
        }
        if (x === 1) {
            return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
};


/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
/*!
    Copyright (c) 2018 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
*/
(function () {
    'use strict';
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
        var classes = '';
        for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
                classes = appendClass(classes, parseValue(arg));
            }
        }
        return classes;
    }
    function parseValue(arg) {
        if (typeof arg === 'string' || typeof arg === 'number') {
            return arg;
        }
        if (typeof arg !== 'object') {
            return '';
        }
        if (Array.isArray(arg)) {
            return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
            return arg.toString();
        }
        var classes = '';
        for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
                classes = appendClass(classes, key);
            }
        }
        return classes;
    }
    function appendClass(value, newClass) {
        if (!newClass) {
            return value;
        }
        if (value) {
            return value + ' ' + newClass;
        }
        return value + newClass;
    }
    if ( true && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
    }
    else if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return classNames;
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else // removed by dead control flow
{}
}());


/***/ }),

/***/ "./node_modules/crelt/index.js":
/*!*************************************!*\
  !*** ./node_modules/crelt/index.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ crelt)
/* harmony export */ });
function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string")
        elt = document.createElement(elt);
    var i = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
        for (var name in next)
            if (Object.prototype.hasOwnProperty.call(next, name)) {
                var value = next[name];
                if (typeof value == "string")
                    elt.setAttribute(name, value);
                else if (value != null)
                    elt[name] = value;
            }
        i++;
    }
    for (; i < arguments.length; i++)
        add(elt, arguments[i]);
    return elt;
}
function add(elt, child) {
    if (typeof child == "string") {
        elt.appendChild(document.createTextNode(child));
    }
    else if (child == null) {
    }
    else if (child.nodeType != null) {
        elt.appendChild(child);
    }
    else if (Array.isArray(child)) {
        for (var i = 0; i < child.length; i++)
            add(elt, child[i]);
    }
    else {
        throw new RangeError("Unsupported child node: " + child);
    }
}


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function'
    ? R.apply
    : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
    };
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
}
else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target)
            .concat(Object.getOwnPropertySymbols(target));
    };
}
else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
    };
}
function ProcessEmitWarning(warning) {
    if (console && console.warn)
        console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function () {
        return defaultMaxListeners;
    },
    set: function (arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function () {
    if (this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
    var doError = (type === 'error');
    var events = this._events;
    if (events !== undefined)
        doError = (doError && events.error === undefined);
    else if (!doError)
        return false;
    if (doError) {
        var er;
        if (args.length > 0)
            er = args[0];
        if (er instanceof Error) {
            throw er;
        }
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err;
    }
    var handler = events[type];
    if (handler === undefined)
        return false;
    if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
    }
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    }
    else {
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        existing = events[type] = listener;
        ++target._eventsCount;
    }
    else {
        if (typeof existing === 'function') {
            existing = events[type] =
                prepend ? [listener, existing] : [existing, listener];
        }
        else if (prepend) {
            existing.unshift(listener);
        }
        else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                existing.length + ' ' + String(type) + ' listeners ' +
                'added. Use emitter.setMaxListeners() to ' +
                'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
    };
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
            return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
    };
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === undefined)
            return this;
        list = events[type];
        if (list === undefined)
            return this;
        if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
                this._events = Object.create(null);
            else {
                delete events[type];
                if (events.removeListener)
                    this.emit('removeListener', type, list.listener || listener);
            }
        }
        else if (typeof list !== 'function') {
            position = -1;
            for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                }
            }
            if (position < 0)
                return this;
            if (position === 0)
                list.shift();
            else {
                spliceOne(list, position);
            }
            if (list.length === 1)
                events[type] = list[0];
            if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener);
        }
        return this;
    };
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === undefined)
            return this;
        if (events.removeListener === undefined) {
            if (arguments.length === 0) {
                this._events = Object.create(null);
                this._eventsCount = 0;
            }
            else if (events[type] !== undefined) {
                if (--this._eventsCount === 0)
                    this._events = Object.create(null);
                else
                    delete events[type];
            }
            return this;
        }
        if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
                key = keys[i];
                if (key === 'removeListener')
                    continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
        }
        listeners = events[type];
        if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
        }
        else if (listeners !== undefined) {
            for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i]);
            }
        }
        return this;
    };
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined)
        return [];
    var evlistener = events[type];
    if (evlistener === undefined)
        return [];
    if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ?
        unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
    }
    else {
        return listenerCount.call(emitter, type);
    }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') {
            return 1;
        }
        else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
    }
    return ret;
}
function once(emitter, name) {
    return new Promise(function (resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') {
                emitter.removeListener('error', errorListener);
            }
            resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== 'error') {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) {
            emitter.once(name, listener);
        }
        else {
            emitter.on(name, listener);
        }
    }
    else if (typeof emitter.addEventListener === 'function') {
        emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
        });
    }
    else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/Audio.mjs":
/*!************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/Audio.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Audio: () => (/* binding */ Audio)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _Media_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Media.mjs */ "./node_modules/liqvid/dist/esm/Media.mjs");
/* harmony import */ var _utils_dom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/dom.mjs */ "./node_modules/liqvid/dist/esm/utils/dom.mjs");



/** Liqvid equivalent of {@link HTMLAudioElement `<audio>`}. */
class Audio extends _Media_mjs__WEBPACK_IMPORTED_MODULE_1__.Media {
    componentDidMount() {
        super.componentDidMount();
        // tracks
        for (const track of Array.from(this.domElement.textTracks)) {
            if (!["captions", "subtitles"].includes(track.kind))
                continue;
            let mode = track.mode;
            track.addEventListener("cuechange", () => {
                if (track.mode !== "showing") {
                    if (mode === "showing")
                        this.playback.captions = [];
                    mode = track.mode;
                    return;
                }
                mode = track.mode;
                const captions = [];
                for (const cue of Array.from(track.activeCues)) {
                    // @ts-expect-error check this I guess
                    const html = cue.text.replace(/\n/g, "<br/>");
                    captions.push((0,_utils_dom_mjs__WEBPACK_IMPORTED_MODULE_2__.fragmentFromHTML)(html));
                }
                this.playback.captions = captions;
            });
        }
    }
    // render method
    render() {
        const { start, obstructCanPlay, obstructCanPlayThrough, children, ...attrs } = this.props;
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("audio", { preload: "auto", ref: (node) => (this.domElement = node), ...attrs }, children));
    }
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/CaptionsDisplay.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/CaptionsDisplay.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Captions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/playback/react */ "./node_modules/@liqvid/playback/dist/esm/react.mjs");



function Captions() {
    const playback = (0,_liqvid_playback_react__WEBPACK_IMPORTED_MODULE_1__.usePlayback)();
    const domElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        const updateCaptions = () => {
            domElement.current.innerHTML = "";
            for (const cue of playback.captions) {
                domElement.current.appendChild(cue);
            }
        };
        playback.on("cuechange", updateCaptions);
        return () => {
            playback.off("cuechange", updateCaptions);
        };
    }, [playback]);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-captions-display", ref: domElement });
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/Controls.mjs":
/*!***************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/Controls.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controls)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _controls_ScrubberBar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controls/ScrubberBar.mjs */ "./node_modules/liqvid/dist/esm/controls/ScrubberBar.mjs");
/* harmony import */ var _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/keymap/react */ "./node_modules/@liqvid/keymap/dist/esm/react.mjs");
/* harmony import */ var _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liqvid/playback/react */ "./node_modules/@liqvid/playback/dist/esm/react.mjs");
/* harmony import */ var _Player_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Player.mjs */ "./node_modules/liqvid/dist/esm/Player.mjs");






// hiding timeout
const TIMEOUT = 3000;
function Controls(props) {
    const keymap = (0,_liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_3__.useKeymap)();
    const playback = (0,_liqvid_playback_react__WEBPACK_IMPORTED_MODULE_4__.usePlayback)();
    const [visible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);
    const timer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);
    // reset the hiding timer
    const resetTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
        if (playback.paused)
            return;
        if (timer.current !== undefined)
            clearTimeout(timer.current);
        timer.current = window.setTimeout(() => setVisible(false), TIMEOUT);
        setVisible(true);
    }, [playback]);
    // mount subscriptions
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        // hide on keyboard input
        keymap.bind("*", resetTimer);
        // show/hiding
        document.body.addEventListener("touchstart", resetTimer);
        document.body.addEventListener("mousemove", resetTimer);
        playback.on("play", resetTimer);
        playback.on("pause", () => {
            clearTimeout(timer.current);
            setVisible(true);
        });
        playback.on("stop", () => {
            clearTimeout(timer.current);
            setVisible(true);
        });
        document.body.addEventListener("mouseleave", () => {
            if (playback.paused)
                return;
            setVisible(false);
        });
    }, [keymap, playback, resetTimer]);
    const classNames = ["rp-controls", "lv-controls"];
    if (!visible)
        classNames.push("hidden");
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: classNames.join(" ") },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_controls_ScrubberBar_mjs__WEBPACK_IMPORTED_MODULE_1__.ScrubberBar, { thumbs: props.thumbs }),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-buttons" }, props.controls instanceof Array ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            _Player_mjs__WEBPACK_IMPORTED_MODULE_2__.Player.defaultControlsLeft,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-right" },
                ...props.controls,
                _Player_mjs__WEBPACK_IMPORTED_MODULE_2__.Player.defaultControlsRight))) : (props.controls))));
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/IdMap.mjs":
/*!************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/IdMap.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IdMap: () => (/* binding */ IdMap)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");



/**
 * This class gives a way to automagically attach data loaded from a file as attributes on elements.
 * This is provided to facilitate the development of—and provide a standard interface for—GUI tools.
 */
class IdMap extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
    static Context = react__WEBPACK_IMPORTED_MODULE_0__.createContext([]);
    /** IDs found within the IdMap */
    foundIds;
    constructor(props) {
        super(props);
        (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_1__.bind)(this, ["renderContent"]);
        this.foundIds = new Set();
    }
    render() {
        if (this.props.hasOwnProperty("map")) {
            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(IdMap.Context.Provider, { value: [this.foundIds, this.props.map] }, this.renderContent([this.foundIds, this.props.map])));
        }
        else {
            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(IdMap.Context.Consumer, null, this.renderContent));
        }
    }
    renderContent([foundIds, map]) {
        return (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.recursiveMap)(this.props.children, (node) => {
            const attrs = {};
            if (node.props.hasOwnProperty("id")) {
                const { id } = node.props;
                foundIds.add(id);
                // biome-ignore lint/suspicious/noExplicitAny: <explanation>
                if (map[id] !== undefined)
                    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
                    Object.assign(attrs, map[id]);
            }
            if (Object.keys(attrs).length === 0) {
                return node;
            }
            else {
                return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(node, attrs);
            }
        });
    }
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/Media.mjs":
/*!************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/Media.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Media: () => (/* binding */ Media)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _utils_media_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/media.mjs */ "./node_modules/liqvid/dist/esm/utils/media.mjs");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _Player_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Player.mjs */ "./node_modules/liqvid/dist/esm/Player.mjs");




class Media extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
    playback;
    player;
    domElement;
    /** When the media element should start playing. */
    start;
    static defaultProps = {
        obstructCanPlay: false,
        obstructCanPlayThrough: false,
    };
    static contextType = _Player_mjs__WEBPACK_IMPORTED_MODULE_2__.Player.Context;
    constructor(props, context) {
        super(props, context);
        this.player = context;
        this.playback = context.playback;
        // get the time right
        this.start = this.props.start ?? 0;
        (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__.bind)(this, [
            "pause",
            "play",
            "onPlay",
            "onRateChange",
            "onSeek",
            "onTimeUpdate",
            "onVolumeChange",
            "onDomPlay",
            "onDomPause",
        ]);
    }
    componentDidMount() {
        // attach event listeners
        this.playback.on("pause", this.pause);
        this.playback.on("play", this.onPlay);
        this.playback.on("ratechange", this.onRateChange);
        this.playback.on("seek", this.onSeek);
        this.playback.on("seeking", this.pause);
        this.playback.on("timeupdate", this.onTimeUpdate);
        this.playback.on("volumechange", this.onVolumeChange);
        this.domElement.addEventListener("play", this.onDomPlay);
        this.domElement.addEventListener("pause", this.onDomPause);
        // canplay/canplaythrough events
        if (this.props.obstructCanPlay) {
            this.player.obstruct("canplay", (0,_utils_media_mjs__WEBPACK_IMPORTED_MODULE_1__.awaitMediaCanPlay)(this.domElement));
        }
        if (this.props.obstructCanPlayThrough) {
            this.player.obstruct("canplaythrough", (0,_utils_media_mjs__WEBPACK_IMPORTED_MODULE_1__.awaitMediaCanPlayThrough)(this.domElement));
        }
        // need to call this once initially
        this.onVolumeChange();
        // progress updater?
        /*const getBuffers = () => {
          const ranges = this.domElement.buffered;
    
          const buffers: [number, number][] = [];
          for (let i = 0; i < ranges.length; ++i) {
            if (ranges.end(i) === Infinity) continue;
            buffers.push([ranges.start(i) * 1000 + this.start, ranges.end(i) * 1000 + this.start]);
          }
    
          return buffers;
        };
    
        const updateBuffers = () => {
          this.player.updateBuffer(this.domElement, getBuffers());
        };
    
        this.player.registerBuffer(this.domElement);
        updateBuffers();
        this.domElement.addEventListener("progress", updateBuffers);
        // setInterval(updateBuffers, 1000);
        // this.domElement.addEventListener('load', updateBuffers);
        */
    }
    componentWillUnmount() {
        this.playback.off("pause", this.pause);
        this.playback.off("play", this.onPlay);
        this.playback.off("ratechange", this.onRateChange);
        this.playback.off("seek", this.onSeek);
        this.playback.off("seeking", this.pause);
        this.playback.off("timeupdate", this.onTimeUpdate);
        this.playback.off("volumechange", this.onVolumeChange);
        this.domElement.removeEventListener("pause", this.onDomPause);
        this.domElement.removeEventListener("play", this.onDomPlay);
        // this.player.unregisterBuffer(this.domElement);
    }
    // getter
    get end() {
        return this.start + this.domElement.duration * 1000;
    }
    pause() {
        if (!this.domElement.ended) {
            this.domElement.removeEventListener("pause", this.onDomPause);
            this.domElement.pause();
            this.domElement.addEventListener("pause", this.onDomPause);
        }
    }
    play() {
        this.domElement.removeEventListener("play", this.onDomPlay);
        const promise = this.domElement.play();
        this.domElement.addEventListener("play", this.onDomPlay);
        return promise;
    }
    onPlay() {
        this.onTimeUpdate(this.playback.currentTime);
    }
    onRateChange() {
        this.domElement.playbackRate = this.playback.playbackRate;
    }
    onSeek(t) {
        this.domElement.currentTime = (t - this.start) / 1000;
        if ((0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__.between)(this.start, t, this.end)) {
            if (this.domElement.paused &&
                !this.playback.paused &&
                !this.playback.seeking) {
                this.play().catch(this.playback.pause);
            }
        }
        else {
            if (!this.domElement.paused)
                this.pause();
        }
    }
    onTimeUpdate(t) {
        if ((0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__.between)(this.start, t, this.end)) {
            if (!this.domElement.paused)
                return;
            this.domElement.currentTime = (t - this.start) / 1000;
            this.play().catch(this.playback.pause);
        }
        else {
            if (!this.domElement.paused)
                this.pause();
            this.domElement.currentTime = (t - this.start) / 1000;
        }
    }
    onVolumeChange() {
        this.domElement.volume = this.playback.volume;
        this.domElement.muted = this.playback.muted;
    }
    onDomPlay() {
        if (this.playback.paused) {
            this.playback.off("play", this.onPlay);
            this.playback.play();
            this.playback.on("play", this.onPlay);
        }
    }
    onDomPause() {
        if (!this.playback.seeking &&
            !this.playback.paused &&
            !hasEnded(this.domElement)) {
            this.playback.off("pause", this.pause);
            this.playback.pause();
            this.playback.on("pause", this.pause);
        }
    }
}
/**
 * Guess whether a media element has ended.
 * (`paused` fires before `ended`, and `currentTime` may be >100ms
 * behind `duration` when this happens).
 * @param media Media element to check.
 * @param threshold How far from the end of the media should be considered "ended".
 * @returns Whether the media element has reached its end.
 */
function hasEnded(media, threshold = 0.5) {
    return media.ended || media.duration - media.currentTime < threshold;
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/Player.mjs":
/*!*************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/Player.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Player: () => (/* binding */ Player)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var _CaptionsDisplay_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CaptionsDisplay.mjs */ "./node_modules/liqvid/dist/esm/CaptionsDisplay.mjs");
/* harmony import */ var _liqvid_keymap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @liqvid/keymap */ "./node_modules/@liqvid/keymap/dist/esm/index.mjs");
/* harmony import */ var _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @liqvid/playback/react */ "./node_modules/@liqvid/playback/dist/esm/react.mjs");
/* harmony import */ var _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @liqvid/keymap/react */ "./node_modules/@liqvid/keymap/dist/esm/react.mjs");
/* harmony import */ var _Controls_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Controls.mjs */ "./node_modules/liqvid/dist/esm/Controls.mjs");
/* harmony import */ var _controls_Captions_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controls/Captions.mjs */ "./node_modules/liqvid/dist/esm/controls/Captions.mjs");
/* harmony import */ var _controls_FullScreen_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./controls/FullScreen.mjs */ "./node_modules/liqvid/dist/esm/controls/FullScreen.mjs");
/* harmony import */ var _controls_PlayPause_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./controls/PlayPause.mjs */ "./node_modules/liqvid/dist/esm/controls/PlayPause.mjs");
/* harmony import */ var _controls_Settings_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./controls/Settings.mjs */ "./node_modules/liqvid/dist/esm/controls/Settings.mjs");
/* harmony import */ var _controls_TimeDisplay_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./controls/TimeDisplay.mjs */ "./node_modules/liqvid/dist/esm/controls/TimeDisplay.mjs");
/* harmony import */ var _controls_Volume_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./controls/Volume.mjs */ "./node_modules/liqvid/dist/esm/controls/Volume.mjs");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @liqvid/utils/interaction */ "./node_modules/@liqvid/utils/dist/esm/interaction.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
















const allowScroll = Symbol();
const ignoreCanvasClick = Symbol();
class Player extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
    /**
     * Liqvid analogue of the [`canplay`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplay_event) event.
     * This can be used to wait for Audio or Video files to load. You can also use {@link obstruct} to add custom loaders.
     */
    canPlay;
    /**
     * Liqvid analogue of the [`canplaythrough`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplaythrough_event) event.
     * This can be used to wait for Audio or Video files to load. You can also use {@link obstruct} to add custom loaders.
     */
    canPlayThrough;
    /** The {@link HTMLDivElement `<div>`} where content is attached (separate from controls). */
    canvas;
    /** Whether keyboard controls are currently being handled. */
    captureKeys;
    hub;
    /** {@link Keymap} attached to the player */
    keymap;
    /** {@link Playback} attached to the player */
    playback;
    /** {@link Script} attached to the player */
    script;
    buffers;
    __canPlayTasks;
    __canPlayThroughTasks;
    dag;
    /** {@link React.Context} used to access ambient Player */
    static Context = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_10__.createUniqueContext)("@liqvid/player", null);
    /**
     * Symbol to access the {@link Player} instance attached to a DOM element
     *
     * `player.canvas.parentElement[Player.symbol] === player`
     */
    static symbol = Symbol.for("@liqvid/player/element");
    /** Default controls appearing on the left */
    static defaultControlsLeft = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_controls_PlayPause_mjs__WEBPACK_IMPORTED_MODULE_6__.PlayPause, null),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_controls_Volume_mjs__WEBPACK_IMPORTED_MODULE_9__.Volume, null),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_controls_TimeDisplay_mjs__WEBPACK_IMPORTED_MODULE_8__.TimeDisplay, null)));
    /** Default controls appearing on the right */
    static defaultControlsRight = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_controls_Captions_mjs__WEBPACK_IMPORTED_MODULE_4__.Captions, null),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_controls_Settings_mjs__WEBPACK_IMPORTED_MODULE_7__.Settings, null),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_controls_FullScreen_mjs__WEBPACK_IMPORTED_MODULE_5__.FullScreen, null)));
    static defaultProps = {
        controls: (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
            Player.defaultControlsLeft,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-right" }, Player.defaultControlsRight))),
        style: {},
    };
    constructor(props) {
        super(props);
        this.hub = new events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.__canPlayTasks = [];
        this.__canPlayThroughTasks = [];
        this.keymap = new _liqvid_keymap__WEBPACK_IMPORTED_MODULE_11__.Keymap();
        this.captureKeys = true;
        if (props.script) {
            this.script = props.script;
            this.playback = this.script.playback;
        }
        else {
            this.playback = props.playback;
        }
        this.buffers = new Map();
        (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_12__.bind)(this, [
            "onMouseUp",
            "suspendKeyCapture",
            "resumeKeyCapture",
            "reparseTree",
        ]);
        this.updateTree = this.updateTree.bind(this);
    }
    componentDidMount() {
        const element = this.canvas.parentElement;
        // biome-ignore lint/suspicious/noExplicitAny: symbol
        element[Player.symbol] = this;
        // inline or frame?
        // const client =
        //   element.parentElement.nodeName.toLowerCase() === "main" &&
        //   element.parentElement.parentElement === document.body &&
        //   element.parentElement.childNodes.length === 1;
        // document.documentElement.classList.toggle("lv-frame", client);
        // element.classList.toggle("lv-frame", client);
        // keyboard events
        document.body.addEventListener("keydown", (e) => {
            if (!this.captureKeys || document.activeElement !== document.body)
                return;
            this.keymap.handle(e);
        });
        // prevent scroll on mobile
        // document.addEventListener("touchmove", e => {
        //   if (e[allowScroll]) return;
        //   e.preventDefault();
        // }, {passive: false});
        // document.addEventListener("touchforcechange", e => e.preventDefault(), {passive: false});
        // canPlay events --- mostly unused
        this.canPlay = Promise.all(this.__canPlayTasks).then(() => {
            this.hub.emit("canplay");
        });
        this.canPlayThrough = Promise.all(this.__canPlayThroughTasks).then(() => {
            this.hub.emit("canplaythrough");
        });
        // hiding stuff
        if (this.script) {
            this.dag = toposort(this.canvas, this.script.markerNumberOf);
            this.script.on("markerupdate", this.updateTree);
            this.updateTree();
        }
    }
    updateTree() {
        const { script } = this;
        recurse(this.dag);
        /** Hide element */
        function hide(leaf) {
            leaf.element.style.opacity = "0";
            leaf.element.style.pointerEvents = "none";
            leaf.element.setAttribute("aria-hidden", "true");
        }
        /** Show element */
        function show(leaf) {
            leaf.element.style.removeProperty("opacity");
            leaf.element.style.removeProperty("pointer-events");
            leaf.element.removeAttribute("aria-hidden");
            return leaf.children.forEach(recurse);
        }
        /** Recurse through DAG */
        function recurse(leaf) {
            if (typeof leaf.first !== "undefined") {
                if (leaf.first <= script.markerIndex &&
                    (!leaf.last || script.markerIndex < leaf.last)) {
                    return show(leaf);
                }
                hide(leaf);
            }
            else if (typeof leaf.during !== "undefined") {
                if (script.markerName.startsWith(leaf.during)) {
                    return show(leaf);
                }
                return hide(leaf);
            }
            else {
                return leaf.children.forEach(recurse);
            }
        }
    }
    canvasClick() {
        const allow = this.hub.listeners("canvasClick").every((_) => _() ?? true);
        if (allow) {
            this.playback.paused ? this.playback.play() : this.playback.pause();
        }
        this.hub.emit("canvasClick");
    }
    onMouseUp(e) {
        // ignore clicks on input tags
        if (["a", "area", "button", "input", "option", "select", "textarea"].includes(e.target.nodeName.toLowerCase()))
            return;
        // data-affords markup
        if (e.target?.closest(`*[data-affords~="click"]`)) {
            return;
        }
        // the reason for this escape hatch is that this gets called in between an element's onMouseUp
        // listener and the listener added by dragHelper, so you can't call stopPropagation() in the
        // onMouseUp or else the dragging won't release.
        // biome-ignore lint/suspicious/noExplicitAny: symbol
        if (e.nativeEvent[ignoreCanvasClick])
            return;
        this.canvasClick();
    }
    static allowScroll(e) {
        // biome-ignore lint/suspicious/noExplicitAny: symbol
        ("nativeEvent" in e ? e.nativeEvent : e)[allowScroll] = true;
    }
    /**
     * Prevent canvas clicks from pausing the video.
     * @param e Click event on video canvas
     * @deprecated Use data-affords="click" instead
     */
    static preventCanvasClick(e) {
        // biome-ignore lint/suspicious/noExplicitAny: symbol
        ("nativeEvent" in e ? e.nativeEvent : e)[ignoreCanvasClick] = true;
    }
    /** Suspends keyboard controls so that components can receive keyboard input. */
    suspendKeyCapture() {
        this.captureKeys = false;
    }
    /** Resumes keyboard controls. */
    resumeKeyCapture() {
        this.captureKeys = true;
    }
    /** @deprecated */
    ready() {
        console.info(".ready() is a noop in v2.1");
    }
    /**
     * Reparse a section of the document for `during()` and `from()`
     * @param node Element to reparse
     */
    reparseTree(node) {
        const root = findClosest(node, this.dag);
        if (!root) {
            throw new Error("Could not find node in tree");
        }
        root.children = toposort(root.element, this.script.markerNumberOf).children;
        this.updateTree();
    }
    registerBuffer(elt) {
        this.buffers.set(elt, []);
    }
    unregisterBuffer(elt) {
        this.buffers.delete(elt);
    }
    updateBuffer(elt, buffers) {
        this.buffers.set(elt, buffers);
        this.playback.emit("bufferupdate");
    }
    /**
     * Obstruct {@link canPlay} or {@link canPlayThrough} events
     * @param event Which event type to obstruct
     * @param task Promise to append
     */
    obstruct(event, task) {
        if (event === "canplay") {
            this.__canPlayTasks.push(task);
        }
        else {
            this.__canPlayThroughTasks.push(task);
        }
    }
    render() {
        const attrs = {
            style: this.props.style,
        };
        const canvasAttrs = _liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_13__.anyHover ? { onMouseUp: this.onMouseUp } : {};
        const classNames = ["lv-player", "ractive-player"];
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Player.Context.Provider, { value: this },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_liqvid_playback_react__WEBPACK_IMPORTED_MODULE_14__.PlaybackContext.Provider, { value: this.playback },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_15__.KeymapContext.Provider, { value: this.keymap },
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: classNames.join(" "), ...attrs },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "rp-canvas lv-canvas", ...canvasAttrs, ref: (canvas) => (this.canvas = canvas) }, this.props.children),
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_CaptionsDisplay_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], null),
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Controls_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], { controls: this.props.controls, thumbs: this.props.thumbs }))))));
    }
}
/* topological sort */
function toposort(root, mn) {
    const nodes = Array.from(root.querySelectorAll("*[data-from-first], *[data-during]"));
    const dag = { children: [], element: root };
    const path = [dag];
    for (const node of nodes) {
        // get first and last marker
        let firstMarkerName, lastMarkerName, during;
        if (node.dataset.fromFirst) {
            firstMarkerName = node.dataset.fromFirst;
            lastMarkerName = node.dataset.fromLast;
        }
        else if (node.dataset.during) {
            during = node.dataset.during;
        }
        // CSS hides this initially, take over now
        node.style.opacity = "0";
        node.style.pointerEvents = "none";
        // node.removeAttribute("data-from-first");
        // node.removeAttribute("data-from-last");
        // node.removeAttribute("data-from-during");
        // build the leaf
        const leaf = {
            children: [],
            element: node,
        };
        if (during)
            leaf.during = during;
        if (firstMarkerName)
            leaf.first = mn(firstMarkerName);
        if (lastMarkerName)
            leaf.last = mn(lastMarkerName);
        // figure out where to graft it
        let current = path[path.length - 1];
        while (!current.element.contains(node)) {
            path.pop();
            current = path[path.length - 1];
        }
        current.children.push(leaf);
        path.push(leaf);
    }
    return dag;
}
/**
 * Find element's closest ancestor in DAG
 * @param needle Element to find
 * @param haystack DAG leaf to search
 * @returns Closest ancestor
 */
function findClosest(needle, haystack) {
    if (!haystack.element.contains(needle)) {
        return null;
    }
    for (let i = 0; i < haystack.children.length; ++i) {
        if (haystack.children[i].element.contains(needle)) {
            return findClosest(needle, haystack.children[i]) ?? haystack;
        }
    }
    return haystack;
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/Video.mjs":
/*!************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/Video.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Video: () => (/* binding */ Video)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _Media_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Media.mjs */ "./node_modules/liqvid/dist/esm/Media.mjs");


/** Liqvid equivalent of {@link HTMLVideoElement `<video>`}. */
class Video extends _Media_mjs__WEBPACK_IMPORTED_MODULE_1__.Media {
    // render method
    render() {
        const { start, children, obstructCanPlay, obstructCanPlayThrough, ...attrs } = this.props;
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("video", { playsInline: true, preload: "auto", ref: (node) => (this.domElement = node), ...attrs }, children));
    }
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/Captions.mjs":
/*!************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/Captions.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Captions: () => (/* binding */ Captions)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _hooks_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks.mjs */ "./node_modules/liqvid/dist/esm/hooks.mjs");




/** Captions control. */
function Captions() {
    const player = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_1__.usePlayer)();
    const keymap = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_1__.useKeymap)();
    const [visible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    const toggleCaptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {
        player.canvas.parentElement.classList.toggle("lv-captions");
        // blur or keyboard controls will get snagged
        if (e.currentTarget instanceof HTMLButtonElement)
            e.currentTarget.blur();
    }, 
    // note that player.canvas may not have loaded yet
    [player.canvas]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        // visibility
        setVisible(!!player.canvas.querySelector("track"));
        // keyboard shortcut
        keymap.bind("C", toggleCaptions);
        return () => {
            keymap.unbind("C", toggleCaptions);
        };
    }, [keymap, player.canvas, toggleCaptions]);
    const events = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onClick)(toggleCaptions), [toggleCaptions]);
    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (visible ? {} : { display: "none" }), [visible]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { className: "lv-controls-captions", ...events, style, title: "Captions (c)" },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { viewBox: "0 0 36 36" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { d: "M 6.00014 8.00002 C 4.33815 8.00002 2.99981 8.8919 2.99981 9.99989 L 2.99981 25.9999 C 2.99981 27.1079 4.33815 27.9998 6.00014 27.9998 L 30.0002 27.9998 C 31.6622 27.9998 33 27.1079 33 25.9999 L 33 9.99989 C 33 8.8919 31.6622 8.00002 30.0002 8.00002 L 6.00014 8.00002 Z M 14.4032 14.0389 C 15.33 14.0389 16.0827 14.3128 16.6615 14.8606 C 17.006 15.1844 17.2644 15.6495 17.4366 16.2558 L 15.9225 16.6176 C 15.833 16.2248 15.6452 15.9148 15.3592 15.6874 C 15.0768 15.46 14.7322 15.3463 14.3257 15.3463 C 13.7642 15.3463 13.3077 15.5479 12.9563 15.9509 C 12.6083 16.354 12.4344 17.0069 12.4344 17.9095 C 12.4344 18.8672 12.6066 19.5493 12.9511 19.9559 C 13.2956 20.3624 13.7435 20.5656 14.2947 20.5656 C 14.7012 20.5656 15.0509 20.4365 15.3437 20.1781 C 15.6366 19.9197 15.8467 19.5132 15.9742 18.9585 L 17.4573 19.4288 C 17.2299 20.2556 16.851 20.8705 16.3204 21.2736 C 15.7933 21.6732 15.1233 21.8731 14.3102 21.8731 C 13.3043 21.8731 12.4774 21.5303 11.8298 20.8447 C 11.1821 20.1557 10.8582 19.2152 10.8582 18.0232 C 10.8582 16.7623 11.1838 15.7839 11.8349 15.0879 C 12.486 14.3886 13.3422 14.0389 14.4032 14.0389 Z M 22.0462 14.0389 C 22.9729 14.0389 23.7257 14.3128 24.3044 14.8606 C 24.6489 15.1844 24.9073 15.6495 25.0796 16.2558 L 23.5655 16.6176 C 23.4759 16.2248 23.2881 15.9148 23.0022 15.6874 C 22.7197 15.46 22.3752 15.3463 21.9687 15.3463 C 21.4071 15.3463 20.9506 15.5479 20.5992 15.9509 C 20.2513 16.354 20.0773 17.0069 20.0773 17.9095 C 20.0773 18.8672 20.2496 19.5493 20.5941 19.9559 C 20.9386 20.3624 21.3864 20.5656 21.9377 20.5656 C 22.3442 20.5656 22.6938 20.4365 22.9867 20.1781 C 23.2795 19.9197 23.4897 19.5132 23.6171 18.9585 L 25.1002 19.4288 C 24.8729 20.2556 24.4939 20.8705 23.9634 21.2736 C 23.4363 21.6732 22.7662 21.8731 21.9532 21.8731 C 20.9472 21.8731 20.1204 21.5303 19.4727 20.8447 C 18.825 20.1557 18.5012 19.2152 18.5012 18.0232 C 18.5012 16.7623 18.8267 15.7839 19.4779 15.0879 C 20.129 14.3886 20.9851 14.0389 22.0462 14.0389 Z" }))));
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/FullScreen.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/FullScreen.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FullScreen: () => (/* binding */ FullScreen)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _fake_fullscreen_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fake-fullscreen.mjs */ "./node_modules/liqvid/dist/esm/fake-fullscreen.mjs");
/* harmony import */ var _i18n_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../i18n.mjs */ "./node_modules/liqvid/dist/esm/i18n.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liqvid/keymap/react */ "./node_modules/@liqvid/keymap/dist/esm/react.mjs");






const toggleFullScreen = () => (0,_fake_fullscreen_mjs__WEBPACK_IMPORTED_MODULE_1__.isFullScreen)() ? (0,_fake_fullscreen_mjs__WEBPACK_IMPORTED_MODULE_1__.exitFullScreen)() : (0,_fake_fullscreen_mjs__WEBPACK_IMPORTED_MODULE_1__.requestFullScreen)();
const events = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_3__.onClick)(toggleFullScreen);
/** Fullscreen control */
function FullScreen() {
    const keymap = (0,_liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_4__.useKeymap)();
    const forceUpdate = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_3__.useForceUpdate)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        // listener
        (0,_fake_fullscreen_mjs__WEBPACK_IMPORTED_MODULE_1__.onFullScreenChange)(forceUpdate);
        // keyboard shortcut
        keymap.bind("F", toggleFullScreen);
        return () => {
            keymap.unbind("F", toggleFullScreen);
        };
    }, [forceUpdate, keymap]);
    const full = (0,_fake_fullscreen_mjs__WEBPACK_IMPORTED_MODULE_1__.isFullScreen)();
    const label = (full ? _i18n_mjs__WEBPACK_IMPORTED_MODULE_2__.strings.EXIT_FULL_SCREEN : _i18n_mjs__WEBPACK_IMPORTED_MODULE_2__.strings.ENTER_FULL_SCREEN) + " (f)";
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { className: "lv-controls-fullscreen", "aria-label": label, title: label, ...events },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { viewBox: "0 0 36 36" }, full ? exitFullScreenIcon : enterFullScreenIcon)));
}
/** Icon to exit full screen */
const exitFullScreenIcon = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 14 14 h -4 v 2 h 6 v -6 h -2 v 4 z" }),
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 22 14 v -4 h -2 v 6 h 6 v -2 h -4 z" }),
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 20 26 h 2 v -4 h 4 v -2 h -6 v 6 z" }),
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 10 22 h 4 v 4 h 2 v -6 h -6 v 2 z" })));
/** Icon to enter full screen */
const enterFullScreenIcon = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 10 16 h 2 v -4 h 4 v -2 h -6 v 6 z" }),
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 20 10 v 2 h 4 v 4 h 2 v -6 h -6 z" }),
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 24 24 h -4 v 2 h 6 v -6 h -2 v 4 z" }),
    react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "white", d: "M 12 20 h -2 v 6 h 6 v -2 h -4 v -4 z" })));


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/PlayPause.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/PlayPause.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlayPause: () => (/* binding */ PlayPause)
/* harmony export */ });
/* harmony import */ var _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/keymap/react */ "./node_modules/@liqvid/keymap/dist/esm/react.mjs");
/* harmony import */ var _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/playback/react */ "./node_modules/@liqvid/playback/dist/esm/react.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _i18n_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../i18n.mjs */ "./node_modules/liqvid/dist/esm/i18n.mjs");






/** Control for playing/pausing */
function PlayPause() {
    const keymap = (0,_liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_2__.useKeymap)();
    const playback = (0,_liqvid_playback_react__WEBPACK_IMPORTED_MODULE_3__.usePlayback)();
    const forceUpdate = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__.useForceUpdate)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        // subscribe to events
        const events = ["pause", "play", "seeking", "seeked", "stop"];
        for (const e of events)
            playback.on(e, () => {
                forceUpdate();
            });
        // keyboard controls
        const toggle = () => playback[playback.paused ? "play" : "pause"]();
        keymap.bind("K", toggle);
        keymap.bind("Space", () => {
            toggle();
        });
        return () => {
            // unbind playback listeners
            for (const e of events)
                playback.off(e, forceUpdate);
            // unbind keyboard controls
            keymap.unbind("K", toggle);
            keymap.unbind("Space", toggle);
        };
    }, [forceUpdate, keymap, playback]);
    // event handler
    const events = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_4__.onClick)(() => (playback.paused ? playback.play() : playback.pause())), [playback]);
    const label = (playback.paused || playback.seeking ? _i18n_mjs__WEBPACK_IMPORTED_MODULE_1__.strings.PLAY : _i18n_mjs__WEBPACK_IMPORTED_MODULE_1__.strings.PAUSE) +
        " (k)";
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { className: "lv-controls-playpause", "aria-label": label, title: label, ...events },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { viewBox: "0 0 36 36" }, playback.paused || playback.seeking ? playIcon : pauseIcon)));
}
/** Play icon */
const playIcon = (react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { d: "M 12,26 18.5,22 18.5,14 12,10 z M 18.5,22 25,18 25,18 18.5,14 z", fill: "white" }));
/** Pause icon */
const pauseIcon = (react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { d: "M 12 26 h 4 v -16 h -4 z M 21 26 h 4 v -16 h -4 z", fill: "white" }));


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/ScrubberBar.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/ScrubberBar.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScrubberBar: () => (/* binding */ ScrubberBar)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _ThumbnailBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ThumbnailBox.mjs */ "./node_modules/liqvid/dist/esm/controls/ThumbnailBox.mjs");
/* harmony import */ var _liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/interaction */ "./node_modules/@liqvid/utils/dist/esm/interaction.mjs");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var _hooks_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks.mjs */ "./node_modules/liqvid/dist/esm/hooks.mjs");







function ScrubberBar(props) {
    const keymap = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_2__.useKeymap)();
    const playback = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_2__.usePlayback)();
    const script = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_2__.useScript)();
    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
        scrubber: playback.currentTime / playback.duration,
        thumb: playback.currentTime / playback.duration,
    });
    const [showThumb, setShowThumb] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    // refs
    const scrubberBar = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    /* Event handlers */
    const seek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
        if (playback.seeking)
            return;
        const progress = playback.currentTime / playback.duration;
        setProgress({ scrubber: progress, thumb: progress });
    }, [playback]);
    const seeked = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
        const progress = playback.currentTime / playback.duration;
        setProgress((prev) => ({ scrubber: progress, thumb: prev.thumb }));
    }, [playback]);
    const timeupdate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
        const progress = playback.currentTime / playback.duration;
        setProgress((prev) => ({ scrubber: progress, thumb: prev.thumb }));
    }, [playback]);
    const back5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => playback.seek(playback.currentTime - 5000), [playback]);
    const fwd5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => playback.seek(playback.currentTime + 5000), [playback]);
    const back10 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => playback.seek(playback.currentTime - 10000), [playback]);
    const fwd10 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => playback.seek(playback.currentTime + 10000), [playback]);
    const seekPercent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {
        const num = parseInt(e.key, 10);
        if (!isNaN(num)) {
            playback.seek((playback.duration * num) / 10);
        }
    }, [playback]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        /* playback listeners */
        playback.on("seek", seek);
        playback.on("seeked", seeked);
        playback.on("timeupdate", timeupdate);
        /* keyboard shortcuts */
        // seek 5
        keymap.bind("ArrowLeft", back5);
        keymap.bind("ArrowRight", fwd5);
        // seek 10
        keymap.bind("J", back10);
        keymap.bind("L", fwd10);
        // percentage seeking
        keymap.bind("0,1,2,3,4,5,6,7,8,9", seekPercent);
        // seek by marker
        if (script) {
            keymap.bind("W", script.back);
            keymap.bind("E", script.forward);
        }
        return () => {
            playback.off("seek", seek);
            playback.off("seeked", seeked);
            playback.off("timeupdate", timeupdate);
            keymap.unbind("ArrowLeft", back5);
            keymap.unbind("ArrowRight", fwd5);
            keymap.unbind("J", back10);
            keymap.unbind("L", fwd10);
            keymap.unbind("0,1,2,3,4,5,6,7,8,9", seekPercent);
            if (script) {
                keymap.unbind("W", script.back);
                keymap.unbind("E", script.forward);
            }
        };
    }, [
        back10,
        back5,
        fwd10,
        fwd5,
        keymap,
        playback,
        script,
        seek,
        seekPercent,
        seeked,
        timeupdate,
    ]);
    // event handlers
    const divEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
        if (!_liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_3__.anyHover)
            return {};
        const listener = (0,_liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_3__.onDrag)(
        // move
        (e, { x }) => {
            const rect = scrubberBar.current.getBoundingClientRect(), progress = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.clamp)(0, (x - rect.left) / rect.width, 1);
            setProgress({ scrubber: progress, thumb: progress });
            playback.seek(progress * playback.duration);
        }, 
        // down
        (e) => {
            playback.seeking = true;
            const rect = scrubberBar.current.getBoundingClientRect(), progress = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.clamp)(0, (e.clientX - rect.left) / rect.width, 1);
            setProgress({ scrubber: progress, thumb: progress });
            playback.seek(progress * playback.duration);
        }, 
        // up
        () => (playback.seeking = false));
        return {
            onMouseDown: (e) => listener(e.nativeEvent),
        };
    }, [playback]);
    // events to attach on the wrapper
    const wrapEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
        const props = {};
        if (_liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_3__.anyHover) {
            Object.assign(props, {
                // show thumb preview on hover
                onMouseOver: () => setShowThumb(true),
                onMouseMove: (e) => {
                    const rect = scrubberBar.current.getBoundingClientRect(), progress = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.clamp)(0, (e.clientX - rect.left) / rect.width, 1);
                    setProgress((prev) => ({ scrubber: prev.scrubber, thumb: progress }));
                },
                onMouseOut: () => setShowThumb(false),
            });
        }
        const listener = (0,_liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_3__.onDrag)(
        // move
        (e, { x }) => {
            const rect = scrubberBar.current.getBoundingClientRect(), progress = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.clamp)(0, (x - rect.left) / rect.width, 1);
            setProgress({ scrubber: progress, thumb: progress });
        }, 
        // start
        (e) => {
            e.preventDefault();
            e.stopPropagation();
            playback.seeking = true;
            setShowThumb(true);
        }, 
        // end
        (e, { x }) => {
            e.preventDefault();
            const rect = scrubberBar.current.getBoundingClientRect(), progress = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.clamp)(0, (x - rect.left) / rect.width, 1);
            setShowThumb(false);
            playback.seeking = false;
            playback.seek(progress * playback.duration);
        });
        props.ref = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_5__.captureRef)((ref) => {
            ref.addEventListener("touchstart", listener, { passive: false });
        });
        return props;
    }, [playback]);
    // events to be attached to the scrubber
    const scrubberEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
        // if (anyHover) return {};
        const listener = (0,_liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_3__.onDrag)(
        // move
        (e, { x }) => {
            const rect = scrubberBar.current.getBoundingClientRect(), progress = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.clamp)(0, (x - rect.left) / rect.width, 1);
            setProgress({ scrubber: progress, thumb: progress });
        }, 
        // start
        (e) => {
            e.preventDefault();
            e.stopPropagation();
            playback.seeking = true;
            setShowThumb(true);
        }, 
        // end
        (e, { x }) => {
            e.preventDefault();
            const rect = scrubberBar.current.getBoundingClientRect(), progress = (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.clamp)(0, (x - rect.left) / rect.width, 1);
            setShowThumb(false);
            playback.seeking = false;
            playback.seek(progress * playback.duration);
        });
        return {
            ref: (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_5__.captureRef)((ref) => {
                ref.addEventListener("touchstart", listener, { passive: false });
            }),
        };
    }, [playback]);
    const highlights = (props.thumbs && props.thumbs.highlights) || [];
    const activeHighlight = highlights.find((_) => (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_4__.between)(_.time / playback.duration, progress.thumb, _.time / playback.duration + 0.01));
    const thumbTitle = activeHighlight ? activeHighlight.title : null;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-scrub", ref: scrubberBar, ...divEvents },
        props.thumbs && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ThumbnailBox_mjs__WEBPACK_IMPORTED_MODULE_1__.ThumbnailBox, { ...props.thumbs, progress: progress.thumb, show: showThumb, title: thumbTitle })),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-scrub-wrap", ...wrapEvents },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { className: "lv-controls-scrub-progress", preserveAspectRatio: "none", viewBox: "0 0 100 10" },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("rect", { className: "lv-progress-elapsed", x: "0", y: "0", height: "10", width: progress.scrubber * 100 }),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("rect", { className: "lv-progress-remaining", x: progress.scrubber * 100, y: "0", height: "10", width: (1 - progress.scrubber) * 100 }),
                highlights.map(({ time }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("rect", { key: time, className: ["lv-thumb-highlight"]
                        .concat(time <= playback.currentTime ? "past" : [])
                        .join(" "), x: (time / playback.duration) * 100, y: "0", width: "1", height: "10" })))),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { className: "lv-scrubber", style: { left: `calc(${progress.scrubber * 100}% - 6px)` }, viewBox: "0 0 100 100", ...scrubberEvents },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("circle", { cx: "50", cy: "50", r: "50", stroke: "none" })))));
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/Settings.mjs":
/*!************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/Settings.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PLAYBACK_RATES: () => (/* binding */ PLAYBACK_RATES),
/* harmony export */   Settings: () => (/* binding */ Settings)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _hooks_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks.mjs */ "./node_modules/liqvid/dist/esm/hooks.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");





const PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
var Dialogs;
(function (Dialogs) {
    Dialogs[Dialogs["None"] = 0] = "None";
    Dialogs[Dialogs["Main"] = 1] = "Main";
    Dialogs[Dialogs["Speed"] = 2] = "Speed";
    Dialogs[Dialogs["Captions"] = 3] = "Captions";
})(Dialogs || (Dialogs = {}));
/** Settings menu */
function Settings() {
    const player = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_1__.usePlayer)(), { keymap, playback } = player;
    const [dialog, setDialog] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Dialogs.None);
    const [currentRate, setRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(playback.playbackRate);
    const forceUpdate = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.useForceUpdate)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        const ratechange = () => setRate(playback.playbackRate);
        const canvasClick = () => setDialog(Dialogs.None);
        const slowDown = () => (playback.playbackRate = get(PLAYBACK_RATES, PLAYBACK_RATES.indexOf(playback.playbackRate) - 1));
        const speedUp = () => (playback.playbackRate = get(PLAYBACK_RATES, PLAYBACK_RATES.indexOf(playback.playbackRate) + 1));
        // subscribe
        playback.on("ratechange", ratechange);
        player.hub.on("canvasClick", canvasClick);
        // keyboard shortcuts
        keymap.bind("Shift+<", slowDown);
        keymap.bind("Shift+>", speedUp);
        return () => {
            playback.off("ratechange", ratechange);
            player.hub.off("canvasClick", canvasClick);
            keymap.unbind("Shift+<", slowDown);
            keymap.unbind("Shift+>", speedUp);
        };
    }, [keymap, playback, player.hub]);
    /* handlers */
    const setSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
        // biome-ignore lint/suspicious/noExplicitAny: ReturnType<typeof onClick> not working for some reason
        const map = {};
        for (const rate of PLAYBACK_RATES) {
            map[rate] = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onClick)(() => {
                playback.playbackRate = rate;
                setDialog(Dialogs.Main);
            });
        }
        return map;
    }, [playback]);
    const toggle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onClick)(() => setDialog((prev) => prev === Dialogs.None ? Dialogs.Main : Dialogs.None)), []);
    // const toggleSubtitles = useMemo(() => onClick(() => {
    //   document.body.classList.toggle("lv-captions");
    //   forceUpdate();
    // }), []);
    // event handlers
    const openMain = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onClick)(() => setDialog(Dialogs.Main));
    const openSpeed = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onClick)(() => setDialog(Dialogs.Speed));
    const openCaptions = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onClick)(() => setDialog(Dialogs.Captions));
    // styles
    const dialogStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
        display: dialog === Dialogs.Main ? "block" : "none",
    }), [dialog]);
    const speedDialogStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
        display: dialog === Dialogs.Speed ? "block" : "none",
    }), [dialog]);
    const captionDialogStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
        display: dialog === Dialogs.Captions ? "block" : "none",
    }), [dialog]);
    // captions, ugh
    const mainAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        mainAudio.current = getMainAudio(player.canvas);
        if (mainAudio.current) {
            tracks.current = captionsAndSubtitles(mainAudio.current);
        }
    }, [player.canvas]);
    const tracks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);
    const selectedTrack = tracks.current.find((t) => t.mode === "showing");
    const setTrack = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.onClick)((e) => {
        // get index, this is kind of ugly
        let i = -1;
        let temp = e.currentTarget;
        while ((temp = temp.previousElementSibling))
            i++;
        // hide old tracks
        for (let j = 0; j < tracks.current.length; ++j) {
            if (j !== i) {
                // this is absurd but necessary to dispatch cuechange???
                tracks.current[j].mode = "disabled";
                tracks.current[j].mode = "hidden";
                tracks.current[j].mode = "disabled";
            }
        }
        // activate new track
        if (i >= 0)
            tracks.current[i].mode = "showing";
        // refresh
        forceUpdate();
    }), [forceUpdate]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-settings" },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-settings-speed-dialog", style: speedDialogStyle },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-dialog-subtitle", ...openMain }, "< Speed"),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", null, PLAYBACK_RATES.map((rate) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", { className: rate === currentRate ? "selected" : "", key: rate, ...setSpeed[rate] }, rate === 1 ? "Normal" : rate.toString()))))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-settings-captions-dialog", style: captionDialogStyle },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-dialog-subtitle", ...openMain }, "< Captions"),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", { className: selectedTrack ? "" : "selected", ...setTrack }, "Off"),
                tracks.current.map((track) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", { className: track === selectedTrack ? "selected" : "", key: track.id || track.label || track.language, ...setTrack }, trackLabel(track)))))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-settings-dialog", style: dialogStyle },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", null,
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", { ...openSpeed },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", { scope: "row" }, "Speed"),
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null,
                            currentRate === 1 ? "Normal" : currentRate,
                            " >")),
                    tracks.current.length > 0 && (react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", { ...openCaptions },
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", { scope: "row" },
                            "Subtitles (",
                            tracks.current.length,
                            ")"),
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null,
                            trackLabel(selectedTrack),
                            " >")))))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { ...toggle, viewBox: "0 0 48 48" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { fill: "#FFF", d: "m24.04 0.14285c-1.376 0-2.7263 0.12375-4.0386 0.34741l-0.64 6.7853c-1.3572 0.37831-2.6417 0.90728-3.8432 1.585l-5.244-4.3317c-2.2152 1.5679-4.1541 3.4955-5.7217 5.7101l4.3426 5.2437c-0.67695 1.2001-1.2177 2.4878-1.5959 3.8432l-6.7745 0.64053c-0.22379 1.3127-0.34741 2.6622-0.34741 4.0386 0 1.3788 0.12285 2.7238 0.34741 4.0386l6.7745 0.64056c0.37825 1.3554 0.91896 2.6431 1.5959 3.8432l-4.3317 5.2437c1.5648 2.2089 3.4908 4.1457 5.6997 5.7105l5.2545-4.3426c1.2023 0.67835 2.485 1.2174 3.8432 1.5959l0.64053 6.7853c1.3123 0.22368 2.6626 0.33658 4.0386 0.33658s2.7155-0.11289 4.0278-0.33658l0.64053-6.7853c1.3582-0.37847 2.6409-0.91755 3.8432-1.5959l5.2545 4.3426c2.2088-1.5649 4.1348-3.5017 5.6997-5.7105l-4.3317-5.2437c0.67695-1.2001 1.2177-2.4878 1.5959-3.8432l6.7744-0.64056c0.22456-1.3148 0.34741-2.6598 0.34741-4.0386 0-1.3765-0.12361-2.726-0.34741-4.0386l-6.7744-0.64053c-0.37825-1.3554-0.91896-2.6431-1.5959-3.8432l4.3426-5.2437c-1.568-2.2146-3.507-4.1422-5.722-5.7101l-5.2437 4.3317c-1.2015-0.67776-2.486-1.2067-3.8432-1.585l-0.641-6.7853c-1.3123-0.22366-2.6518-0.34741-4.0278-0.34741zm0 14.776c5.0178 0 9.076 4.0691 9.076 9.0869s-4.0582 9.0869-9.076 9.0869-9.0869-4.0691-9.0869-9.0869 4.0691-9.0869 9.0869-9.0869z" }))));
}
function getMainAudio(elt) {
    for (const audio of Array.from(elt.querySelectorAll("audio"))) {
        if (captionsAndSubtitles(audio).length > 0)
            return audio;
    }
}
function trackLabel(track) {
    if (track === undefined)
        return "Off";
    return track.label || track.language;
}
function captionsAndSubtitles(audio) {
    return Array.from(audio.textTracks).filter((t) => ["captions", "subtitles"].includes(t.kind));
}
function get(arr, i) {
    return arr[(0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_3__.clamp)(0, i, arr.length - 1)];
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/ThumbnailBox.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/ThumbnailBox.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThumbnailBox: () => (/* binding */ ThumbnailBox)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _hooks_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks.mjs */ "./node_modules/liqvid/dist/esm/hooks.mjs");
/* harmony import */ var _liqvid_utils_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/time */ "./node_modules/@liqvid/utils/dist/esm/time.mjs");




function ThumbnailBox(props) {
    const player = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_1__.usePlayer)(), { playback } = player;
    const { cols = 5, rows = 5, frequency = 4, path, progress, show, title, height = 100, width = 160, } = props;
    const count = cols * rows;
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        // preload thumbs (once more important loading has taken place)
        const maxSlide = Math.floor(playback.duration / frequency / 1000), maxSheet = Math.floor(maxSlide / count);
        player.hub.on("canplay", () => {
            for (let sheetNum = 0; sheetNum <= maxSheet; ++sheetNum) {
                const img = new Image();
                img.src = path.replace("%s", sheetNum.toString());
            }
        });
    }, [count, frequency, path, playback.duration, player]);
    const time = (progress * playback.duration) / 1000, markerNum = Math.floor(time / frequency), sheetNum = Math.floor(markerNum / count), markerNumOnSheet = markerNum % count, row = Math.floor(markerNumOnSheet / rows), col = markerNumOnSheet % rows;
    const sheetName = path.replace("%s", sheetNum.toString());
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-thumbnail", style: {
            display: show ? "block" : "none",
            left: `calc(${progress * 100}%)`,
        } },
        title && react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-thumbnail-title" }, title),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-thumbnail-box" },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", { src: sheetName, style: {
                    left: `-${col * width}px`,
                    top: `-${row * height}px`,
                } }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-thumbnail-time" }, (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_2__.formatTime)(time * 1000)))));
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/TimeDisplay.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/TimeDisplay.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeDisplay: () => (/* binding */ TimeDisplay)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/time */ "./node_modules/@liqvid/utils/dist/esm/time.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _hooks_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks.mjs */ "./node_modules/liqvid/dist/esm/hooks.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");





function TimeDisplay() {
    const playback = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_1__.usePlayback)();
    const forceUpdate = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_2__.useForceUpdate)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        playback.on("durationchange", forceUpdate);
        playback.on("seek", forceUpdate);
        playback.on("timeupdate", forceUpdate);
        return () => {
            playback.off("durationchange", forceUpdate);
            playback.off("seek", forceUpdate);
            playback.off("timeupdate", forceUpdate);
        };
    }, [forceUpdate, playback]);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-controls-time" },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-current-time" }, (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.formatTime)(playback.currentTime)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-time-separator" }, "/"),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { className: "lv-total-time" }, (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.formatTime)(playback.duration))));
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/controls/Volume.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/controls/Volume.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Volume: () => (/* binding */ Volume)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _hooks_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks.mjs */ "./node_modules/liqvid/dist/esm/hooks.mjs");
/* harmony import */ var _i18n_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../i18n.mjs */ "./node_modules/liqvid/dist/esm/i18n.mjs");





/** Volume control */
function Volume() {
    const keymap = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_1__.useKeymap)();
    const playback = (0,_hooks_mjs__WEBPACK_IMPORTED_MODULE_1__.usePlayback)();
    const forceUpdate = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_3__.useForceUpdate)();
    // keyboard controls
    const incrementVolume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => (playback.volume = playback.volume + 0.05), [playback]);
    const decrementVolume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => (playback.volume = playback.volume - 0.05), [playback]);
    const toggleMute = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => (playback.muted = !playback.muted), [playback]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        playback.on("volumechange", forceUpdate);
        keymap.bind("ArrowUp", incrementVolume);
        keymap.bind("ArrowDown", decrementVolume);
        keymap.bind("M", toggleMute);
        return () => {
            playback.off("volumechange", forceUpdate);
            keymap.unbind("ArrowUp", incrementVolume);
            keymap.unbind("ArrowDown", decrementVolume);
            keymap.unbind("M", toggleMute);
        };
    }, [
        decrementVolume,
        forceUpdate,
        incrementVolume,
        keymap,
        playback,
        toggleMute,
    ]);
    // input
    const onChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {
        playback.volume = parseFloat(e.target.value) / 100;
    }, [playback]);
    const events = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_3__.onClick)(() => (playback.muted = !playback.muted)), [playback]);
    const label = (playback.muted ? _i18n_mjs__WEBPACK_IMPORTED_MODULE_2__.strings.UNMUTE : _i18n_mjs__WEBPACK_IMPORTED_MODULE_2__.strings.MUTE) + " (m)";
    const volumeText = new Intl.NumberFormat(undefined, { style: "percent" }).format(playback.volume) + " volume";
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: "lv-controls-volume" },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { "aria-label": label, title: label },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { ...events, viewBox: "0 0 100 100" },
                speakerIcon,
                playback.muted ? (mutedIcon) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement("g", null,
                    playback.volume > 0 && waveIcon1,
                    playback.volume >= 0.5 && waveIcon2)))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", { "aria-valuetext": volumeText, min: "0", max: "100", onChange: onChange, type: "range", value: playback.muted ? 0 : playback.volume * 100 })));
}
const speakerIcon = (react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { d: "M 10 35 h 20 l 25 -20 v 65 l -25 -20 h -20 z", fill: "white", stroke: "none" }));
const mutedIcon = (react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { d: "M 63 55 l 20 20 m 0 -20 l -20 20", stroke: "white", strokeWidth: "7" }));
const waveIcon1 = (react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { d: "M 62 32.5 a 1,1 0 0,1 0,30", fill: "white", stroke: "none" }));
const waveIcon2 = (react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", { d: "M 62 15 a 1,1 0 0,1 0,65 v -10 a 10,10 0 0,0 0,-45 v -10 z", fill: "white", stroke: "none" }));


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/fake-fullscreen.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/fake-fullscreen.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   exitFullScreen: () => (/* binding */ exitFullScreen),
/* harmony export */   isFullScreen: () => (/* binding */ isFullScreen),
/* harmony export */   onFullScreenChange: () => (/* binding */ onFullScreenChange),
/* harmony export */   requestFullScreen: () => (/* binding */ requestFullScreen)
/* harmony export */ });
/* harmony import */ var _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills.mjs */ "./node_modules/liqvid/dist/esm/polyfills.mjs");

let __isFullScreen = false;
const __callbacks = [];
const requestFullScreen = _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.fullscreenEnabled
    ? _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.requestFullScreen
    : () => {
        window.parent.postMessage({ type: "fake-fullscreen", value: true }, window.parent.origin);
        if (!__isFullScreen) {
            __isFullScreen = true;
            for (const _ of __callbacks)
                _();
        }
    };
const exitFullScreen = _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.fullscreenEnabled
    ? _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.exitFullScreen
    : () => {
        window.parent.postMessage({ type: "fake-fullscreen", value: false }, window.parent.origin);
        if (__isFullScreen) {
            __isFullScreen = false;
            for (const _ of __callbacks)
                _();
        }
    };
const isFullScreen = _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.fullscreenEnabled
    ? _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.isFullScreen
    : () => {
        return __isFullScreen;
    };
const onFullScreenChange = _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.fullscreenEnabled
    ? _polyfills_mjs__WEBPACK_IMPORTED_MODULE_0__.onFullScreenChange
    : (callback) => {
        __callbacks.push(callback);
    };


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/hooks.mjs":
/*!************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/hooks.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeymapContext: () => (/* reexport safe */ _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_1__.KeymapContext),
/* harmony export */   PlaybackContext: () => (/* reexport safe */ _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_2__.PlaybackContext),
/* harmony export */   useKeymap: () => (/* reexport safe */ _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_1__.useKeymap),
/* harmony export */   useMarkerUpdate: () => (/* binding */ useMarkerUpdate),
/* harmony export */   usePlayback: () => (/* reexport safe */ _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_2__.usePlayback),
/* harmony export */   usePlayer: () => (/* binding */ usePlayer),
/* harmony export */   useScript: () => (/* binding */ useScript),
/* harmony export */   useTime: () => (/* reexport safe */ _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_2__.useTime),
/* harmony export */   useTimeUpdate: () => (/* binding */ useTimeUpdate)
/* harmony export */ });
/* harmony import */ var _liqvid_playback_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/playback/react */ "./node_modules/@liqvid/playback/dist/esm/react.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _liqvid_keymap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/keymap/react */ "./node_modules/@liqvid/keymap/dist/esm/react.mjs");
/* harmony import */ var _Player_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Player.mjs */ "./node_modules/liqvid/dist/esm/Player.mjs");





/** Access the ambient {@link Player} */
function usePlayer() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_Player_mjs__WEBPACK_IMPORTED_MODULE_3__.Player.Context);
}
/** Register a callback for when the marker changes */
function useMarkerUpdate(callback, deps) {
    const script = useScript();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        script.on("markerupdate", callback);
        return () => {
            script.off("markerupdate", callback);
        };
    }, [callback, script, ...deps]);
}
/** Access the ambient {@link Script} */
function useScript() {
    return usePlayer().script;
}
/** Register a callback for when the time changes */
function useTimeUpdate(callback, deps) {
    const playback = (0,_liqvid_playback_react__WEBPACK_IMPORTED_MODULE_2__.usePlayback)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        playback.on("seek", callback);
        playback.on("timeupdate", callback);
        return () => {
            playback.off("seek", callback);
            playback.off("timeupdate", callback);
        };
    }, [callback, playback, ...deps]);
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/i18n.mjs":
/*!***********************************************!*\
  !*** ./node_modules/liqvid/dist/esm/i18n.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strings: () => (/* binding */ strings)
/* harmony export */ });
const strings = {
    EXIT_FULL_SCREEN: "Exit full screen",
    ENTER_FULL_SCREEN: "Full screen",
    MUTE: "Mute",
    UNMUTE: "Unmute",
    PAUSE: "Pause",
    PLAY: "Play",
};


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Audio: () => (/* reexport safe */ _Audio_mjs__WEBPACK_IMPORTED_MODULE_0__.Audio),
/* harmony export */   Controls: () => (/* binding */ Controls),
/* harmony export */   IdMap: () => (/* reexport safe */ _IdMap_mjs__WEBPACK_IMPORTED_MODULE_1__.IdMap),
/* harmony export */   KeyMap: () => (/* reexport safe */ _liqvid_keymap__WEBPACK_IMPORTED_MODULE_9__.Keymap),
/* harmony export */   Keymap: () => (/* reexport safe */ _liqvid_keymap__WEBPACK_IMPORTED_MODULE_9__.Keymap),
/* harmony export */   KeymapContext: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.KeymapContext),
/* harmony export */   Media: () => (/* reexport safe */ _Media_mjs__WEBPACK_IMPORTED_MODULE_2__.Media),
/* harmony export */   Playback: () => (/* reexport safe */ _playback_mjs__WEBPACK_IMPORTED_MODULE_5__.Playback),
/* harmony export */   PlaybackContext: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.PlaybackContext),
/* harmony export */   Player: () => (/* reexport safe */ _Player_mjs__WEBPACK_IMPORTED_MODULE_3__.Player),
/* harmony export */   Script: () => (/* reexport safe */ _script_mjs__WEBPACK_IMPORTED_MODULE_6__.Script),
/* harmony export */   Utils: () => (/* reexport module object */ _utils_mjs__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   Video: () => (/* reexport safe */ _Video_mjs__WEBPACK_IMPORTED_MODULE_4__.Video),
/* harmony export */   useKeymap: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.useKeymap),
/* harmony export */   useMarkerUpdate: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.useMarkerUpdate),
/* harmony export */   usePlayback: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.usePlayback),
/* harmony export */   usePlayer: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.usePlayer),
/* harmony export */   useScript: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.useScript),
/* harmony export */   useTime: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.useTime),
/* harmony export */   useTimeUpdate: () => (/* reexport safe */ _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__.useTimeUpdate)
/* harmony export */ });
/* harmony import */ var _Audio_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Audio.mjs */ "./node_modules/liqvid/dist/esm/Audio.mjs");
/* harmony import */ var _IdMap_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IdMap.mjs */ "./node_modules/liqvid/dist/esm/IdMap.mjs");
/* harmony import */ var _Media_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Media.mjs */ "./node_modules/liqvid/dist/esm/Media.mjs");
/* harmony import */ var _Player_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Player.mjs */ "./node_modules/liqvid/dist/esm/Player.mjs");
/* harmony import */ var _Video_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Video.mjs */ "./node_modules/liqvid/dist/esm/Video.mjs");
/* harmony import */ var _playback_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./playback.mjs */ "./node_modules/liqvid/dist/esm/playback.mjs");
/* harmony import */ var _script_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./script.mjs */ "./node_modules/liqvid/dist/esm/script.mjs");
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/liqvid/dist/esm/utils.mjs");
/* harmony import */ var _hooks_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./hooks.mjs */ "./node_modules/liqvid/dist/esm/hooks.mjs");
/* harmony import */ var _liqvid_keymap__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @liqvid/keymap */ "./node_modules/@liqvid/keymap/dist/esm/index.mjs");
/* harmony import */ var _controls_Captions_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./controls/Captions.mjs */ "./node_modules/liqvid/dist/esm/controls/Captions.mjs");
/* harmony import */ var _controls_FullScreen_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./controls/FullScreen.mjs */ "./node_modules/liqvid/dist/esm/controls/FullScreen.mjs");
/* harmony import */ var _controls_PlayPause_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./controls/PlayPause.mjs */ "./node_modules/liqvid/dist/esm/controls/PlayPause.mjs");
/* harmony import */ var _controls_ScrubberBar_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./controls/ScrubberBar.mjs */ "./node_modules/liqvid/dist/esm/controls/ScrubberBar.mjs");
/* harmony import */ var _controls_Settings_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./controls/Settings.mjs */ "./node_modules/liqvid/dist/esm/controls/Settings.mjs");
/* harmony import */ var _controls_TimeDisplay_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./controls/TimeDisplay.mjs */ "./node_modules/liqvid/dist/esm/controls/TimeDisplay.mjs");
/* harmony import */ var _controls_Volume_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./controls/Volume.mjs */ "./node_modules/liqvid/dist/esm/controls/Volume.mjs");
/* harmony import */ var _utils_rsc_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/rsc.mjs */ "./node_modules/liqvid/dist/esm/utils/rsc.mjs");










// backwards compatibility


// controls







const Controls = {
    Captions: _controls_Captions_mjs__WEBPACK_IMPORTED_MODULE_10__.Captions,
    FullScreen: _controls_FullScreen_mjs__WEBPACK_IMPORTED_MODULE_11__.FullScreen,
    PlayPause: _controls_PlayPause_mjs__WEBPACK_IMPORTED_MODULE_12__.PlayPause,
    ScrubberBar: _controls_ScrubberBar_mjs__WEBPACK_IMPORTED_MODULE_13__.ScrubberBar,
    Settings: _controls_Settings_mjs__WEBPACK_IMPORTED_MODULE_14__.Settings,
    TimeDisplay: _controls_TimeDisplay_mjs__WEBPACK_IMPORTED_MODULE_15__.TimeDisplay,
    Volume: _controls_Volume_mjs__WEBPACK_IMPORTED_MODULE_16__.Volume,
};
// alias

if (_utils_rsc_mjs__WEBPACK_IMPORTED_MODULE_17__.isClient && !window.hasOwnProperty("RactivePlayer")) {
    Object.defineProperty(window, "RactivePlayer", {
        get() {
            if (typeof window.Liqvid !== "undefined") {
                return window.Liqvid;
            }
        },
    });
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/playback.mjs":
/*!***************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/playback.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Playback: () => (/* reexport safe */ _liqvid_playback__WEBPACK_IMPORTED_MODULE_0__.Playback)
/* harmony export */ });
/* harmony import */ var _liqvid_playback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liqvid/playback */ "./node_modules/@liqvid/playback/dist/esm/animation.mjs");
/* harmony import */ var _liqvid_utils_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/utils/time */ "./node_modules/@liqvid/utils/dist/esm/time.mjs");


// backwards compatibility
Object.defineProperty(_liqvid_playback__WEBPACK_IMPORTED_MODULE_0__.Playback.prototype, "hub", {
    get: function () {
        return this;
    },
});
const seek = _liqvid_playback__WEBPACK_IMPORTED_MODULE_0__.Playback.prototype.seek;
_liqvid_playback__WEBPACK_IMPORTED_MODULE_0__.Playback.prototype.seek = function (t) {
    if (typeof t === "string") {
        t = (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_1__.parseTime)(t);
    }
    seek.call(this, t);
};



/***/ }),

/***/ "./node_modules/liqvid/dist/esm/polyfills.mjs":
/*!****************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/polyfills.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   exitFullScreen: () => (/* binding */ exitFullScreen),
/* harmony export */   fullscreenEnabled: () => (/* binding */ fullscreenEnabled),
/* harmony export */   isFullScreen: () => (/* binding */ isFullScreen),
/* harmony export */   onFullScreenChange: () => (/* binding */ onFullScreenChange),
/* harmony export */   requestFullScreen: () => (/* binding */ requestFullScreen)
/* harmony export */ });
/* harmony import */ var _utils_rsc_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/rsc.mjs */ "./node_modules/liqvid/dist/esm/utils/rsc.mjs");

const id = (_) => _;
const fullscreenEnabled = _utils_rsc_mjs__WEBPACK_IMPORTED_MODULE_0__.isClient
    ? [
        "fullscreenEnabled",
        "webkitFullscreenEnabled",
        "mozFullScreenEnabled",
        "msFullscreenEnabled",
    ]
        // biome-ignore lint/suspicious/noExplicitAny: vendor-specific
        .map((_) => document[_])
        .concat(false)
        .find((_) => _ !== undefined)
    : false;
const requestFullScreen = _utils_rsc_mjs__WEBPACK_IMPORTED_MODULE_0__.isClient
    ? [
        "requestFullscreen",
        "webkitRequestFullscreen",
        "mozRequestFullScreen",
        "msRequestFullscreen",
    ]
        // biome-ignore lint/suspicious/noExplicitAny: vendor-specific
        .map((_) => document.body[_])
        .concat(() => { })
        .find(id)
        .bind(document.body)
    : async () => { };
const exitFullScreen = _utils_rsc_mjs__WEBPACK_IMPORTED_MODULE_0__.isClient
    ? [
        "exitFullscreen",
        "webkitExitFullscreen",
        "mozCancelFullScreen",
        "msExitFullscreen",
    ]
        // biome-ignore lint/suspicious/noExplicitAny: vendor-specific
        .map((_) => document[_])
        .concat(async () => { })
        .find(id)
        .bind(document)
    : async () => { };
const isFullScreen = () => ["fullscreen", "webkitIsFullScreen", "mozFullScreen"]
    // biome-ignore lint/suspicious/noExplicitAny: vendor-specific
    .map((_) => document[_])
    .find((_) => _ !== undefined);
function onFullScreenChange(callback) {
    for (const event of [
        "fullscreenchange",
        "webkitfullscreenchange",
        "mozfullscreenchange",
        "MSFullscreenChange",
    ])
        document.addEventListener(event, callback);
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/script.mjs":
/*!*************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/script.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Script: () => (/* binding */ Script)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/time */ "./node_modules/@liqvid/utils/dist/esm/time.mjs");
/* harmony import */ var _playback_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./playback.mjs */ "./node_modules/liqvid/dist/esm/playback.mjs");




class Script extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /** The underlying {@link Playback} instance. */
    playback;
    /** The array of markers, in the form [name, startTime, endTime]. */
    markers;
    /** Index of the active marker. */
    markerIndex;
    constructor(markers) {
        super();
        this.setMaxListeners(0);
        // bind methods
        (0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_2__.bind)(this, [
            "back",
            "forward",
            "markerByName",
            "markerNumberOf",
            "parseStart",
            "parseEnd",
            "__updateMarker",
        ]);
        // parse times
        let time = 0;
        this.markers = [];
        for (const marker of markers) {
            if (marker.length === 2) {
                const [, duration] = marker;
                this.markers.push([
                    marker[0],
                    time,
                    time +
                        (typeof duration === "string" ? (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.parseTime)(duration) : duration),
                ]);
            }
            else {
                const [, begin, end] = marker;
                this.markers.push([
                    marker[0],
                    typeof begin === "string" ? (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.parseTime)(begin) : begin,
                    typeof end === "string" ? (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.parseTime)(end) : end,
                ]);
            }
            time = this.markers[this.markers.length - 1][2];
        }
        this.markerIndex = 0;
        // create playback object
        this.playback = new _playback_mjs__WEBPACK_IMPORTED_MODULE_1__.Playback({
            duration: this.markers[this.markers.length - 1][2],
        });
        this.playback.on("seek", this.__updateMarker);
        this.playback.on("timeupdate", this.__updateMarker);
    }
    /** @deprecated */
    get hub() {
        return this;
    }
    /** Name of the active marker. */
    get markerName() {
        return this.markers[this.markerIndex][0];
    }
    // public methods
    /** Seek playback to the previous marker. */
    back() {
        this.playback.seek(this.markers[Math.max(0, this.markerIndex - 1)][1]);
    }
    /** Advance playback to the next marker. */
    forward() {
        this.playback.seek(this.markers[Math.min(this.markers.length - 1, this.markerIndex + 1)][1]);
    }
    /**
     * Returns the first marker with the given name.
     * @throws {Error} If no marker named `name` exists.
     */
    markerByName(name) {
        return this.markers[this.markerNumberOf(name)];
    }
    /**
     * Returns the first index of a marker named `name`.
     * @throws {Error} If no marker named `name` exists.
     */
    markerNumberOf(name) {
        for (let i = 0; i < this.markers.length; ++i) {
            if (this.markers[i][0] === name)
                return i;
        }
        throw new Error(`Marker ${name} does not exist`);
    }
    /** If `start` is a string, returns the starting time of the marker with that name. Otherwise, returns `start`. */
    parseStart(start) {
        if (typeof start === "string") {
            if (start.match(_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.timeRegexp))
                return (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.parseTime)(start);
            else
                return this.markerByName(start)[1];
        }
        else {
            return start;
        }
    }
    /** If `end` is a string, returns the ending time of the marker with that name. Otherwise, returns `end`. */
    parseEnd(end) {
        if (typeof end === "string") {
            if (end.match(_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.timeRegexp))
                return (0,_liqvid_utils_time__WEBPACK_IMPORTED_MODULE_3__.parseTime)(end);
            else
                return this.markerByName(end)[2];
        }
        else {
            return end;
        }
    }
    /** Update marker */
    __updateMarker(t) {
        let newIndex;
        for (let i = 0; i < this.markers.length; ++i) {
            const [, begin, end] = this.markers[i];
            if ((0,_liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_2__.between)(begin, t, end)) {
                newIndex = i;
                break;
            }
        }
        if (newIndex === undefined)
            newIndex = this.markers.length - 1;
        if (newIndex !== this.markerIndex) {
            const prevIndex = this.markerIndex;
            this.markerIndex = newIndex;
            this.emit("markerupdate", prevIndex);
        }
    }
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/utils.mjs":
/*!************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/utils.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   animation: () => (/* reexport module object */ _liqvid_utils_animation__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   authoring: () => (/* reexport module object */ _utils_authoring_mjs__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   interactivity: () => (/* reexport module object */ _utils_interactivity_mjs__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   json: () => (/* reexport module object */ _liqvid_utils_json__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   media: () => (/* reexport module object */ _utils_media_mjs__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   misc: () => (/* reexport module object */ _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   mobile: () => (/* reexport module object */ _utils_mobile_mjs__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   react: () => (/* reexport module object */ _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   replayData: () => (/* reexport module object */ _liqvid_utils_replay_data__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   svg: () => (/* reexport module object */ _liqvid_utils_svg__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   time: () => (/* reexport module object */ _liqvid_utils_time__WEBPACK_IMPORTED_MODULE_10__)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liqvid/utils/animation */ "./node_modules/@liqvid/utils/dist/esm/animation.mjs");
/* harmony import */ var _utils_authoring_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/authoring.mjs */ "./node_modules/liqvid/dist/esm/utils/authoring.mjs");
/* harmony import */ var _utils_interactivity_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/interactivity.mjs */ "./node_modules/liqvid/dist/esm/utils/interactivity.mjs");
/* harmony import */ var _liqvid_utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liqvid/utils/json */ "./node_modules/@liqvid/utils/dist/esm/json.mjs");
/* harmony import */ var _utils_media_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/media.mjs */ "./node_modules/liqvid/dist/esm/utils/media.mjs");
/* harmony import */ var _liqvid_utils_misc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @liqvid/utils/misc */ "./node_modules/@liqvid/utils/dist/esm/misc.mjs");
/* harmony import */ var _utils_mobile_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/mobile.mjs */ "./node_modules/liqvid/dist/esm/utils/mobile.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");
/* harmony import */ var _liqvid_utils_replay_data__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @liqvid/utils/replay-data */ "./node_modules/@liqvid/utils/dist/esm/replay-data.mjs");
/* harmony import */ var _liqvid_utils_svg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @liqvid/utils/svg */ "./node_modules/@liqvid/utils/dist/esm/svg.mjs");
/* harmony import */ var _liqvid_utils_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @liqvid/utils/time */ "./node_modules/@liqvid/utils/dist/esm/time.mjs");
/* various things we sometimes use */


// export * as dom from './utils/dom';











/***/ }),

/***/ "./node_modules/liqvid/dist/esm/utils/authoring.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/utils/authoring.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   during: () => (/* binding */ during),
/* harmony export */   from: () => (/* binding */ from),
/* harmony export */   showIf: () => (/* binding */ showIf)
/* harmony export */ });
// conditional display
function showIf(cond) {
    if (!cond)
        return {
            style: {
                opacity: 0,
                pointerEvents: "none",
            },
        };
    return {};
}
/** Returns a CSS block to show the element only when marker name begins with `prefix` */
function during(prefix) {
    return {
        ["data-during"]: prefix,
    };
}
/** Returns a CSS block to show the element when marker is in [first, last) */
function from(first, last) {
    return {
        ["data-from-first"]: first,
        ["data-from-last"]: last,
    };
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/utils/dom.mjs":
/*!****************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/utils/dom.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fragmentFromHTML: () => (/* binding */ fragmentFromHTML)
/* harmony export */ });
function fragmentFromHTML(str) {
    const t = document.createElement("template");
    t.innerHTML = str;
    return t.content.cloneNode(true);
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/utils/interactivity.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/utils/interactivity.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dragHelper: () => (/* binding */ dragHelper),
/* harmony export */   dragHelperReact: () => (/* binding */ dragHelperReact)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liqvid/utils/interaction */ "./node_modules/@liqvid/utils/dist/esm/interaction.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");


function isReactMouseEvent(e) {
    return "nativeEvent" in e && e.nativeEvent instanceof MouseEvent;
}
/**
 * Helper for implementing drag functionality, abstracting over mouse vs touch events.
 * @returns An event listener which should be added to both `mousedown` and `touchstart` events.
 */
function dragHelper(move, 
/** Callback for when dragging begins (pointer is touched). */
down = () => { }, 
/** Callback for when dragging ends (pointer is lifted). */
up = () => { }) {
    /*
      We can't directly use the version from @liqvid/utils/interaction because down() might want to use React types.
      Hence this goofiness.
    */
    let args;
    const __down = (e, ...captureArgs) => {
        args = captureArgs;
    };
    const listener = (0,_liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_0__.onDrag)(move, __down, up);
    return (e) => {
        if ((e instanceof MouseEvent || isReactMouseEvent(e)) && e.button !== 0)
            return;
        if ("nativeEvent" in e) {
            listener(e.nativeEvent);
        }
        else {
            listener(e);
        }
        down(e, ...args);
    };
}
/**
 * Helper for implementing drag functionality, abstracting over mouse vs touch events.
 * @param innerRef Any `ref` that you want attached to the element, since this method attaches its own `ref` attribute. This is a hack around https://github.com/facebook/react/issues/2043.
 * @returns An object of event handlers which should be added to a React element with {...}
 */
function dragHelperReact(move, down, up, innerRef) {
    const listener = dragHelper(move, down, up);
    if (innerRef) {
        const intercept = (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_1__.captureRef)((ref) => ref.addEventListener("touchstart", listener, { passive: false }), innerRef);
        return {
            "data-affords": "click",
            onMouseDown: listener,
            ref: intercept,
        };
    }
    else {
        return {
            "data-affords": "click",
            onMouseDown: listener,
            onTouchStart: listener,
        };
    }
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/utils/media.mjs":
/*!******************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/utils/media.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   awaitMediaCanPlay: () => (/* binding */ awaitMediaCanPlay),
/* harmony export */   awaitMediaCanPlayThrough: () => (/* binding */ awaitMediaCanPlayThrough)
/* harmony export */ });
/** Promisifed version of [canplay](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplay_event) event */
function awaitMediaCanPlay(media) {
    return new Promise((resolve) => {
        if (media.readyState === media.HAVE_FUTURE_DATA) {
            return resolve();
        }
        else {
            media.addEventListener("canplay", () => resolve());
        }
    });
}
/** Promisified version of [`canplaythrough`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplaythrough_event) event. */
function awaitMediaCanPlayThrough(media) {
    return new Promise((resolve) => {
        if (media.readyState === media.HAVE_ENOUGH_DATA) {
            return resolve();
        }
        else {
            media.addEventListener("canplaythrough", () => resolve());
        }
    });
}


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/utils/mobile.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/utils/mobile.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anyHover: () => (/* reexport safe */ _liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_0__.anyHover),
/* harmony export */   attachClickHandler: () => (/* reexport safe */ _liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_0__.onClick),
/* harmony export */   onClick: () => (/* binding */ onClick)
/* harmony export */ });
/* harmony import */ var _liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liqvid/utils/interaction */ "./node_modules/@liqvid/utils/dist/esm/interaction.mjs");
/* harmony import */ var _liqvid_utils_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liqvid/utils/react */ "./node_modules/@liqvid/utils/dist/esm/react.mjs");



/**
    Drop-in replacement for onClick handlers which works better on mobile.
  The innerRef attribute, and the implementation, is a hack around https://github.com/facebook/react/issues/2043.
*/
const onClick = (callback, innerRef) => {
    if (_liqvid_utils_interaction__WEBPACK_IMPORTED_MODULE_0__.anyHover) {
        return { onClick: callback };
    }
    else {
        let touchId, target;
        // touchstart handler
        const onTouchStart = (e) => {
            if (typeof touchId === "number")
                return;
            target = e.currentTarget;
            touchId = e.changedTouches[0].identifier;
        };
        // touchend handler
        const onTouchEnd = (e) => {
            if (typeof touchId !== "number")
                return;
            for (const touch of Array.from(e.changedTouches)) {
                if (touch.identifier !== touchId)
                    continue;
                if (target.contains(document.elementFromPoint(touch.clientX, touch.clientY))) {
                    callback(e);
                }
                touchId = undefined;
                break;
            }
        };
        return {
            ref: (0,_liqvid_utils_react__WEBPACK_IMPORTED_MODULE_1__.captureRef)((ref) => {
                ref.addEventListener("touchstart", onTouchStart, { passive: false });
                ref.addEventListener("touchend", onTouchEnd, { passive: false });
            }, innerRef),
        };
    }
};


/***/ }),

/***/ "./node_modules/liqvid/dist/esm/utils/rsc.mjs":
/*!****************************************************!*\
  !*** ./node_modules/liqvid/dist/esm/utils/rsc.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isClient: () => (/* binding */ isClient)
/* harmony export */ });
// work with Next.js
const isClient = typeof globalThis.document !== "undefined";


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


if (true) {
    (function () {
        'use strict';
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
                'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
        var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js");
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
            {
                suppressWarning = newSuppressWarning;
            }
        }
        function warn(format) {
            {
                if (!suppressWarning) {
                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                if (!suppressWarning) {
                    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([stack]);
                }
                var argsWithFormat = args.map(function (item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = true;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + 'Capture', dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
            {
                if (registrationNameDependencies[registrationName]) {
                    error('EventRegistry: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);
                }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
                var lowerCasedName = registrationName.toLowerCase();
                possibleRegistrationNames[lowerCasedName] = registrationName;
                if (registrationName === 'onDoubleClick') {
                    possibleRegistrationNames.ondblclick = registrationName;
                }
            }
            for (var i = 0; i < dependencies.length; i++) {
                allNativeEvents.add(dependencies[i]);
            }
        }
        var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                }
                catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided `%s` attribute is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', attributeName, typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function checkPropStringCoercion(value, propName) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided `%s` prop is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', propName, typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided `%s` CSS property is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', propName, typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function checkHtmlStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided HTML markup uses a value of unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function checkFormFieldValueStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('Form field values (value, checked, defaultValue, or defaultChecked props)' + ' must be strings, not %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
                return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
                return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
                validatedAttributeNameCache[attributeName] = true;
                return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
                error('Invalid attribute name: `%s`', attributeName);
            }
            return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
                return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
                return false;
            }
            if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
                return true;
            }
            return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
                return false;
            }
            switch (typeof value) {
                case 'function':
                case 'symbol':
                    return true;
                case 'boolean':
                    {
                        if (isCustomComponentTag) {
                            return false;
                        }
                        if (propertyInfo !== null) {
                            return !propertyInfo.acceptsBooleans;
                        }
                        else {
                            var prefix = name.toLowerCase().slice(0, 5);
                            return prefix !== 'data-' && prefix !== 'aria-';
                        }
                    }
                default:
                    return false;
            }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === 'undefined') {
                return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
                return true;
            }
            if (isCustomComponentTag) {
                return false;
            }
            if (propertyInfo !== null) {
                switch (propertyInfo.type) {
                    case BOOLEAN:
                        return !value;
                    case OVERLOADED_BOOLEAN:
                        return value === false;
                    case NUMERIC:
                        return isNaN(value);
                    case POSITIVE_NUMERIC:
                        return isNaN(value) || value < 1;
                }
            }
            return false;
        }
        function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL;
            this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = ['children', 'dangerouslySetInnerHTML',
            'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
        reservedProps.forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        ['allowFullScreen', 'async',
            'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',
            'itemScope'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        ['checked',
            'multiple', 'muted', 'selected'
        ].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        ['capture', 'download'
        ].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        ['cols', 'rows', 'size', 'span'
        ].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ['rowSpan', 'start'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function (token) {
            return token[1].toUpperCase();
        };
        ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'
        ].forEach(function (attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'
        ].forEach(function (attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/1999/xlink', false, false);
        });
        ['xml:base', 'xml:lang', 'xml:space'
        ].forEach(function (attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/XML/1998/namespace', false, false);
        });
        ['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = 'xlinkHref';
        properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, 'xlink:href', 'http://www.w3.org/1999/xlink', true, false);
        ['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
            {
                if (!didWarn && isJavaScriptProtocol.test(url)) {
                    didWarn = true;
                    error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
                }
            }
        }
        function getValueForProperty(node, name, expected, propertyInfo) {
            {
                if (propertyInfo.mustUseProperty) {
                    var propertyName = propertyInfo.propertyName;
                    return node[propertyName];
                }
                else {
                    {
                        checkAttributeStringCoercion(expected, name);
                    }
                    if (propertyInfo.sanitizeURL) {
                        sanitizeURL('' + expected);
                    }
                    var attributeName = propertyInfo.attributeName;
                    var stringValue = null;
                    if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                        if (node.hasAttribute(attributeName)) {
                            var value = node.getAttribute(attributeName);
                            if (value === '') {
                                return true;
                            }
                            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                                return value;
                            }
                            if (value === '' + expected) {
                                return expected;
                            }
                            return value;
                        }
                    }
                    else if (node.hasAttribute(attributeName)) {
                        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                            return node.getAttribute(attributeName);
                        }
                        if (propertyInfo.type === BOOLEAN) {
                            return expected;
                        }
                        stringValue = node.getAttribute(attributeName);
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                        return stringValue === null ? expected : stringValue;
                    }
                    else if (stringValue === '' + expected) {
                        return expected;
                    }
                    else {
                        return stringValue;
                    }
                }
            }
        }
        function getValueForAttribute(node, name, expected, isCustomComponentTag) {
            {
                if (!isAttributeNameSafe(name)) {
                    return;
                }
                if (!node.hasAttribute(name)) {
                    return expected === undefined ? undefined : null;
                }
                var value = node.getAttribute(name);
                {
                    checkAttributeStringCoercion(expected, name);
                }
                if (value === '' + expected) {
                    return expected;
                }
                return value;
            }
        }
        function setValueForProperty(node, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
                return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
                value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
                if (isAttributeNameSafe(name)) {
                    var _attributeName = name;
                    if (value === null) {
                        node.removeAttribute(_attributeName);
                    }
                    else {
                        {
                            checkAttributeStringCoercion(value, name);
                        }
                        node.setAttribute(_attributeName, '' + value);
                    }
                }
                return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                if (value === null) {
                    var type = propertyInfo.type;
                    node[propertyName] = type === BOOLEAN ? false : '';
                }
                else {
                    node[propertyName] = value;
                }
                return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
                node.removeAttribute(attributeName);
            }
            else {
                var _type = propertyInfo.type;
                var attributeValue;
                if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                    attributeValue = '';
                }
                else {
                    {
                        {
                            checkAttributeStringCoercion(value, attributeName);
                        }
                        attributeValue = '' + value;
                    }
                    if (propertyInfo.sanitizeURL) {
                        sanitizeURL(attributeValue.toString());
                    }
                }
                if (attributeNamespace) {
                    node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
                }
                else {
                    node.setAttribute(attributeName, attributeValue);
                }
            }
        }
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_SCOPE_TYPE = Symbol.for('react.scope');
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() { }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    }
                    catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function () {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function () {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        }
                        catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    }
                    else {
                        try {
                            Fake.call();
                        }
                        catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                }
                else {
                    try {
                        throw Error();
                    }
                    catch (x) {
                        control = x;
                    }
                    fn();
                }
            }
            catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                        c--;
                    }
                    for (; s >= 1 && c >= 0; s--, c--) {
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                } while (s >= 1 && c >= 0);
                            }
                            break;
                        }
                    }
                }
            }
            finally {
                reentry = false;
                {
                    ReactCurrentDispatcher.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
            {
                return describeNativeComponentFrame(ctor, true);
            }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch (type) {
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch (type.$$typeof) {
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            }
                            catch (x) { }
                        }
                }
            }
            return '';
        }
        function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
                case HostComponent:
                    return describeBuiltInComponentFrame(fiber.type);
                case LazyComponent:
                    return describeBuiltInComponentFrame('Lazy');
                case SuspenseComponent:
                    return describeBuiltInComponentFrame('Suspense');
                case SuspenseListComponent:
                    return describeBuiltInComponentFrame('SuspenseList');
                case FunctionComponent:
                case IndeterminateComponent:
                case SimpleMemoComponent:
                    return describeFunctionComponentFrame(fiber.type);
                case ForwardRef:
                    return describeFunctionComponentFrame(fiber.type.render);
                case ClassComponent:
                    return describeClassComponentFrame(fiber.type);
                default:
                    return '';
            }
        }
        function getStackByFiberInDevAndProd(workInProgress) {
            try {
                var info = '';
                var node = workInProgress;
                do {
                    info += describeFiber(node);
                    node = node.return;
                } while (node);
                return info;
            }
            catch (x) {
                return '\nError generating stack: ' + x.message + '\n' + x.stack;
            }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch (type) {
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
            }
            if (typeof type === 'object') {
                switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            }
                            catch (x) {
                                return null;
                            }
                        }
                }
            }
            return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || '';
            return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
                case CacheComponent:
                    return 'Cache';
                case ContextConsumer:
                    var context = type;
                    return getContextName$1(context) + '.Consumer';
                case ContextProvider:
                    var provider = type;
                    return getContextName$1(provider._context) + '.Provider';
                case DehydratedFragment:
                    return 'DehydratedFragment';
                case ForwardRef:
                    return getWrappedName$1(type, type.render, 'ForwardRef');
                case Fragment:
                    return 'Fragment';
                case HostComponent:
                    return type;
                case HostPortal:
                    return 'Portal';
                case HostRoot:
                    return 'Root';
                case HostText:
                    return 'Text';
                case LazyComponent:
                    return getComponentNameFromType(type);
                case Mode:
                    if (type === REACT_STRICT_MODE_TYPE) {
                        return 'StrictMode';
                    }
                    return 'Mode';
                case OffscreenComponent:
                    return 'Offscreen';
                case Profiler:
                    return 'Profiler';
                case ScopeComponent:
                    return 'Scope';
                case SuspenseComponent:
                    return 'Suspense';
                case SuspenseListComponent:
                    return 'SuspenseList';
                case TracingMarkerComponent:
                    return 'TracingMarker';
                case ClassComponent:
                case FunctionComponent:
                case IncompleteClassComponent:
                case IndeterminateComponent:
                case MemoComponent:
                case SimpleMemoComponent:
                    if (typeof type === 'function') {
                        return type.displayName || type.name || null;
                    }
                    if (typeof type === 'string') {
                        return type;
                    }
                    break;
            }
            return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
            {
                if (current === null) {
                    return null;
                }
                var owner = current._debugOwner;
                if (owner !== null && typeof owner !== 'undefined') {
                    return getComponentNameFromFiber(owner);
                }
            }
            return null;
        }
        function getCurrentFiberStackInDev() {
            {
                if (current === null) {
                    return '';
                }
                return getStackByFiberInDevAndProd(current);
            }
        }
        function resetCurrentFiber() {
            {
                ReactDebugCurrentFrame.getCurrentStack = null;
                current = null;
                isRendering = false;
            }
        }
        function setCurrentFiber(fiber) {
            {
                ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
                current = fiber;
                isRendering = false;
            }
        }
        function getCurrentFiber() {
            {
                return current;
            }
        }
        function setIsRendering(rendering) {
            {
                isRendering = rendering;
            }
        }
        function toString(value) {
            return '' + value;
        }
        function getToStringValue(value) {
            switch (typeof value) {
                case 'boolean':
                case 'number':
                case 'string':
                case 'undefined':
                    return value;
                case 'object':
                    {
                        checkFormFieldValueStringCoercion(value);
                    }
                    return value;
                default:
                    return '';
            }
        }
        var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
        };
        function checkControlledValueProps(tagName, props) {
            {
                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                    error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                }
                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                    error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                }
            }
        }
        function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
        }
        function getTracker(node) {
            return node._valueTracker;
        }
        function detachTracker(node) {
            node._valueTracker = null;
        }
        function getValueFromNode(node) {
            var value = '';
            if (!node) {
                return value;
            }
            if (isCheckable(node)) {
                value = node.checked ? 'true' : 'false';
            }
            else {
                value = node.value;
            }
            return value;
        }
        function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? 'checked' : 'value';
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
                checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = '' + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
                return;
            }
            var get = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
                configurable: true,
                get: function () {
                    return get.call(this);
                },
                set: function (value) {
                    {
                        checkFormFieldValueStringCoercion(value);
                    }
                    currentValue = '' + value;
                    set.call(this, value);
                }
            });
            Object.defineProperty(node, valueField, {
                enumerable: descriptor.enumerable
            });
            var tracker = {
                getValue: function () {
                    return currentValue;
                },
                setValue: function (value) {
                    {
                        checkFormFieldValueStringCoercion(value);
                    }
                    currentValue = '' + value;
                },
                stopTracking: function () {
                    detachTracker(node);
                    delete node[valueField];
                }
            };
            return tracker;
        }
        function track(node) {
            if (getTracker(node)) {
                return;
            }
            node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
            if (!node) {
                return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
                return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
                tracker.setValue(nextValue);
                return true;
            }
            return false;
        }
        function getActiveElement(doc) {
            doc = doc || (typeof document !== 'undefined' ? document : undefined);
            if (typeof doc === 'undefined') {
                return null;
            }
            try {
                return doc.activeElement || doc.body;
            }
            catch (e) {
                return doc.body;
            }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props) {
            var usesChecked = props.type === 'checkbox' || props.type === 'radio';
            return usesChecked ? props.checked != null : props.value != null;
        }
        function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = assign({}, props, {
                defaultChecked: undefined,
                defaultValue: undefined,
                value: undefined,
                checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
        }
        function initWrapperState(element, props) {
            {
                checkControlledValueProps('input', props);
                if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
                    error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
                    didWarnCheckedDefaultChecked = true;
                }
                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
                    error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
                    didWarnValueDefaultValue = true;
                }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? '' : props.defaultValue;
            node._wrapperState = {
                initialChecked: props.checked != null ? props.checked : props.defaultChecked,
                initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
                controlled: isControlled(props)
            };
        }
        function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
                setValueForProperty(node, 'checked', checked, false);
            }
        }
        function updateWrapper(element, props) {
            var node = element;
            {
                var controlled = isControlled(props);
                if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                    error('A component is changing an uncontrolled input to be controlled. ' + 'This is likely caused by the value changing from undefined to ' + 'a defined value, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');
                    didWarnUncontrolledToControlled = true;
                }
                if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                    error('A component is changing a controlled input to be uncontrolled. ' + 'This is likely caused by the value changing from a defined to ' + 'undefined, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');
                    didWarnControlledToUncontrolled = true;
                }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
                if (type === 'number') {
                    if (value === 0 && node.value === '' ||
                        node.value != value) {
                        node.value = toString(value);
                    }
                }
                else if (node.value !== toString(value)) {
                    node.value = toString(value);
                }
            }
            else if (type === 'submit' || type === 'reset') {
                node.removeAttribute('value');
                return;
            }
            {
                if (props.hasOwnProperty('value')) {
                    setDefaultValue(node, props.type, value);
                }
                else if (props.hasOwnProperty('defaultValue')) {
                    setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
                }
            }
            {
                if (props.checked == null && props.defaultChecked != null) {
                    node.defaultChecked = !!props.defaultChecked;
                }
            }
        }
        function postMountWrapper(element, props, isHydrating) {
            var node = element;
            if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
                var type = props.type;
                var isButton = type === 'submit' || type === 'reset';
                if (isButton && (props.value === undefined || props.value === null)) {
                    return;
                }
                var initialValue = toString(node._wrapperState.initialValue);
                if (!isHydrating) {
                    {
                        if (initialValue !== node.value) {
                            node.value = initialValue;
                        }
                    }
                }
                {
                    node.defaultValue = initialValue;
                }
            }
            var name = node.name;
            if (name !== '') {
                node.name = '';
            }
            {
                node.defaultChecked = !node.defaultChecked;
                node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name !== '') {
                node.name = name;
            }
        }
        function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
        }
        function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === 'radio' && name != null) {
                var queryRoot = rootNode;
                while (queryRoot.parentNode) {
                    queryRoot = queryRoot.parentNode;
                }
                {
                    checkAttributeStringCoercion(name, 'name');
                }
                var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
                for (var i = 0; i < group.length; i++) {
                    var otherNode = group[i];
                    if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                        continue;
                    }
                    var otherProps = getFiberCurrentPropsFromNode(otherNode);
                    if (!otherProps) {
                        throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.');
                    }
                    updateValueIfChanged(otherNode);
                    updateWrapper(otherNode, otherProps);
                }
            }
        }
        function setDefaultValue(node, type, value) {
            if (type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
                if (value == null) {
                    node.defaultValue = toString(node._wrapperState.initialValue);
                }
                else if (node.defaultValue !== toString(value)) {
                    node.defaultValue = toString(value);
                }
            }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element, props) {
            {
                if (props.value == null) {
                    if (typeof props.children === 'object' && props.children !== null) {
                        React.Children.forEach(props.children, function (child) {
                            if (child == null) {
                                return;
                            }
                            if (typeof child === 'string' || typeof child === 'number') {
                                return;
                            }
                            if (!didWarnInvalidChild) {
                                didWarnInvalidChild = true;
                                error('Cannot infer the option value of complex children. ' + 'Pass a `value` prop or use a plain string as children to <option>.');
                            }
                        });
                    }
                    else if (props.dangerouslySetInnerHTML != null) {
                        if (!didWarnInvalidInnerHTML) {
                            didWarnInvalidInnerHTML = true;
                            error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows ' + 'which value should be selected.');
                        }
                    }
                }
                if (props.selected != null && !didWarnSelectedSetOnOption) {
                    error('Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
                    didWarnSelectedSetOnOption = true;
                }
            }
        }
        function postMountWrapper$1(element, props) {
            if (props.value != null) {
                element.setAttribute('value', toString(getToStringValue(props.value)));
            }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        var didWarnValueDefaultValue$1;
        {
            didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
                return '\n\nCheck the render method of `' + ownerName + '`.';
            }
            return '';
        }
        var valuePropNames = ['value', 'defaultValue'];
        function checkSelectPropTypes(props) {
            {
                checkControlledValueProps('select', props);
                for (var i = 0; i < valuePropNames.length; i++) {
                    var propName = valuePropNames[i];
                    if (props[propName] == null) {
                        continue;
                    }
                    var propNameIsArray = isArray(props[propName]);
                    if (props.multiple && !propNameIsArray) {
                        error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
                    }
                    else if (!props.multiple && propNameIsArray) {
                        error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
                    }
                }
            }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options = node.options;
            if (multiple) {
                var selectedValues = propValue;
                var selectedValue = {};
                for (var i = 0; i < selectedValues.length; i++) {
                    selectedValue['$' + selectedValues[i]] = true;
                }
                for (var _i = 0; _i < options.length; _i++) {
                    var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
                    if (options[_i].selected !== selected) {
                        options[_i].selected = selected;
                    }
                    if (selected && setDefaultSelected) {
                        options[_i].defaultSelected = true;
                    }
                }
            }
            else {
                var _selectedValue = toString(getToStringValue(propValue));
                var defaultSelected = null;
                for (var _i2 = 0; _i2 < options.length; _i2++) {
                    if (options[_i2].value === _selectedValue) {
                        options[_i2].selected = true;
                        if (setDefaultSelected) {
                            options[_i2].defaultSelected = true;
                        }
                        return;
                    }
                    if (defaultSelected === null && !options[_i2].disabled) {
                        defaultSelected = options[_i2];
                    }
                }
                if (defaultSelected !== null) {
                    defaultSelected.selected = true;
                }
            }
        }
        function getHostProps$1(element, props) {
            return assign({}, props, {
                value: undefined
            });
        }
        function initWrapperState$1(element, props) {
            var node = element;
            {
                checkSelectPropTypes(props);
            }
            node._wrapperState = {
                wasMultiple: !!props.multiple
            };
            {
                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
                    error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');
                    didWarnValueDefaultValue$1 = true;
                }
            }
        }
        function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
                updateOptions(node, !!props.multiple, value, false);
            }
            else if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
        }
        function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
                updateOptions(node, !!props.multiple, value, false);
            }
            else if (wasMultiple !== !!props.multiple) {
                if (props.defaultValue != null) {
                    updateOptions(node, !!props.multiple, props.defaultValue, true);
                }
                else {
                    updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
                }
            }
        }
        function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
                updateOptions(node, !!props.multiple, value, false);
            }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
                throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');
            }
            var hostProps = assign({}, props, {
                value: undefined,
                defaultValue: undefined,
                children: toString(node._wrapperState.initialValue)
            });
            return hostProps;
        }
        function initWrapperState$2(element, props) {
            var node = element;
            {
                checkControlledValueProps('textarea', props);
                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
                    error('%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
                    didWarnValDefaultVal = true;
                }
            }
            var initialValue = props.value;
            if (initialValue == null) {
                var children = props.children, defaultValue = props.defaultValue;
                if (children != null) {
                    {
                        error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
                    }
                    {
                        if (defaultValue != null) {
                            throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');
                        }
                        if (isArray(children)) {
                            if (children.length > 1) {
                                throw new Error('<textarea> can only have at most one child.');
                            }
                            children = children[0];
                        }
                        defaultValue = children;
                    }
                }
                if (defaultValue == null) {
                    defaultValue = '';
                }
                initialValue = defaultValue;
            }
            node._wrapperState = {
                initialValue: getToStringValue(initialValue)
            };
        }
        function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
                var newValue = toString(value);
                if (newValue !== node.value) {
                    node.value = newValue;
                }
                if (props.defaultValue == null && node.defaultValue !== newValue) {
                    node.defaultValue = newValue;
                }
            }
            if (defaultValue != null) {
                node.defaultValue = toString(defaultValue);
            }
        }
        function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
                if (textContent !== '' && textContent !== null) {
                    node.value = textContent;
                }
            }
        }
        function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
        }
        var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
        var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
        var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
        function getIntrinsicNamespace(type) {
            switch (type) {
                case 'svg':
                    return SVG_NAMESPACE;
                case 'math':
                    return MATH_NAMESPACE;
                default:
                    return HTML_NAMESPACE;
            }
        }
        function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
                return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
                return HTML_NAMESPACE;
            }
            return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function (func) {
            if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
                return function (arg0, arg1, arg2, arg3) {
                    MSApp.execUnsafeLocalFunction(function () {
                        return func(arg0, arg1, arg2, arg3);
                    });
                };
            }
            else {
                return func;
            }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
                if (!('innerHTML' in node)) {
                    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
                    reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
                    var svgNode = reusableSVGContainer.firstChild;
                    while (node.firstChild) {
                        node.removeChild(node.firstChild);
                    }
                    while (svgNode.firstChild) {
                        node.appendChild(svgNode.firstChild);
                    }
                    return;
                }
            }
            node.innerHTML = html;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function (node, text) {
            if (text) {
                var firstChild = node.firstChild;
                if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                    firstChild.nodeValue = text;
                    return;
                }
            }
            node.textContent = text;
        };
        var shorthandToLonghand = {
            animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],
            background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],
            backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
            border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],
            borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
            borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
            borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
            borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
            borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],
            borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
            borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
            borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
            borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],
            borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
            borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
            borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
            borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
            columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
            columns: ['columnCount', 'columnWidth'],
            flex: ['flexBasis', 'flexGrow', 'flexShrink'],
            flexFlow: ['flexDirection', 'flexWrap'],
            font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],
            fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],
            gap: ['columnGap', 'rowGap'],
            grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
            gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
            gridColumn: ['gridColumnEnd', 'gridColumnStart'],
            gridColumnGap: ['columnGap'],
            gridGap: ['columnGap', 'rowGap'],
            gridRow: ['gridRowEnd', 'gridRowStart'],
            gridRowGap: ['rowGap'],
            gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
            listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
            margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
            marker: ['markerEnd', 'markerMid', 'markerStart'],
            mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],
            maskPosition: ['maskPositionX', 'maskPositionY'],
            outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
            overflow: ['overflowX', 'overflowY'],
            padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
            placeContent: ['alignContent', 'justifyContent'],
            placeItems: ['alignItems', 'justifyItems'],
            placeSelf: ['alignSelf', 'justifySelf'],
            textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
            textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
            transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
            wordWrap: ['overflowWrap']
        };
        var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
        };
        function prefixKey(prefix, key) {
            return prefix + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
        Object.keys(isUnitlessNumber).forEach(function (prop) {
            prefixes.forEach(function (prefix) {
                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
            });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === 'boolean' || value === '';
            if (isEmpty) {
                return '';
            }
            if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
                return value + 'px';
            }
            {
                checkCSSPropertyStringCoercion(value, name);
            }
            return ('' + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
        }
        var warnValidStyle = function () { };
        {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function (string) {
                return string.replace(hyphenPattern, function (_, character) {
                    return character.toUpperCase();
                });
            };
            var warnHyphenatedStyleName = function (name) {
                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                    return;
                }
                warnedStyleNames[name] = true;
                error('Unsupported style property %s. Did you mean %s?', name, camelize(name.replace(msPattern$1, 'ms-')));
            };
            var warnBadVendoredStyleName = function (name) {
                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                    return;
                }
                warnedStyleNames[name] = true;
                error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function (name, value) {
                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                    return;
                }
                warnedStyleValues[value] = true;
                error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
            };
            var warnStyleValueIsNaN = function (name, value) {
                if (warnedForNaNValue) {
                    return;
                }
                warnedForNaNValue = true;
                error('`NaN` is an invalid value for the `%s` css style property.', name);
            };
            var warnStyleValueIsInfinity = function (name, value) {
                if (warnedForInfinityValue) {
                    return;
                }
                warnedForInfinityValue = true;
                error('`Infinity` is an invalid value for the `%s` css style property.', name);
            };
            warnValidStyle = function (name, value) {
                if (name.indexOf('-') > -1) {
                    warnHyphenatedStyleName(name);
                }
                else if (badVendoredStyleNamePattern.test(name)) {
                    warnBadVendoredStyleName(name);
                }
                else if (badStyleValueWithSemicolonPattern.test(value)) {
                    warnStyleValueWithSemicolon(name, value);
                }
                if (typeof value === 'number') {
                    if (isNaN(value)) {
                        warnStyleValueIsNaN(name, value);
                    }
                    else if (!isFinite(value)) {
                        warnStyleValueIsInfinity(name, value);
                    }
                }
            };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
            {
                var serialized = '';
                var delimiter = '';
                for (var styleName in styles) {
                    if (!styles.hasOwnProperty(styleName)) {
                        continue;
                    }
                    var styleValue = styles[styleName];
                    if (styleValue != null) {
                        var isCustomProperty = styleName.indexOf('--') === 0;
                        serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';
                        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                        delimiter = ';';
                    }
                }
                return serialized || null;
            }
        }
        function setValueForStyles(node, styles) {
            var style = node.style;
            for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                    continue;
                }
                var isCustomProperty = styleName.indexOf('--') === 0;
                {
                    if (!isCustomProperty) {
                        warnValidStyle$1(styleName, styles[styleName]);
                    }
                }
                var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
                if (styleName === 'float') {
                    styleName = 'cssFloat';
                }
                if (isCustomProperty) {
                    style.setProperty(styleName, styleValue);
                }
                else {
                    style[styleName] = styleValue;
                }
            }
        }
        function isValueEmpty(value) {
            return value == null || typeof value === 'boolean' || value === '';
        }
        function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
                var longhands = shorthandToLonghand[key] || [key];
                for (var i = 0; i < longhands.length; i++) {
                    expanded[longhands[i]] = key;
                }
            }
            return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
                if (!nextStyles) {
                    return;
                }
                var expandedUpdates = expandShorthandMap(styleUpdates);
                var expandedStyles = expandShorthandMap(nextStyles);
                var warnedAbout = {};
                for (var key in expandedUpdates) {
                    var originalKey = expandedUpdates[key];
                    var correctOriginalKey = expandedStyles[key];
                    if (correctOriginalKey && originalKey !== correctOriginalKey) {
                        var warningKey = originalKey + ',' + correctOriginalKey;
                        if (warnedAbout[warningKey]) {
                            continue;
                        }
                        warnedAbout[warningKey] = true;
                        error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
                    }
                }
            }
        }
        var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        var voidElementTags = assign({
            menuitem: true
        }, omittedCloseTags);
        var HTML = '__html';
        function assertValidProps(tag, props) {
            if (!props) {
                return;
            }
            if (voidElementTags[tag]) {
                if (props.children != null || props.dangerouslySetInnerHTML != null) {
                    throw new Error(tag + " is a void element tag and must neither have `children` nor " + 'use `dangerouslySetInnerHTML`.');
                }
            }
            if (props.dangerouslySetInnerHTML != null) {
                if (props.children != null) {
                    throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
                }
                if (typeof props.dangerouslySetInnerHTML !== 'object' || !(HTML in props.dangerouslySetInnerHTML)) {
                    throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://reactjs.org/link/dangerously-set-inner-html ' + 'for more information.');
                }
            }
            {
                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                    error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
                }
            }
            if (props.style != null && typeof props.style !== 'object') {
                throw new Error('The `style` prop expects a mapping from style properties to values, ' + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + 'using JSX.');
            }
        }
        function isCustomComponent(tagName, props) {
            if (tagName.indexOf('-') === -1) {
                return typeof props.is === 'string';
            }
            switch (tagName) {
                case 'annotation-xml':
                case 'color-profile':
                case 'font-face':
                case 'font-face-src':
                case 'font-face-uri':
                case 'font-face-format':
                case 'font-face-name':
                case 'missing-glyph':
                    return false;
                default:
                    return true;
            }
        }
        var possibleStandardNames = {
            accept: 'accept',
            acceptcharset: 'acceptCharset',
            'accept-charset': 'acceptCharset',
            accesskey: 'accessKey',
            action: 'action',
            allowfullscreen: 'allowFullScreen',
            alt: 'alt',
            as: 'as',
            async: 'async',
            autocapitalize: 'autoCapitalize',
            autocomplete: 'autoComplete',
            autocorrect: 'autoCorrect',
            autofocus: 'autoFocus',
            autoplay: 'autoPlay',
            autosave: 'autoSave',
            capture: 'capture',
            cellpadding: 'cellPadding',
            cellspacing: 'cellSpacing',
            challenge: 'challenge',
            charset: 'charSet',
            checked: 'checked',
            children: 'children',
            cite: 'cite',
            class: 'className',
            classid: 'classID',
            classname: 'className',
            cols: 'cols',
            colspan: 'colSpan',
            content: 'content',
            contenteditable: 'contentEditable',
            contextmenu: 'contextMenu',
            controls: 'controls',
            controlslist: 'controlsList',
            coords: 'coords',
            crossorigin: 'crossOrigin',
            dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
            data: 'data',
            datetime: 'dateTime',
            default: 'default',
            defaultchecked: 'defaultChecked',
            defaultvalue: 'defaultValue',
            defer: 'defer',
            dir: 'dir',
            disabled: 'disabled',
            disablepictureinpicture: 'disablePictureInPicture',
            disableremoteplayback: 'disableRemotePlayback',
            download: 'download',
            draggable: 'draggable',
            enctype: 'encType',
            enterkeyhint: 'enterKeyHint',
            for: 'htmlFor',
            form: 'form',
            formmethod: 'formMethod',
            formaction: 'formAction',
            formenctype: 'formEncType',
            formnovalidate: 'formNoValidate',
            formtarget: 'formTarget',
            frameborder: 'frameBorder',
            headers: 'headers',
            height: 'height',
            hidden: 'hidden',
            high: 'high',
            href: 'href',
            hreflang: 'hrefLang',
            htmlfor: 'htmlFor',
            httpequiv: 'httpEquiv',
            'http-equiv': 'httpEquiv',
            icon: 'icon',
            id: 'id',
            imagesizes: 'imageSizes',
            imagesrcset: 'imageSrcSet',
            innerhtml: 'innerHTML',
            inputmode: 'inputMode',
            integrity: 'integrity',
            is: 'is',
            itemid: 'itemID',
            itemprop: 'itemProp',
            itemref: 'itemRef',
            itemscope: 'itemScope',
            itemtype: 'itemType',
            keyparams: 'keyParams',
            keytype: 'keyType',
            kind: 'kind',
            label: 'label',
            lang: 'lang',
            list: 'list',
            loop: 'loop',
            low: 'low',
            manifest: 'manifest',
            marginwidth: 'marginWidth',
            marginheight: 'marginHeight',
            max: 'max',
            maxlength: 'maxLength',
            media: 'media',
            mediagroup: 'mediaGroup',
            method: 'method',
            min: 'min',
            minlength: 'minLength',
            multiple: 'multiple',
            muted: 'muted',
            name: 'name',
            nomodule: 'noModule',
            nonce: 'nonce',
            novalidate: 'noValidate',
            open: 'open',
            optimum: 'optimum',
            pattern: 'pattern',
            placeholder: 'placeholder',
            playsinline: 'playsInline',
            poster: 'poster',
            preload: 'preload',
            profile: 'profile',
            radiogroup: 'radioGroup',
            readonly: 'readOnly',
            referrerpolicy: 'referrerPolicy',
            rel: 'rel',
            required: 'required',
            reversed: 'reversed',
            role: 'role',
            rows: 'rows',
            rowspan: 'rowSpan',
            sandbox: 'sandbox',
            scope: 'scope',
            scoped: 'scoped',
            scrolling: 'scrolling',
            seamless: 'seamless',
            selected: 'selected',
            shape: 'shape',
            size: 'size',
            sizes: 'sizes',
            span: 'span',
            spellcheck: 'spellCheck',
            src: 'src',
            srcdoc: 'srcDoc',
            srclang: 'srcLang',
            srcset: 'srcSet',
            start: 'start',
            step: 'step',
            style: 'style',
            summary: 'summary',
            tabindex: 'tabIndex',
            target: 'target',
            title: 'title',
            type: 'type',
            usemap: 'useMap',
            value: 'value',
            width: 'width',
            wmode: 'wmode',
            wrap: 'wrap',
            about: 'about',
            accentheight: 'accentHeight',
            'accent-height': 'accentHeight',
            accumulate: 'accumulate',
            additive: 'additive',
            alignmentbaseline: 'alignmentBaseline',
            'alignment-baseline': 'alignmentBaseline',
            allowreorder: 'allowReorder',
            alphabetic: 'alphabetic',
            amplitude: 'amplitude',
            arabicform: 'arabicForm',
            'arabic-form': 'arabicForm',
            ascent: 'ascent',
            attributename: 'attributeName',
            attributetype: 'attributeType',
            autoreverse: 'autoReverse',
            azimuth: 'azimuth',
            basefrequency: 'baseFrequency',
            baselineshift: 'baselineShift',
            'baseline-shift': 'baselineShift',
            baseprofile: 'baseProfile',
            bbox: 'bbox',
            begin: 'begin',
            bias: 'bias',
            by: 'by',
            calcmode: 'calcMode',
            capheight: 'capHeight',
            'cap-height': 'capHeight',
            clip: 'clip',
            clippath: 'clipPath',
            'clip-path': 'clipPath',
            clippathunits: 'clipPathUnits',
            cliprule: 'clipRule',
            'clip-rule': 'clipRule',
            color: 'color',
            colorinterpolation: 'colorInterpolation',
            'color-interpolation': 'colorInterpolation',
            colorinterpolationfilters: 'colorInterpolationFilters',
            'color-interpolation-filters': 'colorInterpolationFilters',
            colorprofile: 'colorProfile',
            'color-profile': 'colorProfile',
            colorrendering: 'colorRendering',
            'color-rendering': 'colorRendering',
            contentscripttype: 'contentScriptType',
            contentstyletype: 'contentStyleType',
            cursor: 'cursor',
            cx: 'cx',
            cy: 'cy',
            d: 'd',
            datatype: 'datatype',
            decelerate: 'decelerate',
            descent: 'descent',
            diffuseconstant: 'diffuseConstant',
            direction: 'direction',
            display: 'display',
            divisor: 'divisor',
            dominantbaseline: 'dominantBaseline',
            'dominant-baseline': 'dominantBaseline',
            dur: 'dur',
            dx: 'dx',
            dy: 'dy',
            edgemode: 'edgeMode',
            elevation: 'elevation',
            enablebackground: 'enableBackground',
            'enable-background': 'enableBackground',
            end: 'end',
            exponent: 'exponent',
            externalresourcesrequired: 'externalResourcesRequired',
            fill: 'fill',
            fillopacity: 'fillOpacity',
            'fill-opacity': 'fillOpacity',
            fillrule: 'fillRule',
            'fill-rule': 'fillRule',
            filter: 'filter',
            filterres: 'filterRes',
            filterunits: 'filterUnits',
            floodopacity: 'floodOpacity',
            'flood-opacity': 'floodOpacity',
            floodcolor: 'floodColor',
            'flood-color': 'floodColor',
            focusable: 'focusable',
            fontfamily: 'fontFamily',
            'font-family': 'fontFamily',
            fontsize: 'fontSize',
            'font-size': 'fontSize',
            fontsizeadjust: 'fontSizeAdjust',
            'font-size-adjust': 'fontSizeAdjust',
            fontstretch: 'fontStretch',
            'font-stretch': 'fontStretch',
            fontstyle: 'fontStyle',
            'font-style': 'fontStyle',
            fontvariant: 'fontVariant',
            'font-variant': 'fontVariant',
            fontweight: 'fontWeight',
            'font-weight': 'fontWeight',
            format: 'format',
            from: 'from',
            fx: 'fx',
            fy: 'fy',
            g1: 'g1',
            g2: 'g2',
            glyphname: 'glyphName',
            'glyph-name': 'glyphName',
            glyphorientationhorizontal: 'glyphOrientationHorizontal',
            'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
            glyphorientationvertical: 'glyphOrientationVertical',
            'glyph-orientation-vertical': 'glyphOrientationVertical',
            glyphref: 'glyphRef',
            gradienttransform: 'gradientTransform',
            gradientunits: 'gradientUnits',
            hanging: 'hanging',
            horizadvx: 'horizAdvX',
            'horiz-adv-x': 'horizAdvX',
            horizoriginx: 'horizOriginX',
            'horiz-origin-x': 'horizOriginX',
            ideographic: 'ideographic',
            imagerendering: 'imageRendering',
            'image-rendering': 'imageRendering',
            in2: 'in2',
            in: 'in',
            inlist: 'inlist',
            intercept: 'intercept',
            k1: 'k1',
            k2: 'k2',
            k3: 'k3',
            k4: 'k4',
            k: 'k',
            kernelmatrix: 'kernelMatrix',
            kernelunitlength: 'kernelUnitLength',
            kerning: 'kerning',
            keypoints: 'keyPoints',
            keysplines: 'keySplines',
            keytimes: 'keyTimes',
            lengthadjust: 'lengthAdjust',
            letterspacing: 'letterSpacing',
            'letter-spacing': 'letterSpacing',
            lightingcolor: 'lightingColor',
            'lighting-color': 'lightingColor',
            limitingconeangle: 'limitingConeAngle',
            local: 'local',
            markerend: 'markerEnd',
            'marker-end': 'markerEnd',
            markerheight: 'markerHeight',
            markermid: 'markerMid',
            'marker-mid': 'markerMid',
            markerstart: 'markerStart',
            'marker-start': 'markerStart',
            markerunits: 'markerUnits',
            markerwidth: 'markerWidth',
            mask: 'mask',
            maskcontentunits: 'maskContentUnits',
            maskunits: 'maskUnits',
            mathematical: 'mathematical',
            mode: 'mode',
            numoctaves: 'numOctaves',
            offset: 'offset',
            opacity: 'opacity',
            operator: 'operator',
            order: 'order',
            orient: 'orient',
            orientation: 'orientation',
            origin: 'origin',
            overflow: 'overflow',
            overlineposition: 'overlinePosition',
            'overline-position': 'overlinePosition',
            overlinethickness: 'overlineThickness',
            'overline-thickness': 'overlineThickness',
            paintorder: 'paintOrder',
            'paint-order': 'paintOrder',
            panose1: 'panose1',
            'panose-1': 'panose1',
            pathlength: 'pathLength',
            patterncontentunits: 'patternContentUnits',
            patterntransform: 'patternTransform',
            patternunits: 'patternUnits',
            pointerevents: 'pointerEvents',
            'pointer-events': 'pointerEvents',
            points: 'points',
            pointsatx: 'pointsAtX',
            pointsaty: 'pointsAtY',
            pointsatz: 'pointsAtZ',
            prefix: 'prefix',
            preservealpha: 'preserveAlpha',
            preserveaspectratio: 'preserveAspectRatio',
            primitiveunits: 'primitiveUnits',
            property: 'property',
            r: 'r',
            radius: 'radius',
            refx: 'refX',
            refy: 'refY',
            renderingintent: 'renderingIntent',
            'rendering-intent': 'renderingIntent',
            repeatcount: 'repeatCount',
            repeatdur: 'repeatDur',
            requiredextensions: 'requiredExtensions',
            requiredfeatures: 'requiredFeatures',
            resource: 'resource',
            restart: 'restart',
            result: 'result',
            results: 'results',
            rotate: 'rotate',
            rx: 'rx',
            ry: 'ry',
            scale: 'scale',
            security: 'security',
            seed: 'seed',
            shaperendering: 'shapeRendering',
            'shape-rendering': 'shapeRendering',
            slope: 'slope',
            spacing: 'spacing',
            specularconstant: 'specularConstant',
            specularexponent: 'specularExponent',
            speed: 'speed',
            spreadmethod: 'spreadMethod',
            startoffset: 'startOffset',
            stddeviation: 'stdDeviation',
            stemh: 'stemh',
            stemv: 'stemv',
            stitchtiles: 'stitchTiles',
            stopcolor: 'stopColor',
            'stop-color': 'stopColor',
            stopopacity: 'stopOpacity',
            'stop-opacity': 'stopOpacity',
            strikethroughposition: 'strikethroughPosition',
            'strikethrough-position': 'strikethroughPosition',
            strikethroughthickness: 'strikethroughThickness',
            'strikethrough-thickness': 'strikethroughThickness',
            string: 'string',
            stroke: 'stroke',
            strokedasharray: 'strokeDasharray',
            'stroke-dasharray': 'strokeDasharray',
            strokedashoffset: 'strokeDashoffset',
            'stroke-dashoffset': 'strokeDashoffset',
            strokelinecap: 'strokeLinecap',
            'stroke-linecap': 'strokeLinecap',
            strokelinejoin: 'strokeLinejoin',
            'stroke-linejoin': 'strokeLinejoin',
            strokemiterlimit: 'strokeMiterlimit',
            'stroke-miterlimit': 'strokeMiterlimit',
            strokewidth: 'strokeWidth',
            'stroke-width': 'strokeWidth',
            strokeopacity: 'strokeOpacity',
            'stroke-opacity': 'strokeOpacity',
            suppresscontenteditablewarning: 'suppressContentEditableWarning',
            suppresshydrationwarning: 'suppressHydrationWarning',
            surfacescale: 'surfaceScale',
            systemlanguage: 'systemLanguage',
            tablevalues: 'tableValues',
            targetx: 'targetX',
            targety: 'targetY',
            textanchor: 'textAnchor',
            'text-anchor': 'textAnchor',
            textdecoration: 'textDecoration',
            'text-decoration': 'textDecoration',
            textlength: 'textLength',
            textrendering: 'textRendering',
            'text-rendering': 'textRendering',
            to: 'to',
            transform: 'transform',
            typeof: 'typeof',
            u1: 'u1',
            u2: 'u2',
            underlineposition: 'underlinePosition',
            'underline-position': 'underlinePosition',
            underlinethickness: 'underlineThickness',
            'underline-thickness': 'underlineThickness',
            unicode: 'unicode',
            unicodebidi: 'unicodeBidi',
            'unicode-bidi': 'unicodeBidi',
            unicoderange: 'unicodeRange',
            'unicode-range': 'unicodeRange',
            unitsperem: 'unitsPerEm',
            'units-per-em': 'unitsPerEm',
            unselectable: 'unselectable',
            valphabetic: 'vAlphabetic',
            'v-alphabetic': 'vAlphabetic',
            values: 'values',
            vectoreffect: 'vectorEffect',
            'vector-effect': 'vectorEffect',
            version: 'version',
            vertadvy: 'vertAdvY',
            'vert-adv-y': 'vertAdvY',
            vertoriginx: 'vertOriginX',
            'vert-origin-x': 'vertOriginX',
            vertoriginy: 'vertOriginY',
            'vert-origin-y': 'vertOriginY',
            vhanging: 'vHanging',
            'v-hanging': 'vHanging',
            videographic: 'vIdeographic',
            'v-ideographic': 'vIdeographic',
            viewbox: 'viewBox',
            viewtarget: 'viewTarget',
            visibility: 'visibility',
            vmathematical: 'vMathematical',
            'v-mathematical': 'vMathematical',
            vocab: 'vocab',
            widths: 'widths',
            wordspacing: 'wordSpacing',
            'word-spacing': 'wordSpacing',
            writingmode: 'writingMode',
            'writing-mode': 'writingMode',
            x1: 'x1',
            x2: 'x2',
            x: 'x',
            xchannelselector: 'xChannelSelector',
            xheight: 'xHeight',
            'x-height': 'xHeight',
            xlinkactuate: 'xlinkActuate',
            'xlink:actuate': 'xlinkActuate',
            xlinkarcrole: 'xlinkArcrole',
            'xlink:arcrole': 'xlinkArcrole',
            xlinkhref: 'xlinkHref',
            'xlink:href': 'xlinkHref',
            xlinkrole: 'xlinkRole',
            'xlink:role': 'xlinkRole',
            xlinkshow: 'xlinkShow',
            'xlink:show': 'xlinkShow',
            xlinktitle: 'xlinkTitle',
            'xlink:title': 'xlinkTitle',
            xlinktype: 'xlinkType',
            'xlink:type': 'xlinkType',
            xmlbase: 'xmlBase',
            'xml:base': 'xmlBase',
            xmllang: 'xmlLang',
            'xml:lang': 'xmlLang',
            xmlns: 'xmlns',
            'xml:space': 'xmlSpace',
            xmlnsxlink: 'xmlnsXlink',
            'xmlns:xlink': 'xmlnsXlink',
            xmlspace: 'xmlSpace',
            y1: 'y1',
            y2: 'y2',
            y: 'y',
            ychannelselector: 'yChannelSelector',
            z: 'z',
            zoomandpan: 'zoomAndPan'
        };
        var ariaProperties = {
            'aria-current': 0,
            'aria-description': 0,
            'aria-details': 0,
            'aria-disabled': 0,
            'aria-hidden': 0,
            'aria-invalid': 0,
            'aria-keyshortcuts': 0,
            'aria-label': 0,
            'aria-roledescription': 0,
            'aria-autocomplete': 0,
            'aria-checked': 0,
            'aria-expanded': 0,
            'aria-haspopup': 0,
            'aria-level': 0,
            'aria-modal': 0,
            'aria-multiline': 0,
            'aria-multiselectable': 0,
            'aria-orientation': 0,
            'aria-placeholder': 0,
            'aria-pressed': 0,
            'aria-readonly': 0,
            'aria-required': 0,
            'aria-selected': 0,
            'aria-sort': 0,
            'aria-valuemax': 0,
            'aria-valuemin': 0,
            'aria-valuenow': 0,
            'aria-valuetext': 0,
            'aria-atomic': 0,
            'aria-busy': 0,
            'aria-live': 0,
            'aria-relevant': 0,
            'aria-dropeffect': 0,
            'aria-grabbed': 0,
            'aria-activedescendant': 0,
            'aria-colcount': 0,
            'aria-colindex': 0,
            'aria-colspan': 0,
            'aria-controls': 0,
            'aria-describedby': 0,
            'aria-errormessage': 0,
            'aria-flowto': 0,
            'aria-labelledby': 0,
            'aria-owns': 0,
            'aria-posinset': 0,
            'aria-rowcount': 0,
            'aria-rowindex': 0,
            'aria-rowspan': 0,
            'aria-setsize': 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
        var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
        function validateProperty(tagName, name) {
            {
                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                    return true;
                }
                if (rARIACamel.test(name)) {
                    var ariaName = 'aria-' + name.slice(4).toLowerCase();
                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                    if (correctName == null) {
                        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
                        warnedProperties[name] = true;
                        return true;
                    }
                    if (name !== correctName) {
                        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
                        warnedProperties[name] = true;
                        return true;
                    }
                }
                if (rARIA.test(name)) {
                    var lowerCasedName = name.toLowerCase();
                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                    if (standardName == null) {
                        warnedProperties[name] = true;
                        return false;
                    }
                    if (name !== standardName) {
                        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
                        warnedProperties[name] = true;
                        return true;
                    }
                }
            }
            return true;
        }
        function warnInvalidARIAProps(type, props) {
            {
                var invalidProps = [];
                for (var key in props) {
                    var isValid = validateProperty(type, key);
                    if (!isValid) {
                        invalidProps.push(key);
                    }
                }
                var unknownPropString = invalidProps.map(function (prop) {
                    return '`' + prop + '`';
                }).join(', ');
                if (invalidProps.length === 1) {
                    error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
                }
                else if (invalidProps.length > 1) {
                    error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
                }
            }
        }
        function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
                return;
            }
            warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
            {
                if (type !== 'input' && type !== 'textarea' && type !== 'select') {
                    return;
                }
                if (props != null && props.value === null && !didWarnValueNull) {
                    didWarnValueNull = true;
                    if (type === 'select' && props.multiple) {
                        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
                    }
                    else {
                        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
                    }
                }
            }
        }
        var validateProperty$1 = function () { };
        {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
            var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
            validateProperty$1 = function (tagName, name, value, eventRegistry) {
                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                    return true;
                }
                var lowerCasedName = name.toLowerCase();
                if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
                    error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
                    warnedProperties$1[name] = true;
                    return true;
                }
                if (eventRegistry != null) {
                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
                    if (registrationNameDependencies.hasOwnProperty(name)) {
                        return true;
                    }
                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                    if (registrationName != null) {
                        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (EVENT_NAME_REGEX.test(name)) {
                        error('Unknown event handler property `%s`. It will be ignored.', name);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                }
                else if (EVENT_NAME_REGEX.test(name)) {
                    if (INVALID_EVENT_NAME_REGEX.test(name)) {
                        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
                    }
                    warnedProperties$1[name] = true;
                    return true;
                }
                if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                    return true;
                }
                if (lowerCasedName === 'innerhtml') {
                    error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
                    warnedProperties$1[name] = true;
                    return true;
                }
                if (lowerCasedName === 'aria') {
                    error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
                    warnedProperties$1[name] = true;
                    return true;
                }
                if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
                    error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);
                    warnedProperties$1[name] = true;
                    return true;
                }
                if (typeof value === 'number' && isNaN(value)) {
                    error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
                    warnedProperties$1[name] = true;
                    return true;
                }
                var propertyInfo = getPropertyInfo(name);
                var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                    var standardName = possibleStandardNames[lowerCasedName];
                    if (standardName !== name) {
                        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                }
                else if (!isReserved && name !== lowerCasedName) {
                    error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
                    warnedProperties$1[name] = true;
                    return true;
                }
                if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                    if (value) {
                        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
                    }
                    else {
                        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                    }
                    warnedProperties$1[name] = true;
                    return true;
                }
                if (isReserved) {
                    return true;
                }
                if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                    warnedProperties$1[name] = true;
                    return false;
                }
                if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                    error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                    warnedProperties$1[name] = true;
                    return true;
                }
                return true;
            };
        }
        var warnUnknownProperties = function (type, props, eventRegistry) {
            {
                var unknownProps = [];
                for (var key in props) {
                    var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                    if (!isValid) {
                        unknownProps.push(key);
                    }
                }
                var unknownPropString = unknownProps.map(function (prop) {
                    return '`' + prop + '`';
                }).join(', ');
                if (unknownProps.length === 1) {
                    error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
                }
                else if (unknownProps.length > 1) {
                    error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
                }
            }
        };
        function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
                return;
            }
            warnUnknownProperties(type, props, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
            {
                if (currentReplayingEvent !== null) {
                    error('Expected currently replaying event to be null. This error ' + 'is likely caused by a bug in React. Please file an issue.');
                }
            }
            currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
            {
                if (currentReplayingEvent === null) {
                    error('Expected currently replaying event to not be null. This error ' + 'is likely caused by a bug in React. Please file an issue.');
                }
            }
            currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
            return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
                target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
                return;
            }
            if (typeof restoreImpl !== 'function') {
                throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled ' + 'events. This error is likely caused by a bug in React. Please file an issue.');
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
                var _props = getFiberCurrentPropsFromNode(stateNode);
                restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
        }
        function setRestoreImplementation(impl) {
            restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
            if (restoreTarget) {
                if (restoreQueue) {
                    restoreQueue.push(target);
                }
                else {
                    restoreQueue = [target];
                }
            }
            else {
                restoreTarget = target;
            }
        }
        function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
            if (!restoreTarget) {
                return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
                for (var i = 0; i < queuedTargets.length; i++) {
                    restoreStateOfTarget(queuedTargets[i]);
                }
            }
        }
        var batchedUpdatesImpl = function (fn, bookkeeping) {
            return fn(bookkeeping);
        };
        var flushSyncImpl = function () { };
        var isInsideEventHandler = false;
        function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
                flushSyncImpl();
                restoreStateIfNeeded();
            }
        }
        function batchedUpdates(fn, a, b) {
            if (isInsideEventHandler) {
                return fn(a, b);
            }
            isInsideEventHandler = true;
            try {
                return batchedUpdatesImpl(fn, a, b);
            }
            finally {
                isInsideEventHandler = false;
                finishEventHandler();
            }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
            return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
        }
        function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
                case 'onClick':
                case 'onClickCapture':
                case 'onDoubleClick':
                case 'onDoubleClickCapture':
                case 'onMouseDown':
                case 'onMouseDownCapture':
                case 'onMouseMove':
                case 'onMouseMoveCapture':
                case 'onMouseUp':
                case 'onMouseUpCapture':
                case 'onMouseEnter':
                    return !!(props.disabled && isInteractive(type));
                default:
                    return false;
            }
        }
        function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
                return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
                return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
                return null;
            }
            if (listener && typeof listener !== 'function') {
                throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM) {
            try {
                var options = {};
                Object.defineProperty(options, 'passive', {
                    get: function () {
                        passiveBrowserEventsSupported = true;
                    }
                });
                window.addEventListener('test', options, options);
                window.removeEventListener('test', options, options);
            }
            catch (e) {
                passiveBrowserEventsSupported = false;
            }
        }
        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
                func.apply(context, funcArgs);
            }
            catch (error) {
                this.onError(error);
            }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
            if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                var fakeNode = document.createElement('react');
                invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
                    if (typeof document === 'undefined' || document === null) {
                        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');
                    }
                    var evt = document.createEvent('Event');
                    var didCall = false;
                    var didError = true;
                    var windowEvent = window.event;
                    var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');
                    function restoreAfterDispatch() {
                        fakeNode.removeEventListener(evtType, callCallback, false);
                        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
                            window.event = windowEvent;
                        }
                    }
                    var funcArgs = Array.prototype.slice.call(arguments, 3);
                    function callCallback() {
                        didCall = true;
                        restoreAfterDispatch();
                        func.apply(context, funcArgs);
                        didError = false;
                    }
                    var error;
                    var didSetError = false;
                    var isCrossOriginError = false;
                    function handleWindowError(event) {
                        error = event.error;
                        didSetError = true;
                        if (error === null && event.colno === 0 && event.lineno === 0) {
                            isCrossOriginError = true;
                        }
                        if (event.defaultPrevented) {
                            if (error != null && typeof error === 'object') {
                                try {
                                    error._suppressLogging = true;
                                }
                                catch (inner) {
                                }
                            }
                        }
                    }
                    var evtType = "react-" + (name ? name : 'invokeguardedcallback');
                    window.addEventListener('error', handleWindowError);
                    fakeNode.addEventListener(evtType, callCallback, false);
                    evt.initEvent(evtType, false, false);
                    fakeNode.dispatchEvent(evt);
                    if (windowEventDescriptor) {
                        Object.defineProperty(window, 'event', windowEventDescriptor);
                    }
                    if (didCall && didError) {
                        if (!didSetError) {
                            error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
                        }
                        else if (isCrossOriginError) {
                            error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
                        }
                        this.onError(error);
                    }
                    window.removeEventListener('error', handleWindowError);
                    if (!didCall) {
                        restoreAfterDispatch();
                        return invokeGuardedCallbackProd.apply(this, arguments);
                    }
                };
            }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
            onError: function (error) {
                hasError = true;
                caughtError = error;
            }
        };
        function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
                var error = clearCaughtError();
                if (!hasRethrowError) {
                    hasRethrowError = true;
                    rethrowError = error;
                }
            }
        }
        function rethrowCaughtError() {
            if (hasRethrowError) {
                var error = rethrowError;
                hasRethrowError = false;
                rethrowError = null;
                throw error;
            }
        }
        function hasCaughtError() {
            return hasError;
        }
        function clearCaughtError() {
            if (hasError) {
                var error = caughtError;
                hasError = false;
                caughtError = null;
                return error;
            }
            else {
                throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');
            }
        }
        function get(key) {
            return key._reactInternals;
        }
        function has(key) {
            return key._reactInternals !== undefined;
        }
        function set(key, value) {
            key._reactInternals = value;
        }
        var NoFlags = 0;
        var PerformedWork = 1;
        var Placement = 2;
        var Update = 4;
        var ChildDeletion = 16;
        var ContentReset = 32;
        var Callback = 64;
        var DidCapture = 128;
        var ForceClientRender = 256;
        var Ref = 512;
        var Snapshot = 1024;
        var Passive = 2048;
        var Hydrating = 4096;
        var Visibility = 8192;
        var StoreConsistency = 16384;
        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
        var HostEffectMask = 32767;
        var Incomplete = 32768;
        var ShouldCapture = 65536;
        var ForceUpdateForLegacySuspense = 131072;
        var Forked = 1048576;
        var RefStatic = 2097152;
        var LayoutStatic = 4194304;
        var PassiveStatic = 8388608;
        var MountLayoutDev = 16777216;
        var MountPassiveDev = 33554432;
        var BeforeMutationMask = Update | Snapshot | (0);
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
                var nextNode = node;
                do {
                    node = nextNode;
                    if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                        nearestMounted = node.return;
                    }
                    nextNode = node.return;
                } while (nextNode);
            }
            else {
                while (node.return) {
                    node = node.return;
                }
            }
            if (node.tag === HostRoot) {
                return nearestMounted;
            }
            return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
                var suspenseState = fiber.memoizedState;
                if (suspenseState === null) {
                    var current = fiber.alternate;
                    if (current !== null) {
                        suspenseState = current.memoizedState;
                    }
                }
                if (suspenseState !== null) {
                    return suspenseState.dehydrated;
                }
            }
            return null;
        }
        function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
            {
                var owner = ReactCurrentOwner.current;
                if (owner !== null && owner.tag === ClassComponent) {
                    var ownerFiber = owner;
                    var instance = ownerFiber.stateNode;
                    if (!instance._warnedAboutRefsInRender) {
                        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');
                    }
                    instance._warnedAboutRefsInRender = true;
                }
            }
            var fiber = get(component);
            if (!fiber) {
                return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
                throw new Error('Unable to find node on an unmounted component.');
            }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
                var nearestMounted = getNearestMountedFiber(fiber);
                if (nearestMounted === null) {
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (nearestMounted !== fiber) {
                    return null;
                }
                return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
                var parentA = a.return;
                if (parentA === null) {
                    break;
                }
                var parentB = parentA.alternate;
                if (parentB === null) {
                    var nextParent = parentA.return;
                    if (nextParent !== null) {
                        a = b = nextParent;
                        continue;
                    }
                    break;
                }
                if (parentA.child === parentB.child) {
                    var child = parentA.child;
                    while (child) {
                        if (child === a) {
                            assertIsMounted(parentA);
                            return fiber;
                        }
                        if (child === b) {
                            assertIsMounted(parentA);
                            return alternate;
                        }
                        child = child.sibling;
                    }
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (a.return !== b.return) {
                    a = parentA;
                    b = parentB;
                }
                else {
                    var didFindChild = false;
                    var _child = parentA.child;
                    while (_child) {
                        if (_child === a) {
                            didFindChild = true;
                            a = parentA;
                            b = parentB;
                            break;
                        }
                        if (_child === b) {
                            didFindChild = true;
                            b = parentA;
                            a = parentB;
                            break;
                        }
                        _child = _child.sibling;
                    }
                    if (!didFindChild) {
                        _child = parentB.child;
                        while (_child) {
                            if (_child === a) {
                                didFindChild = true;
                                a = parentB;
                                b = parentA;
                                break;
                            }
                            if (_child === b) {
                                didFindChild = true;
                                b = parentB;
                                a = parentA;
                                break;
                            }
                            _child = _child.sibling;
                        }
                        if (!didFindChild) {
                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
                        }
                    }
                }
                if (a.alternate !== b) {
                    throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
                }
            }
            if (a.tag !== HostRoot) {
                throw new Error('Unable to find node on an unmounted component.');
            }
            if (a.stateNode.current === a) {
                return fiber;
            }
            return alternate;
        }
        function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
                return node;
            }
            var child = node.child;
            while (child !== null) {
                var match = findCurrentHostFiberImpl(child);
                if (match !== null) {
                    return match;
                }
                child = child.sibling;
            }
            return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
                return node;
            }
            var child = node.child;
            while (child !== null) {
                if (child.tag !== HostPortal) {
                    var match = findCurrentHostFiberWithNoPortalsImpl(child);
                    if (match !== null) {
                        return match;
                    }
                }
                child = child.sibling;
            }
            return null;
        }
        var scheduleCallback = Scheduler.unstable_scheduleCallback;
        var cancelCallback = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
        function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
                return true;
            }
            if (!hook.supportsFiber) {
                {
                    error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');
                }
                return true;
            }
            try {
                if (enableSchedulingProfiler) {
                    internals = assign({}, internals, {
                        getLaneLabelMap: getLaneLabelMap,
                        injectProfilingHooks: injectProfilingHooks
                    });
                }
                rendererID = hook.inject(internals);
                injectedHook = hook;
            }
            catch (err) {
                {
                    error('React instrumentation encountered an error: %s.', err);
                }
            }
            if (hook.checkDCE) {
                return true;
            }
            else {
                return false;
            }
        }
        function onScheduleRoot(root, children) {
            {
                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
                    try {
                        injectedHook.onScheduleFiberRoot(rendererID, root, children);
                    }
                    catch (err) {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function onCommitRoot(root, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
                try {
                    var didError = (root.current.flags & DidCapture) === DidCapture;
                    if (enableProfilerTimer) {
                        var schedulerPriority;
                        switch (eventPriority) {
                            case DiscreteEventPriority:
                                schedulerPriority = ImmediatePriority;
                                break;
                            case ContinuousEventPriority:
                                schedulerPriority = UserBlockingPriority;
                                break;
                            case DefaultEventPriority:
                                schedulerPriority = NormalPriority;
                                break;
                            case IdleEventPriority:
                                schedulerPriority = IdlePriority;
                                break;
                            default:
                                schedulerPriority = NormalPriority;
                                break;
                        }
                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
                    }
                    else {
                        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
                    }
                }
                catch (err) {
                    {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function onPostCommitRoot(root) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {
                try {
                    injectedHook.onPostCommitFiberRoot(rendererID, root);
                }
                catch (err) {
                    {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
                try {
                    injectedHook.onCommitFiberUnmount(rendererID, fiber);
                }
                catch (err) {
                    {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
            {
                if (typeof unstable_yieldValue === 'function') {
                    unstable_setDisableYieldValue(newIsStrictMode);
                    setSuppressWarning(newIsStrictMode);
                }
                if (injectedHook && typeof injectedHook.setStrictMode === 'function') {
                    try {
                        injectedHook.setStrictMode(rendererID, newIsStrictMode);
                    }
                    catch (err) {
                        {
                            if (!hasLoggedError) {
                                hasLoggedError = true;
                                error('React instrumentation encountered an error: %s', err);
                            }
                        }
                    }
                }
            }
        }
        function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
            {
                var map = new Map();
                var lane = 1;
                for (var index = 0; index < TotalLanes; index++) {
                    var label = getLabelForLane(lane);
                    map.set(lane, label);
                    lane *= 2;
                }
                return map;
            }
        }
        function markCommitStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {
                    injectedProfilingHooks.markCommitStarted(lanes);
                }
            }
        }
        function markCommitStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {
                    injectedProfilingHooks.markCommitStopped();
                }
            }
        }
        function markComponentRenderStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {
                    injectedProfilingHooks.markComponentRenderStarted(fiber);
                }
            }
        }
        function markComponentRenderStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {
                    injectedProfilingHooks.markComponentRenderStopped();
                }
            }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
                }
            }
        }
        function markComponentPassiveEffectMountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();
                }
            }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
                }
            }
        }
        function markComponentPassiveEffectUnmountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
                }
            }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
                }
            }
        }
        function markComponentLayoutEffectMountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();
                }
            }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
                }
            }
        }
        function markComponentLayoutEffectUnmountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
                }
            }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {
                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
                }
            }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {
                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
                }
            }
        }
        function markLayoutEffectsStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {
                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);
                }
            }
        }
        function markLayoutEffectsStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {
                    injectedProfilingHooks.markLayoutEffectsStopped();
                }
            }
        }
        function markPassiveEffectsStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {
                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);
                }
            }
        }
        function markPassiveEffectsStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {
                    injectedProfilingHooks.markPassiveEffectsStopped();
                }
            }
        }
        function markRenderStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {
                    injectedProfilingHooks.markRenderStarted(lanes);
                }
            }
        }
        function markRenderYielded() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {
                    injectedProfilingHooks.markRenderYielded();
                }
            }
        }
        function markRenderStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {
                    injectedProfilingHooks.markRenderStopped();
                }
            }
        }
        function markRenderScheduled(lane) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {
                    injectedProfilingHooks.markRenderScheduled(lane);
                }
            }
        }
        function markForceUpdateScheduled(fiber, lane) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {
                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
                }
            }
        }
        function markStateUpdateScheduled(fiber, lane) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {
                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
                }
            }
        }
        var NoMode = 0;
        var ConcurrentMode = 1;
        var ProfileMode = 2;
        var StrictLegacyMode = 8;
        var StrictEffectsMode = 16;
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
                return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = 0;
        var NoLane = 0;
        var SyncLane = 1;
        var InputContinuousHydrationLane = 2;
        var InputContinuousLane = 4;
        var DefaultHydrationLane = 8;
        var DefaultLane = 16;
        var TransitionHydrationLane = 32;
        var TransitionLanes = 4194240;
        var TransitionLane1 = 64;
        var TransitionLane2 = 128;
        var TransitionLane3 = 256;
        var TransitionLane4 = 512;
        var TransitionLane5 = 1024;
        var TransitionLane6 = 2048;
        var TransitionLane7 = 4096;
        var TransitionLane8 = 8192;
        var TransitionLane9 = 16384;
        var TransitionLane10 = 32768;
        var TransitionLane11 = 65536;
        var TransitionLane12 = 131072;
        var TransitionLane13 = 262144;
        var TransitionLane14 = 524288;
        var TransitionLane15 = 1048576;
        var TransitionLane16 = 2097152;
        var RetryLanes = 130023424;
        var RetryLane1 = 4194304;
        var RetryLane2 = 8388608;
        var RetryLane3 = 16777216;
        var RetryLane4 = 33554432;
        var RetryLane5 = 67108864;
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = 134217728;
        var NonIdleLanes = 268435455;
        var IdleHydrationLane = 268435456;
        var IdleLane = 536870912;
        var OffscreenLane = 1073741824;
        function getLabelForLane(lane) {
            {
                if (lane & SyncLane) {
                    return 'Sync';
                }
                if (lane & InputContinuousHydrationLane) {
                    return 'InputContinuousHydration';
                }
                if (lane & InputContinuousLane) {
                    return 'InputContinuous';
                }
                if (lane & DefaultHydrationLane) {
                    return 'DefaultHydration';
                }
                if (lane & DefaultLane) {
                    return 'Default';
                }
                if (lane & TransitionHydrationLane) {
                    return 'TransitionHydration';
                }
                if (lane & TransitionLanes) {
                    return 'Transition';
                }
                if (lane & RetryLanes) {
                    return 'Retry';
                }
                if (lane & SelectiveHydrationLane) {
                    return 'SelectiveHydration';
                }
                if (lane & IdleHydrationLane) {
                    return 'IdleHydration';
                }
                if (lane & IdleLane) {
                    return 'Idle';
                }
                if (lane & OffscreenLane) {
                    return 'Offscreen';
                }
            }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
                case SyncLane:
                    return SyncLane;
                case InputContinuousHydrationLane:
                    return InputContinuousHydrationLane;
                case InputContinuousLane:
                    return InputContinuousLane;
                case DefaultHydrationLane:
                    return DefaultHydrationLane;
                case DefaultLane:
                    return DefaultLane;
                case TransitionHydrationLane:
                    return TransitionHydrationLane;
                case TransitionLane1:
                case TransitionLane2:
                case TransitionLane3:
                case TransitionLane4:
                case TransitionLane5:
                case TransitionLane6:
                case TransitionLane7:
                case TransitionLane8:
                case TransitionLane9:
                case TransitionLane10:
                case TransitionLane11:
                case TransitionLane12:
                case TransitionLane13:
                case TransitionLane14:
                case TransitionLane15:
                case TransitionLane16:
                    return lanes & TransitionLanes;
                case RetryLane1:
                case RetryLane2:
                case RetryLane3:
                case RetryLane4:
                case RetryLane5:
                    return lanes & RetryLanes;
                case SelectiveHydrationLane:
                    return SelectiveHydrationLane;
                case IdleHydrationLane:
                    return IdleHydrationLane;
                case IdleLane:
                    return IdleLane;
                case OffscreenLane:
                    return OffscreenLane;
                default:
                    {
                        error('Should have found matching lanes. This is a bug in React.');
                    }
                    return lanes;
            }
        }
        function getNextLanes(root, wipLanes) {
            var pendingLanes = root.pendingLanes;
            if (pendingLanes === NoLanes) {
                return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root.suspendedLanes;
            var pingedLanes = root.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                if (nonIdleUnblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                }
                else {
                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                    if (nonIdlePingedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                    }
                }
            }
            else {
                var unblockedLanes = pendingLanes & ~suspendedLanes;
                if (unblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(unblockedLanes);
                }
                else {
                    if (pingedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(pingedLanes);
                    }
                }
            }
            if (nextLanes === NoLanes) {
                return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes &&
                (wipLanes & suspendedLanes) === NoLanes) {
                var nextLane = getHighestPriorityLane(nextLanes);
                var wipLane = getHighestPriorityLane(wipLanes);
                if (nextLane >= wipLane ||
                    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
                    return wipLanes;
                }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
                nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root.entangledLanes;
            if (entangledLanes !== NoLanes) {
                var entanglements = root.entanglements;
                var lanes = nextLanes & entangledLanes;
                while (lanes > 0) {
                    var index = pickArbitraryLaneIndex(lanes);
                    var lane = 1 << index;
                    nextLanes |= entanglements[index];
                    lanes &= ~lane;
                }
            }
            return nextLanes;
        }
        function getMostRecentEventTime(root, lanes) {
            var eventTimes = root.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                var eventTime = eventTimes[index];
                if (eventTime > mostRecentEventTime) {
                    mostRecentEventTime = eventTime;
                }
                lanes &= ~lane;
            }
            return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
            switch (lane) {
                case SyncLane:
                case InputContinuousHydrationLane:
                case InputContinuousLane:
                    return currentTime + 250;
                case DefaultHydrationLane:
                case DefaultLane:
                case TransitionHydrationLane:
                case TransitionLane1:
                case TransitionLane2:
                case TransitionLane3:
                case TransitionLane4:
                case TransitionLane5:
                case TransitionLane6:
                case TransitionLane7:
                case TransitionLane8:
                case TransitionLane9:
                case TransitionLane10:
                case TransitionLane11:
                case TransitionLane12:
                case TransitionLane13:
                case TransitionLane14:
                case TransitionLane15:
                case TransitionLane16:
                    return currentTime + 5000;
                case RetryLane1:
                case RetryLane2:
                case RetryLane3:
                case RetryLane4:
                case RetryLane5:
                    return NoTimestamp;
                case SelectiveHydrationLane:
                case IdleHydrationLane:
                case IdleLane:
                case OffscreenLane:
                    return NoTimestamp;
                default:
                    {
                        error('Should have found matching lanes. This is a bug in React.');
                    }
                    return NoTimestamp;
            }
        }
        function markStarvedLanesAsExpired(root, currentTime) {
            var pendingLanes = root.pendingLanes;
            var suspendedLanes = root.suspendedLanes;
            var pingedLanes = root.pingedLanes;
            var expirationTimes = root.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                var expirationTime = expirationTimes[index];
                if (expirationTime === NoTimestamp) {
                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                        expirationTimes[index] = computeExpirationTime(lane, currentTime);
                    }
                }
                else if (expirationTime <= currentTime) {
                    root.expiredLanes |= lane;
                }
                lanes &= ~lane;
            }
        }
        function getHighestPriorityPendingLanes(root) {
            return getHighestPriorityLanes(root.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root) {
            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
                return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
                return OffscreenLane;
            }
            return NoLanes;
        }
        function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root, lanes) {
            return (lanes & root.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
                nextTransitionLane = TransitionLane1;
            }
            return lane;
        }
        function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
                nextRetryLane = RetryLane1;
            }
            return lane;
        }
        function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
        }
        function isSubsetOfLanes(set, subset) {
            return (set & subset) === subset;
        }
        function mergeLanes(a, b) {
            return a | b;
        }
        function removeLanes(set, subset) {
            return set & ~subset;
        }
        function intersectLanes(a, b) {
            return a & b;
        }
        function laneToLanes(lane) {
            return lane;
        }
        function higherPriorityLane(a, b) {
            return a !== NoLane && a < b ? a : b;
        }
        function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
                laneMap.push(initial);
            }
            return laneMap;
        }
        function markRootUpdated(root, updateLane, eventTime) {
            root.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
                root.suspendedLanes = NoLanes;
                root.pingedLanes = NoLanes;
            }
            var eventTimes = root.eventTimes;
            var index = laneToIndex(updateLane);
            eventTimes[index] = eventTime;
        }
        function markRootSuspended(root, suspendedLanes) {
            root.suspendedLanes |= suspendedLanes;
            root.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                expirationTimes[index] = NoTimestamp;
                lanes &= ~lane;
            }
        }
        function markRootPinged(root, pingedLanes, eventTime) {
            root.pingedLanes |= root.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root, remainingLanes) {
            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
            root.pendingLanes = remainingLanes;
            root.suspendedLanes = NoLanes;
            root.pingedLanes = NoLanes;
            root.expiredLanes &= remainingLanes;
            root.mutableReadLanes &= remainingLanes;
            root.entangledLanes &= remainingLanes;
            var entanglements = root.entanglements;
            var eventTimes = root.eventTimes;
            var expirationTimes = root.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                entanglements[index] = NoLanes;
                eventTimes[index] = NoTimestamp;
                expirationTimes[index] = NoTimestamp;
                lanes &= ~lane;
            }
        }
        function markRootEntangled(root, entangledLanes) {
            var rootEntangledLanes = root.entangledLanes |= entangledLanes;
            var entanglements = root.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                if (lane & entangledLanes |
                    entanglements[index] & entangledLanes) {
                    entanglements[index] |= entangledLanes;
                }
                lanes &= ~lane;
            }
        }
        function getBumpedLaneForHydration(root, renderLanes) {
            var renderLane = getHighestPriorityLane(renderLanes);
            var lane;
            switch (renderLane) {
                case InputContinuousLane:
                    lane = InputContinuousHydrationLane;
                    break;
                case DefaultLane:
                    lane = DefaultHydrationLane;
                    break;
                case TransitionLane1:
                case TransitionLane2:
                case TransitionLane3:
                case TransitionLane4:
                case TransitionLane5:
                case TransitionLane6:
                case TransitionLane7:
                case TransitionLane8:
                case TransitionLane9:
                case TransitionLane10:
                case TransitionLane11:
                case TransitionLane12:
                case TransitionLane13:
                case TransitionLane14:
                case TransitionLane15:
                case TransitionLane16:
                case RetryLane1:
                case RetryLane2:
                case RetryLane3:
                case RetryLane4:
                case RetryLane5:
                    lane = TransitionHydrationLane;
                    break;
                case IdleLane:
                    lane = IdleHydrationLane;
                    break;
                default:
                    lane = NoLane;
                    break;
            }
            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
                return NoLane;
            }
            return lane;
        }
        function addFiberToLanesMap(root, fiber, lanes) {
            if (!isDevToolsPresent) {
                return;
            }
            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
            while (lanes > 0) {
                var index = laneToIndex(lanes);
                var lane = 1 << index;
                var updaters = pendingUpdatersLaneMap[index];
                updaters.add(fiber);
                lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root, lanes) {
            if (!isDevToolsPresent) {
                return;
            }
            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
            var memoizedUpdaters = root.memoizedUpdaters;
            while (lanes > 0) {
                var index = laneToIndex(lanes);
                var lane = 1 << index;
                var updaters = pendingUpdatersLaneMap[index];
                if (updaters.size > 0) {
                    updaters.forEach(function (fiber) {
                        var alternate = fiber.alternate;
                        if (alternate === null || !memoizedUpdaters.has(alternate)) {
                            memoizedUpdaters.add(fiber);
                        }
                    });
                    updaters.clear();
                }
                lanes &= ~lane;
            }
        }
        function getTransitionsForLanes(root, lanes) {
            {
                return null;
            }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
            return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn) {
            var previousPriority = currentUpdatePriority;
            try {
                currentUpdatePriority = priority;
                return fn();
            }
            finally {
                currentUpdatePriority = previousPriority;
            }
        }
        function higherEventPriority(a, b) {
            return a !== 0 && a < b ? a : b;
        }
        function lowerEventPriority(a, b) {
            return a === 0 || a > b ? a : b;
        }
        function isHigherEventPriority(a, b) {
            return a !== 0 && a < b;
        }
        function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
                return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
                return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
                return DefaultEventPriority;
            }
            return IdleEventPriority;
        }
        function isRootDehydrated(root) {
            var currentState = root.current.memoizedState;
            return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn) {
            _attemptSynchronousHydration = fn;
        }
        function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn) {
            getCurrentUpdatePriority$1 = fn;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn) {
            attemptHydrationAtPriority = fn;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = new Map();
        var queuedPointerCaptures = new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput',
            'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];
        function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
                blockedOn: blockedOn,
                domEventName: domEventName,
                eventSystemFlags: eventSystemFlags,
                nativeEvent: nativeEvent,
                targetContainers: [targetContainer]
            };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
                case 'focusin':
                case 'focusout':
                    queuedFocus = null;
                    break;
                case 'dragenter':
                case 'dragleave':
                    queuedDrag = null;
                    break;
                case 'mouseover':
                case 'mouseout':
                    queuedMouse = null;
                    break;
                case 'pointerover':
                case 'pointerout':
                    {
                        var pointerId = nativeEvent.pointerId;
                        queuedPointers.delete(pointerId);
                        break;
                    }
                case 'gotpointercapture':
                case 'lostpointercapture':
                    {
                        var _pointerId = nativeEvent.pointerId;
                        queuedPointerCaptures.delete(_pointerId);
                        break;
                    }
            }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
                var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (blockedOn !== null) {
                    var _fiber2 = getInstanceFromNode(blockedOn);
                    if (_fiber2 !== null) {
                        attemptContinuousHydration(_fiber2);
                    }
                }
                return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
                targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
                case 'focusin':
                    {
                        var focusEvent = nativeEvent;
                        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                        return true;
                    }
                case 'dragenter':
                    {
                        var dragEvent = nativeEvent;
                        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                        return true;
                    }
                case 'mouseover':
                    {
                        var mouseEvent = nativeEvent;
                        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                        return true;
                    }
                case 'pointerover':
                    {
                        var pointerEvent = nativeEvent;
                        var pointerId = pointerEvent.pointerId;
                        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                        return true;
                    }
                case 'gotpointercapture':
                    {
                        var _pointerEvent = nativeEvent;
                        var _pointerId2 = _pointerEvent.pointerId;
                        queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                        return true;
                    }
            }
            return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
                var nearestMounted = getNearestMountedFiber(targetInst);
                if (nearestMounted !== null) {
                    var tag = nearestMounted.tag;
                    if (tag === SuspenseComponent) {
                        var instance = getSuspenseInstanceFromFiber(nearestMounted);
                        if (instance !== null) {
                            queuedTarget.blockedOn = instance;
                            attemptHydrationAtPriority(queuedTarget.priority, function () {
                                attemptHydrationAtCurrentPriority(nearestMounted);
                            });
                            return;
                        }
                    }
                    else if (tag === HostRoot) {
                        var root = nearestMounted.stateNode;
                        if (isRootDehydrated(root)) {
                            queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                            return;
                        }
                    }
                }
            }
            queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
                blockedOn: null,
                target: target,
                priority: updatePriority
            };
            var i = 0;
            for (; i < queuedExplicitHydrationTargets.length; i++) {
                if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
                    break;
                }
            }
            queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
            if (i === 0) {
                attemptExplicitHydrationTarget(queuedTarget);
            }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
                return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
                var targetContainer = targetContainers[0];
                var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
                if (nextBlockedOn === null) {
                    {
                        var nativeEvent = queuedEvent.nativeEvent;
                        var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                        setReplayingEvent(nativeEventClone);
                        nativeEvent.target.dispatchEvent(nativeEventClone);
                        resetReplayingEvent();
                    }
                }
                else {
                    var _fiber3 = getInstanceFromNode(nextBlockedOn);
                    if (_fiber3 !== null) {
                        attemptContinuousHydration(_fiber3);
                    }
                    queuedEvent.blockedOn = nextBlockedOn;
                    return false;
                }
                targetContainers.shift();
            }
            return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
                map.delete(key);
            }
        }
        function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
                queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
                queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
                queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
                if (!hasScheduledReplayAttempt) {
                    hasScheduledReplayAttempt = true;
                    Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
                }
            }
        }
        function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
                scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
                for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                    var queuedEvent = queuedDiscreteEvents[i];
                    if (queuedEvent.blockedOn === unblocked) {
                        queuedEvent.blockedOn = null;
                    }
                }
            }
            if (queuedFocus !== null) {
                scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
                scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
                scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function (queuedEvent) {
                return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
                var queuedTarget = queuedExplicitHydrationTargets[_i];
                if (queuedTarget.blockedOn === unblocked) {
                    queuedTarget.blockedOn = null;
                }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
                var nextExplicitTarget = queuedExplicitHydrationTargets[0];
                if (nextExplicitTarget.blockedOn !== null) {
                    break;
                }
                else {
                    attemptExplicitHydrationTarget(nextExplicitTarget);
                    if (nextExplicitTarget.blockedOn === null) {
                        queuedExplicitHydrationTargets.shift();
                    }
                }
            }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
            _enabled = !!enabled;
        }
        function isEnabled() {
            return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
                case DiscreteEventPriority:
                    listenerWrapper = dispatchDiscreteEvent;
                    break;
                case ContinuousEventPriority:
                    listenerWrapper = dispatchContinuousEvent;
                    break;
                case DefaultEventPriority:
                default:
                    listenerWrapper = dispatchEvent;
                    break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
                setCurrentUpdatePriority(DiscreteEventPriority);
                dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            }
            finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig.transition = prevTransition;
            }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
                setCurrentUpdatePriority(ContinuousEventPriority);
                dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            }
            finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig.transition = prevTransition;
            }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
                return;
            }
            {
                dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                clearIfContinuousEvent(domEventName, nativeEvent);
                return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
                nativeEvent.stopPropagation();
                return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
                while (blockedOn !== null) {
                    var fiber = getInstanceFromNode(blockedOn);
                    if (fiber !== null) {
                        attemptSynchronousHydration(fiber);
                    }
                    var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                    if (nextBlockedOn === null) {
                        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                    }
                    if (nextBlockedOn === blockedOn) {
                        break;
                    }
                    blockedOn = nextBlockedOn;
                }
                if (blockedOn !== null) {
                    nativeEvent.stopPropagation();
                }
                return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
                var nearestMounted = getNearestMountedFiber(targetInst);
                if (nearestMounted === null) {
                    targetInst = null;
                }
                else {
                    var tag = nearestMounted.tag;
                    if (tag === SuspenseComponent) {
                        var instance = getSuspenseInstanceFromFiber(nearestMounted);
                        if (instance !== null) {
                            return instance;
                        }
                        targetInst = null;
                    }
                    else if (tag === HostRoot) {
                        var root = nearestMounted.stateNode;
                        if (isRootDehydrated(root)) {
                            return getContainerFromFiber(nearestMounted);
                        }
                        targetInst = null;
                    }
                    else if (nearestMounted !== targetInst) {
                        targetInst = null;
                    }
                }
            }
            return_targetInst = targetInst;
            return null;
        }
        function getEventPriority(domEventName) {
            switch (domEventName) {
                case 'cancel':
                case 'click':
                case 'close':
                case 'contextmenu':
                case 'copy':
                case 'cut':
                case 'auxclick':
                case 'dblclick':
                case 'dragend':
                case 'dragstart':
                case 'drop':
                case 'focusin':
                case 'focusout':
                case 'input':
                case 'invalid':
                case 'keydown':
                case 'keypress':
                case 'keyup':
                case 'mousedown':
                case 'mouseup':
                case 'paste':
                case 'pause':
                case 'play':
                case 'pointercancel':
                case 'pointerdown':
                case 'pointerup':
                case 'ratechange':
                case 'reset':
                case 'resize':
                case 'seeked':
                case 'submit':
                case 'touchcancel':
                case 'touchend':
                case 'touchstart':
                case 'volumechange':
                case 'change':
                case 'selectionchange':
                case 'textInput':
                case 'compositionstart':
                case 'compositionend':
                case 'compositionupdate':
                case 'beforeblur':
                case 'afterblur':
                case 'beforeinput':
                case 'blur':
                case 'fullscreenchange':
                case 'focus':
                case 'hashchange':
                case 'popstate':
                case 'select':
                case 'selectstart':
                    return DiscreteEventPriority;
                case 'drag':
                case 'dragenter':
                case 'dragexit':
                case 'dragleave':
                case 'dragover':
                case 'mousemove':
                case 'mouseout':
                case 'mouseover':
                case 'pointermove':
                case 'pointerout':
                case 'pointerover':
                case 'scroll':
                case 'toggle':
                case 'touchmove':
                case 'wheel':
                case 'mouseenter':
                case 'mouseleave':
                case 'pointerenter':
                case 'pointerleave':
                    return ContinuousEventPriority;
                case 'message':
                    {
                        var schedulerPriority = getCurrentPriorityLevel();
                        switch (schedulerPriority) {
                            case ImmediatePriority:
                                return DiscreteEventPriority;
                            case UserBlockingPriority:
                                return ContinuousEventPriority;
                            case NormalPriority:
                            case LowPriority:
                                return DefaultEventPriority;
                            case IdlePriority:
                                return IdleEventPriority;
                            default:
                                return DefaultEventPriority;
                        }
                    }
                default:
                    return DefaultEventPriority;
            }
        }
        function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
                capture: true,
                passive: passive
            });
            return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
                passive: passive
            });
            return listener;
        }
        var root = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
            root = nativeEventTarget;
            startText = getText();
            return true;
        }
        function reset() {
            root = null;
            startText = null;
            fallbackText = null;
        }
        function getData() {
            if (fallbackText) {
                return fallbackText;
            }
            var start;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText();
            var endLength = endValue.length;
            for (start = 0; start < startLength; start++) {
                if (startValue[start] !== endValue[start]) {
                    break;
                }
            }
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd; end++) {
                if (startValue[startLength - end] !== endValue[endLength - end]) {
                    break;
                }
            }
            var sliceTail = end > 1 ? 1 - end : undefined;
            fallbackText = endValue.slice(start, sliceTail);
            return fallbackText;
        }
        function getText() {
            if ('value' in root) {
                return root.value;
            }
            return root.textContent;
        }
        function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ('charCode' in nativeEvent) {
                charCode = nativeEvent.charCode;
                if (charCode === 0 && keyCode === 13) {
                    charCode = 13;
                }
            }
            else {
                charCode = keyCode;
            }
            if (charCode === 10) {
                charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
                return charCode;
            }
            return 0;
        }
        function functionThatReturnsTrue() {
            return true;
        }
        function functionThatReturnsFalse() {
            return false;
        }
        function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
                this._reactName = reactName;
                this._targetInst = targetInst;
                this.type = reactEventType;
                this.nativeEvent = nativeEvent;
                this.target = nativeEventTarget;
                this.currentTarget = null;
                for (var _propName in Interface) {
                    if (!Interface.hasOwnProperty(_propName)) {
                        continue;
                    }
                    var normalize = Interface[_propName];
                    if (normalize) {
                        this[_propName] = normalize(nativeEvent);
                    }
                    else {
                        this[_propName] = nativeEvent[_propName];
                    }
                }
                var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
                if (defaultPrevented) {
                    this.isDefaultPrevented = functionThatReturnsTrue;
                }
                else {
                    this.isDefaultPrevented = functionThatReturnsFalse;
                }
                this.isPropagationStopped = functionThatReturnsFalse;
                return this;
            }
            assign(SyntheticBaseEvent.prototype, {
                preventDefault: function () {
                    this.defaultPrevented = true;
                    var event = this.nativeEvent;
                    if (!event) {
                        return;
                    }
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    else if (typeof event.returnValue !== 'unknown') {
                        event.returnValue = false;
                    }
                    this.isDefaultPrevented = functionThatReturnsTrue;
                },
                stopPropagation: function () {
                    var event = this.nativeEvent;
                    if (!event) {
                        return;
                    }
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    else if (typeof event.cancelBubble !== 'unknown') {
                        event.cancelBubble = true;
                    }
                    this.isPropagationStopped = functionThatReturnsTrue;
                },
                persist: function () {
                },
                isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
        }
        var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (event) {
                return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
                if (lastMouseEvent && event.type === 'mousemove') {
                    lastMovementX = event.screenX - lastMouseEvent.screenX;
                    lastMovementY = event.screenY - lastMouseEvent.screenY;
                }
                else {
                    lastMovementX = 0;
                    lastMovementY = 0;
                }
                lastMouseEvent = event;
            }
        }
        var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function (event) {
                if (event.relatedTarget === undefined)
                    return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
                return event.relatedTarget;
            },
            movementX: function (event) {
                if ('movementX' in event) {
                    return event.movementX;
                }
                updateMouseMovementPolyfillState(event);
                return lastMovementX;
            },
            movementY: function (event) {
                if ('movementY' in event) {
                    return event.movementY;
                }
                return lastMovementY;
            }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function (event) {
                return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
            }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
            Esc: 'Escape',
            Spacebar: ' ',
            Left: 'ArrowLeft',
            Up: 'ArrowUp',
            Right: 'ArrowRight',
            Down: 'ArrowDown',
            Del: 'Delete',
            Win: 'OS',
            Menu: 'ContextMenu',
            Apps: 'ContextMenu',
            Scroll: 'ScrollLock',
            MozPrintableKey: 'Unidentified'
        };
        var translateToKey = {
            '8': 'Backspace',
            '9': 'Tab',
            '12': 'Clear',
            '13': 'Enter',
            '16': 'Shift',
            '17': 'Control',
            '18': 'Alt',
            '19': 'Pause',
            '20': 'CapsLock',
            '27': 'Escape',
            '32': ' ',
            '33': 'PageUp',
            '34': 'PageDown',
            '35': 'End',
            '36': 'Home',
            '37': 'ArrowLeft',
            '38': 'ArrowUp',
            '39': 'ArrowRight',
            '40': 'ArrowDown',
            '45': 'Insert',
            '46': 'Delete',
            '112': 'F1',
            '113': 'F2',
            '114': 'F3',
            '115': 'F4',
            '116': 'F5',
            '117': 'F6',
            '118': 'F7',
            '119': 'F8',
            '120': 'F9',
            '121': 'F10',
            '122': 'F11',
            '123': 'F12',
            '144': 'NumLock',
            '145': 'ScrollLock',
            '224': 'Meta'
        };
        function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if (key !== 'Unidentified') {
                    return key;
                }
            }
            if (nativeEvent.type === 'keypress') {
                var charCode = getEventCharCode(nativeEvent);
                return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
                return translateToKey[nativeEvent.keyCode] || 'Unidentified';
            }
            return '';
        }
        var modifierKeyToProp = {
            Alt: 'altKey',
            Control: 'ctrlKey',
            Meta: 'metaKey',
            Shift: 'shiftKey'
        };
        function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
                return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
        }
        var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function (event) {
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                return 0;
            },
            keyCode: function (event) {
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            },
            which: function (event) {
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function (event) {
                return 'deltaX' in event ? event.deltaX :
                    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function (event) {
                return 'deltaY' in event ? event.deltaY :
                    'wheelDeltaY' in event ? -event.wheelDeltaY :
                        'wheelDelta' in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;
        var documentMode = null;
        if (canUseDOM && 'documentMode' in document) {
            documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode;
        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
            registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);
            registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
            registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
            registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
                !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
            switch (domEventName) {
                case 'compositionstart':
                    return 'onCompositionStart';
                case 'compositionend':
                    return 'onCompositionEnd';
                case 'compositionupdate':
                    return 'onCompositionUpdate';
            }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
                case 'keyup':
                    return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
                case 'keydown':
                    return nativeEvent.keyCode !== START_KEYCODE;
                case 'keypress':
                case 'mousedown':
                case 'focusout':
                    return true;
                default:
                    return false;
            }
        }
        function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === 'object' && 'data' in detail) {
                return detail.data;
            }
            return null;
        }
        function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === 'ko';
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
                eventType = getCompositionEventType(domEventName);
            }
            else if (!isComposing) {
                if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                    eventType = 'onCompositionStart';
                }
            }
            else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
                eventType = 'onCompositionEnd';
            }
            if (!eventType) {
                return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
                if (!isComposing && eventType === 'onCompositionStart') {
                    isComposing = initialize(nativeEventTarget);
                }
                else if (eventType === 'onCompositionEnd') {
                    if (isComposing) {
                        fallbackData = getData();
                    }
                }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
                var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                    event: event,
                    listeners: listeners
                });
                if (fallbackData) {
                    event.data = fallbackData;
                }
                else {
                    var customData = getDataFromCustomEvent(nativeEvent);
                    if (customData !== null) {
                        event.data = customData;
                    }
                }
            }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
                case 'compositionend':
                    return getDataFromCustomEvent(nativeEvent);
                case 'keypress':
                    var which = nativeEvent.which;
                    if (which !== SPACEBAR_CODE) {
                        return null;
                    }
                    hasSpaceKeypress = true;
                    return SPACEBAR_CHAR;
                case 'textInput':
                    var chars = nativeEvent.data;
                    if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                        return null;
                    }
                    return chars;
                default:
                    return null;
            }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
                if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                    var chars = getData();
                    reset();
                    isComposing = false;
                    return chars;
                }
                return null;
            }
            switch (domEventName) {
                case 'paste':
                    return null;
                case 'keypress':
                    if (!isKeypressCommand(nativeEvent)) {
                        if (nativeEvent.char && nativeEvent.char.length > 1) {
                            return nativeEvent.char;
                        }
                        else if (nativeEvent.which) {
                            return String.fromCharCode(nativeEvent.which);
                        }
                    }
                    return null;
                case 'compositionend':
                    return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
                default:
                    return null;
            }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
                chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            }
            else {
                chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
                return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');
            if (listeners.length > 0) {
                var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                    event: event,
                    listeners: listeners
                });
                event.data = chars;
            }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            'datetime-local': true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
        };
        function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === 'input') {
                return !!supportedInputTypes[elem.type];
            }
            if (nodeName === 'textarea') {
                return true;
            }
            return false;
        }
        function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
                return false;
            }
            var eventName = 'on' + eventNameSuffix;
            var isSupported = (eventName in document);
            if (!isSupported) {
                var element = document.createElement('div');
                element.setAttribute(eventName, 'return;');
                isSupported = typeof element[eventName] === 'function';
            }
            return isSupported;
        }
        function registerEvents$1() {
            registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, 'onChange');
            if (listeners.length > 0) {
                var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);
                dispatchQueue.push({
                    event: event,
                    listeners: listeners
                });
            }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
        }
        function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
                return targetInst;
            }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === 'change') {
                return targetInst;
            }
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
            isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent('onpropertychange', handlePropertyChange);
        }
        function stopWatchingForValueChange() {
            if (!activeElement) {
                return;
            }
            activeElement.detachEvent('onpropertychange', handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== 'value') {
                return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
                manualDispatchChangeEvent(nativeEvent);
            }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === 'focusin') {
                stopWatchingForValueChange();
                startWatchingForValueChange(target, targetInst);
            }
            else if (domEventName === 'focusout') {
                stopWatchingForValueChange();
            }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {
                return getInstIfValueChanged(activeElementInst);
            }
        }
        function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === 'click') {
                return getInstIfValueChanged(targetInst);
            }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === 'input' || domEventName === 'change') {
                return getInstIfValueChanged(targetInst);
            }
        }
        function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== 'number') {
                return;
            }
            {
                setDefaultValue(node, 'number', node.value);
            }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
                getTargetInstFunc = getTargetInstForChangeEvent;
            }
            else if (isTextInputElement(targetNode)) {
                if (isInputEventSupported) {
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                }
                else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    handleEventFunc = handleEventsForInputEventPolyfill;
                }
            }
            else if (shouldUseClickEvent(targetNode)) {
                getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
                var inst = getTargetInstFunc(domEventName, targetInst);
                if (inst) {
                    createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                    return;
                }
            }
            if (handleEventFunc) {
                handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === 'focusout') {
                handleControlledInputBlur(targetNode);
            }
        }
        function registerEvents$2() {
            registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
            registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
            registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
            registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
            var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
                var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
                if (related) {
                    if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                        return;
                    }
                }
            }
            if (!isOutEvent && !isOverEvent) {
                return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
                win = nativeEventTarget;
            }
            else {
                var doc = nativeEventTarget.ownerDocument;
                if (doc) {
                    win = doc.defaultView || doc.parentWindow;
                }
                else {
                    win = window;
                }
            }
            var from;
            var to;
            if (isOutEvent) {
                var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
                from = targetInst;
                to = _related ? getClosestInstanceFromNode(_related) : null;
                if (to !== null) {
                    var nearestMounted = getNearestMountedFiber(to);
                    if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                        to = null;
                    }
                }
            }
            else {
                from = null;
                to = targetInst;
            }
            if (from === to) {
                return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = 'onMouseLeave';
            var enterEventType = 'onMouseEnter';
            var eventTypePrefix = 'mouse';
            if (domEventName === 'pointerout' || domEventName === 'pointerover') {
                SyntheticEventCtor = SyntheticPointerEvent;
                leaveEventType = 'onPointerLeave';
                enterEventType = 'onPointerEnter';
                eventTypePrefix = 'pointer';
            }
            var fromNode = from == null ? win : getNodeFromInstance(from);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
                var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);
                enterEvent.target = toNode;
                enterEvent.relatedTarget = fromNode;
                enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
        }
        function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === 'function' ? Object.is : is;
        function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
                return true;
            }
            if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
                return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
                return false;
            }
            for (var i = 0; i < keysA.length; i++) {
                var currentKey = keysA[i];
                if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                    return false;
                }
            }
            return true;
        }
        function getLeafNode(node) {
            while (node && node.firstChild) {
                node = node.firstChild;
            }
            return node;
        }
        function getSiblingNode(node) {
            while (node) {
                if (node.nextSibling) {
                    return node.nextSibling;
                }
                node = node.parentNode;
            }
        }
        function getNodeForCharacterOffset(root, offset) {
            var node = getLeafNode(root);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
                if (node.nodeType === TEXT_NODE) {
                    nodeEnd = nodeStart + node.textContent.length;
                    if (nodeStart <= offset && nodeEnd >= offset) {
                        return {
                            node: node,
                            offset: offset - nodeStart
                        };
                    }
                    nodeStart = nodeEnd;
                }
                node = getLeafNode(getSiblingNode(node));
            }
        }
        function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
                return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
                anchorNode.nodeType;
                focusNode.nodeType;
            }
            catch (e) {
                return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer: while (true) {
                var next = null;
                while (true) {
                    if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                        start = length + anchorOffset;
                    }
                    if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                        end = length + focusOffset;
                    }
                    if (node.nodeType === TEXT_NODE) {
                        length += node.nodeValue.length;
                    }
                    if ((next = node.firstChild) === null) {
                        break;
                    }
                    parentNode = node;
                    node = next;
                }
                while (true) {
                    if (node === outerNode) {
                        break outer;
                    }
                    if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                        start = length;
                    }
                    if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                        end = length;
                    }
                    if ((next = node.nextSibling) !== null) {
                        break;
                    }
                    node = parentNode;
                    parentNode = node.parentNode;
                }
                node = next;
            }
            if (start === -1 || end === -1) {
                return null;
            }
            return {
                start: start,
                end: end
            };
        }
        function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
                return;
            }
            var selection = win.getSelection();
            var length = node.textContent.length;
            var start = Math.min(offsets.start, length);
            var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
            if (!selection.extend && start > end) {
                var temp = end;
                end = start;
                start = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
                if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                    return;
                }
                var range = doc.createRange();
                range.setStart(startMarker.node, startMarker.offset);
                selection.removeAllRanges();
                if (start > end) {
                    selection.addRange(range);
                    selection.extend(endMarker.node, endMarker.offset);
                }
                else {
                    range.setEnd(endMarker.node, endMarker.offset);
                    selection.addRange(range);
                }
            }
        }
        function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
                return false;
            }
            else if (outerNode === innerNode) {
                return true;
            }
            else if (isTextNode(outerNode)) {
                return false;
            }
            else if (isTextNode(innerNode)) {
                return containsNode(outerNode, innerNode.parentNode);
            }
            else if ('contains' in outerNode) {
                return outerNode.contains(innerNode);
            }
            else if (outerNode.compareDocumentPosition) {
                return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            }
            else {
                return false;
            }
        }
        function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
        }
        function isSameOriginFrame(iframe) {
            try {
                return typeof iframe.contentWindow.location.href === 'string';
            }
            catch (err) {
                return false;
            }
        }
        function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
                if (isSameOriginFrame(element)) {
                    win = element.contentWindow;
                }
                else {
                    return element;
                }
                element = getActiveElement(win.document);
            }
            return element;
        }
        function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
        }
        function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
                focusedElem: focusedElem,
                selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
        }
        function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
                if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                    setSelection(priorFocusedElem, priorSelectionRange);
                }
                var ancestors = [];
                var ancestor = priorFocusedElem;
                while (ancestor = ancestor.parentNode) {
                    if (ancestor.nodeType === ELEMENT_NODE) {
                        ancestors.push({
                            element: ancestor,
                            left: ancestor.scrollLeft,
                            top: ancestor.scrollTop
                        });
                    }
                }
                if (typeof priorFocusedElem.focus === 'function') {
                    priorFocusedElem.focus();
                }
                for (var i = 0; i < ancestors.length; i++) {
                    var info = ancestors[i];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                }
            }
        }
        function getSelection(input) {
            var selection;
            if ('selectionStart' in input) {
                selection = {
                    start: input.selectionStart,
                    end: input.selectionEnd
                };
            }
            else {
                selection = getOffsets(input);
            }
            return selection || {
                start: 0,
                end: 0
            };
        }
        function setSelection(input, offsets) {
            var start = offsets.start;
            var end = offsets.end;
            if (end === undefined) {
                end = start;
            }
            if ('selectionStart' in input) {
                input.selectionStart = start;
                input.selectionEnd = Math.min(end, input.value.length);
            }
            else {
                setOffsets(input, offsets);
            }
        }
        var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;
        function registerEvents$3() {
            registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node) {
            if ('selectionStart' in node && hasSelectionCapabilities(node)) {
                return {
                    start: node.selectionStart,
                    end: node.selectionEnd
                };
            }
            else {
                var win = node.ownerDocument && node.ownerDocument.defaultView || window;
                var selection = win.getSelection();
                return {
                    anchorNode: selection.anchorNode,
                    anchorOffset: selection.anchorOffset,
                    focusNode: selection.focusNode,
                    focusOffset: selection.focusOffset
                };
            }
        }
        function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
                return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
                lastSelection = currentSelection;
                var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');
                if (listeners.length > 0) {
                    var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);
                    dispatchQueue.push({
                        event: event,
                        listeners: listeners
                    });
                    event.target = activeElement$1;
                }
            }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
                case 'focusin':
                    if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
                        activeElement$1 = targetNode;
                        activeElementInst$1 = targetInst;
                        lastSelection = null;
                    }
                    break;
                case 'focusout':
                    activeElement$1 = null;
                    activeElementInst$1 = null;
                    lastSelection = null;
                    break;
                case 'mousedown':
                    mouseDown = true;
                    break;
                case 'contextmenu':
                case 'mouseup':
                case 'dragend':
                    mouseDown = false;
                    constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                    break;
                case 'selectionchange':
                    if (skipSelectionChangeEvent) {
                        break;
                    }
                case 'keydown':
                case 'keyup':
                    constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
        }
        function makePrefixMap(styleProp, eventName) {
            var prefixes = {};
            prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes['Webkit' + styleProp] = 'webkit' + eventName;
            prefixes['Moz' + styleProp] = 'moz' + eventName;
            return prefixes;
        }
        var vendorPrefixes = {
            animationend: makePrefixMap('Animation', 'AnimationEnd'),
            animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
            animationstart: makePrefixMap('Animation', 'AnimationStart'),
            transitionend: makePrefixMap('Transition', 'TransitionEnd')
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM) {
            style = document.createElement('div').style;
            if (!('AnimationEvent' in window)) {
                delete vendorPrefixes.animationend.animation;
                delete vendorPrefixes.animationiteration.animation;
                delete vendorPrefixes.animationstart.animation;
            }
            if (!('TransitionEvent' in window)) {
                delete vendorPrefixes.transitionend.transition;
            }
        }
        function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
                return prefixedEventNames[eventName];
            }
            else if (!vendorPrefixes[eventName]) {
                return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
                if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                    return prefixedEventNames[eventName] = prefixMap[styleProp];
                }
            }
            return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName('animationend');
        var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');
        var ANIMATION_START = getVendorPrefixedEventName('animationstart');
        var TRANSITION_END = getVendorPrefixedEventName('transitionend');
        var topLevelEventsToReactNames = new Map();
        var simpleEventPluginEvents = ['abort', 'auxClick', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'gotPointerCapture', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'lostPointerCapture', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'pointerCancel', 'pointerDown', 'pointerMove', 'pointerOut', 'pointerOver', 'pointerUp', 'progress', 'rateChange', 'reset', 'resize', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchStart', 'volumeChange', 'scroll', 'toggle', 'touchMove', 'waiting', 'wheel'];
        function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
            for (var i = 0; i < simpleEventPluginEvents.length; i++) {
                var eventName = simpleEventPluginEvents[i];
                var domEventName = eventName.toLowerCase();
                var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
                registerSimpleEvent(domEventName, 'on' + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, 'onAnimationEnd');
            registerSimpleEvent(ANIMATION_ITERATION, 'onAnimationIteration');
            registerSimpleEvent(ANIMATION_START, 'onAnimationStart');
            registerSimpleEvent('dblclick', 'onDoubleClick');
            registerSimpleEvent('focusin', 'onFocus');
            registerSimpleEvent('focusout', 'onBlur');
            registerSimpleEvent(TRANSITION_END, 'onTransitionEnd');
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === undefined) {
                return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
                case 'keypress':
                    if (getEventCharCode(nativeEvent) === 0) {
                        return;
                    }
                case 'keydown':
                case 'keyup':
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                case 'focusin':
                    reactEventType = 'focus';
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                case 'focusout':
                    reactEventType = 'blur';
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                case 'beforeblur':
                case 'afterblur':
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                case 'click':
                    if (nativeEvent.button === 2) {
                        return;
                    }
                case 'auxclick':
                case 'dblclick':
                case 'mousedown':
                case 'mousemove':
                case 'mouseup':
                case 'mouseout':
                case 'mouseover':
                case 'contextmenu':
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                case 'drag':
                case 'dragend':
                case 'dragenter':
                case 'dragexit':
                case 'dragleave':
                case 'dragover':
                case 'dragstart':
                case 'drop':
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                case 'touchcancel':
                case 'touchend':
                case 'touchmove':
                case 'touchstart':
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                case 'scroll':
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                case 'wheel':
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                case 'copy':
                case 'cut':
                case 'paste':
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                case 'gotpointercapture':
                case 'lostpointercapture':
                case 'pointercancel':
                case 'pointerdown':
                case 'pointermove':
                case 'pointerout':
                case 'pointerover':
                case 'pointerup':
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
                var accumulateTargetOnly = !inCapturePhase &&
                    domEventName === 'scroll';
                var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
                if (_listeners.length > 0) {
                    var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                    dispatchQueue.push({
                        event: _event,
                        listeners: _listeners
                    });
                }
            }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
                extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
                extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
                extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
                extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
        }
        var mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'resize', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting'];
        var nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
            var type = event.type || 'unknown-event';
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
            event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
                for (var i = dispatchListeners.length - 1; i >= 0; i--) {
                    var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                    if (instance !== previousInstance && event.isPropagationStopped()) {
                        return;
                    }
                    executeDispatch(event, listener, currentTarget);
                    previousInstance = instance;
                }
            }
            else {
                for (var _i = 0; _i < dispatchListeners.length; _i++) {
                    var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                    if (_instance !== previousInstance && event.isPropagationStopped()) {
                        return;
                    }
                    executeDispatch(event, _listener, _currentTarget);
                    previousInstance = _instance;
                }
            }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i = 0; i < dispatchQueue.length; i++) {
                var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
                processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
                if (!nonDelegatedEvents.has(domEventName)) {
                    error('Did not expect a listenToNonDelegatedEvent() call for "%s". ' + 'This is a bug in React. Please file an issue.', domEventName);
                }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
                addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
                listenerSet.add(listenerSetKey);
            }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
                if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                    error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. ' + 'This is a bug in React. Please file an issue.', domEventName);
                }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
                eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
                rootContainerElement[listeningMarker] = true;
                allNativeEvents.forEach(function (domEventName) {
                    if (domEventName !== 'selectionchange') {
                        if (!nonDelegatedEvents.has(domEventName)) {
                            listenToNativeEvent(domEventName, false, rootContainerElement);
                        }
                        listenToNativeEvent(domEventName, true, rootContainerElement);
                    }
                });
                var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
                if (ownerDocument !== null) {
                    if (!ownerDocument[listeningMarker]) {
                        ownerDocument[listeningMarker] = true;
                        listenToNativeEvent('selectionchange', false, ownerDocument);
                    }
                }
            }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = undefined;
            if (passiveBrowserEventsSupported) {
                if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {
                    isPassiveListener = true;
                }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
                if (isPassiveListener !== undefined) {
                    unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
                }
                else {
                    unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
                }
            }
            else {
                if (isPassiveListener !== undefined) {
                    unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
                }
                else {
                    unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
                }
            }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
                var targetContainerNode = targetContainer;
                if (targetInst !== null) {
                    var node = targetInst;
                    mainLoop: while (true) {
                        if (node === null) {
                            return;
                        }
                        var nodeTag = node.tag;
                        if (nodeTag === HostRoot || nodeTag === HostPortal) {
                            var container = node.stateNode.containerInfo;
                            if (isMatchingRootContainer(container, targetContainerNode)) {
                                break;
                            }
                            if (nodeTag === HostPortal) {
                                var grandNode = node.return;
                                while (grandNode !== null) {
                                    var grandTag = grandNode.tag;
                                    if (grandTag === HostRoot || grandTag === HostPortal) {
                                        var grandContainer = grandNode.stateNode.containerInfo;
                                        if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                                            return;
                                        }
                                    }
                                    grandNode = grandNode.return;
                                }
                            }
                            while (container !== null) {
                                var parentNode = getClosestInstanceFromNode(container);
                                if (parentNode === null) {
                                    return;
                                }
                                var parentTag = parentNode.tag;
                                if (parentTag === HostComponent || parentTag === HostText) {
                                    node = ancestorInst = parentNode;
                                    continue mainLoop;
                                }
                                container = container.parentNode;
                            }
                        }
                        node = node.return;
                    }
                }
            }
            batchedUpdates(function () {
                return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
        }
        function createDispatchListener(instance, listener, currentTarget) {
            return {
                instance: instance,
                listener: listener,
                currentTarget: currentTarget
            };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + 'Capture' : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
                var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
                if (tag === HostComponent && stateNode !== null) {
                    lastHostComponent = stateNode;
                    if (reactEventName !== null) {
                        var listener = getListener(instance, reactEventName);
                        if (listener != null) {
                            listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                        }
                    }
                }
                if (accumulateTargetOnly) {
                    break;
                }
                instance = instance.return;
            }
            return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + 'Capture';
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
                var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
                if (tag === HostComponent && stateNode !== null) {
                    var currentTarget = stateNode;
                    var captureListener = getListener(instance, captureName);
                    if (captureListener != null) {
                        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                    }
                    var bubbleListener = getListener(instance, reactName);
                    if (bubbleListener != null) {
                        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                    }
                }
                instance = instance.return;
            }
            return listeners;
        }
        function getParent(inst) {
            if (inst === null) {
                return null;
            }
            do {
                inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
                return inst;
            }
            return null;
        }
        function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
                depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
                depthB++;
            }
            while (depthA - depthB > 0) {
                nodeA = getParent(nodeA);
                depthA--;
            }
            while (depthB - depthA > 0) {
                nodeB = getParent(nodeB);
                depthB--;
            }
            var depth = depthA;
            while (depth--) {
                if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                    return nodeA;
                }
                nodeA = getParent(nodeA);
                nodeB = getParent(nodeB);
            }
            return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
                if (instance === common) {
                    break;
                }
                var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
                if (alternate !== null && alternate === common) {
                    break;
                }
                if (tag === HostComponent && stateNode !== null) {
                    var currentTarget = stateNode;
                    if (inCapturePhase) {
                        var captureListener = getListener(instance, registrationName);
                        if (captureListener != null) {
                            listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                        }
                    }
                    else if (!inCapturePhase) {
                        var bubbleListener = getListener(instance, registrationName);
                        if (bubbleListener != null) {
                            listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                        }
                    }
                }
                instance = instance.return;
            }
            if (listeners.length !== 0) {
                dispatchQueue.push({
                    event: event,
                    listeners: listeners
                });
            }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
            var common = from && to ? getLowestCommonAncestor(from, to) : null;
            if (from !== null) {
                accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
            }
            if (to !== null && enterEvent !== null) {
                accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
        }
        function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? 'capture' : 'bubble');
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
        var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
        var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
        var AUTOFOCUS = 'autoFocus';
        var CHILDREN = 'children';
        var STYLE = 'style';
        var HTML$1 = '__html';
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
            warnedUnknownTags = {
                dialog: true,
                webview: true
            };
            validatePropertiesInDevelopment = function (type, props) {
                validateProperties(type, props);
                validateProperties$1(type, props);
                validateProperties$2(type, props, {
                    registrationNameDependencies: registrationNameDependencies,
                    possibleRegistrationNames: possibleRegistrationNames
                });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function (propName, serverValue, clientValue) {
                if (didWarnInvalidHydration) {
                    return;
                }
                var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
                var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
                if (normalizedServerValue === normalizedClientValue) {
                    return;
                }
                didWarnInvalidHydration = true;
                error('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function (attributeNames) {
                if (didWarnInvalidHydration) {
                    return;
                }
                didWarnInvalidHydration = true;
                var names = [];
                attributeNames.forEach(function (name) {
                    names.push(name);
                });
                error('Extra attributes from the server: %s', names);
            };
            warnForInvalidEventListener = function (registrationName, listener) {
                if (listener === false) {
                    error('Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
                }
                else {
                    error('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
                }
            };
            normalizeHTML = function (parent, html) {
                var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
                testElement.innerHTML = html;
                return testElement.innerHTML;
            };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
            {
                checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === 'string' ? markup : '' + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
                return;
            }
            if (shouldWarnDev) {
                {
                    if (!didWarnInvalidHydration) {
                        didWarnInvalidHydration = true;
                        error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                    }
                }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
                throw new Error('Text content does not match server-rendered HTML.');
            }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop() { }
        function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
                if (!nextProps.hasOwnProperty(propKey)) {
                    continue;
                }
                var nextProp = nextProps[propKey];
                if (propKey === STYLE) {
                    {
                        if (nextProp) {
                            Object.freeze(nextProp);
                        }
                    }
                    setValueForStyles(domElement, nextProp);
                }
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                    var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                    if (nextHtml != null) {
                        setInnerHTML(domElement, nextHtml);
                    }
                }
                else if (propKey === CHILDREN) {
                    if (typeof nextProp === 'string') {
                        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
                        if (canSetTextContent) {
                            setTextContent(domElement, nextProp);
                        }
                    }
                    else if (typeof nextProp === 'number') {
                        setTextContent(domElement, '' + nextProp);
                    }
                }
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                    ;
                else if (propKey === AUTOFOCUS)
                    ;
                else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                    if (nextProp != null) {
                        if (typeof nextProp !== 'function') {
                            warnForInvalidEventListener(propKey, nextProp);
                        }
                        if (propKey === 'onScroll') {
                            listenToNonDelegatedEvent('scroll', domElement);
                        }
                    }
                }
                else if (nextProp != null) {
                    setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
                }
            }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
                var propKey = updatePayload[i];
                var propValue = updatePayload[i + 1];
                if (propKey === STYLE) {
                    setValueForStyles(domElement, propValue);
                }
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                    setInnerHTML(domElement, propValue);
                }
                else if (propKey === CHILDREN) {
                    setTextContent(domElement, propValue);
                }
                else {
                    setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
                }
            }
        }
        function createElement(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
                namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
                {
                    isCustomComponentTag = isCustomComponent(type, props);
                    if (!isCustomComponentTag && type !== type.toLowerCase()) {
                        error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type);
                    }
                }
                if (type === 'script') {
                    var div = ownerDocument.createElement('div');
                    div.innerHTML = '<script><' + '/script>';
                    var firstChild = div.firstChild;
                    domElement = div.removeChild(firstChild);
                }
                else if (typeof props.is === 'string') {
                    domElement = ownerDocument.createElement(type, {
                        is: props.is
                    });
                }
                else {
                    domElement = ownerDocument.createElement(type);
                    if (type === 'select') {
                        var node = domElement;
                        if (props.multiple) {
                            node.multiple = true;
                        }
                        else if (props.size) {
                            node.size = props.size;
                        }
                    }
                }
            }
            else {
                domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
                if (namespaceURI === HTML_NAMESPACE) {
                    if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !hasOwnProperty.call(warnedUnknownTags, type)) {
                        warnedUnknownTags[type] = true;
                        error('The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
                    }
                }
            }
            return domElement;
        }
        function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
                validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
                case 'dialog':
                    listenToNonDelegatedEvent('cancel', domElement);
                    listenToNonDelegatedEvent('close', domElement);
                    props = rawProps;
                    break;
                case 'iframe':
                case 'object':
                case 'embed':
                    listenToNonDelegatedEvent('load', domElement);
                    props = rawProps;
                    break;
                case 'video':
                case 'audio':
                    for (var i = 0; i < mediaEventTypes.length; i++) {
                        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                    }
                    props = rawProps;
                    break;
                case 'source':
                    listenToNonDelegatedEvent('error', domElement);
                    props = rawProps;
                    break;
                case 'img':
                case 'image':
                case 'link':
                    listenToNonDelegatedEvent('error', domElement);
                    listenToNonDelegatedEvent('load', domElement);
                    props = rawProps;
                    break;
                case 'details':
                    listenToNonDelegatedEvent('toggle', domElement);
                    props = rawProps;
                    break;
                case 'input':
                    initWrapperState(domElement, rawProps);
                    props = getHostProps(domElement, rawProps);
                    listenToNonDelegatedEvent('invalid', domElement);
                    break;
                case 'option':
                    validateProps(domElement, rawProps);
                    props = rawProps;
                    break;
                case 'select':
                    initWrapperState$1(domElement, rawProps);
                    props = getHostProps$1(domElement, rawProps);
                    listenToNonDelegatedEvent('invalid', domElement);
                    break;
                case 'textarea':
                    initWrapperState$2(domElement, rawProps);
                    props = getHostProps$2(domElement, rawProps);
                    listenToNonDelegatedEvent('invalid', domElement);
                    break;
                default:
                    props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
                case 'input':
                    track(domElement);
                    postMountWrapper(domElement, rawProps, false);
                    break;
                case 'textarea':
                    track(domElement);
                    postMountWrapper$3(domElement);
                    break;
                case 'option':
                    postMountWrapper$1(domElement, rawProps);
                    break;
                case 'select':
                    postMountWrapper$2(domElement, rawProps);
                    break;
                default:
                    if (typeof props.onClick === 'function') {
                        trapClickOnNonInteractiveElement(domElement);
                    }
                    break;
            }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
                validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
                case 'input':
                    lastProps = getHostProps(domElement, lastRawProps);
                    nextProps = getHostProps(domElement, nextRawProps);
                    updatePayload = [];
                    break;
                case 'select':
                    lastProps = getHostProps$1(domElement, lastRawProps);
                    nextProps = getHostProps$1(domElement, nextRawProps);
                    updatePayload = [];
                    break;
                case 'textarea':
                    lastProps = getHostProps$2(domElement, lastRawProps);
                    nextProps = getHostProps$2(domElement, nextRawProps);
                    updatePayload = [];
                    break;
                default:
                    lastProps = lastRawProps;
                    nextProps = nextRawProps;
                    if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
                        trapClickOnNonInteractiveElement(domElement);
                    }
                    break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
                if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                    continue;
                }
                if (propKey === STYLE) {
                    var lastStyle = lastProps[propKey];
                    for (styleName in lastStyle) {
                        if (lastStyle.hasOwnProperty(styleName)) {
                            if (!styleUpdates) {
                                styleUpdates = {};
                            }
                            styleUpdates[styleName] = '';
                        }
                    }
                }
                else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                    ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                    ;
                else if (propKey === AUTOFOCUS)
                    ;
                else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                    if (!updatePayload) {
                        updatePayload = [];
                    }
                }
                else {
                    (updatePayload = updatePayload || []).push(propKey, null);
                }
            }
            for (propKey in nextProps) {
                var nextProp = nextProps[propKey];
                var lastProp = lastProps != null ? lastProps[propKey] : undefined;
                if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                    continue;
                }
                if (propKey === STYLE) {
                    {
                        if (nextProp) {
                            Object.freeze(nextProp);
                        }
                    }
                    if (lastProp) {
                        for (styleName in lastProp) {
                            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                                if (!styleUpdates) {
                                    styleUpdates = {};
                                }
                                styleUpdates[styleName] = '';
                            }
                        }
                        for (styleName in nextProp) {
                            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                                if (!styleUpdates) {
                                    styleUpdates = {};
                                }
                                styleUpdates[styleName] = nextProp[styleName];
                            }
                        }
                    }
                    else {
                        if (!styleUpdates) {
                            if (!updatePayload) {
                                updatePayload = [];
                            }
                            updatePayload.push(propKey, styleUpdates);
                        }
                        styleUpdates = nextProp;
                    }
                }
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                    var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                    var lastHtml = lastProp ? lastProp[HTML$1] : undefined;
                    if (nextHtml != null) {
                        if (lastHtml !== nextHtml) {
                            (updatePayload = updatePayload || []).push(propKey, nextHtml);
                        }
                    }
                }
                else if (propKey === CHILDREN) {
                    if (typeof nextProp === 'string' || typeof nextProp === 'number') {
                        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
                    }
                }
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                    ;
                else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                    if (nextProp != null) {
                        if (typeof nextProp !== 'function') {
                            warnForInvalidEventListener(propKey, nextProp);
                        }
                        if (propKey === 'onScroll') {
                            listenToNonDelegatedEvent('scroll', domElement);
                        }
                    }
                    if (!updatePayload && lastProp !== nextProp) {
                        updatePayload = [];
                    }
                }
                else {
                    (updatePayload = updatePayload || []).push(propKey, nextProp);
                }
            }
            if (styleUpdates) {
                {
                    validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
                }
                (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
                updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
                case 'input':
                    updateWrapper(domElement, nextRawProps);
                    break;
                case 'textarea':
                    updateWrapper$1(domElement, nextRawProps);
                    break;
                case 'select':
                    postUpdateWrapper(domElement, nextRawProps);
                    break;
            }
        }
        function getPossibleStandardName(propName) {
            {
                var lowerCasedName = propName.toLowerCase();
                if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                    return null;
                }
                return possibleStandardNames[lowerCasedName] || null;
            }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
                isCustomComponentTag = isCustomComponent(tag, rawProps);
                validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
                case 'dialog':
                    listenToNonDelegatedEvent('cancel', domElement);
                    listenToNonDelegatedEvent('close', domElement);
                    break;
                case 'iframe':
                case 'object':
                case 'embed':
                    listenToNonDelegatedEvent('load', domElement);
                    break;
                case 'video':
                case 'audio':
                    for (var i = 0; i < mediaEventTypes.length; i++) {
                        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                    }
                    break;
                case 'source':
                    listenToNonDelegatedEvent('error', domElement);
                    break;
                case 'img':
                case 'image':
                case 'link':
                    listenToNonDelegatedEvent('error', domElement);
                    listenToNonDelegatedEvent('load', domElement);
                    break;
                case 'details':
                    listenToNonDelegatedEvent('toggle', domElement);
                    break;
                case 'input':
                    initWrapperState(domElement, rawProps);
                    listenToNonDelegatedEvent('invalid', domElement);
                    break;
                case 'option':
                    validateProps(domElement, rawProps);
                    break;
                case 'select':
                    initWrapperState$1(domElement, rawProps);
                    listenToNonDelegatedEvent('invalid', domElement);
                    break;
                case 'textarea':
                    initWrapperState$2(domElement, rawProps);
                    listenToNonDelegatedEvent('invalid', domElement);
                    break;
            }
            assertValidProps(tag, rawProps);
            {
                extraAttributeNames = new Set();
                var attributes = domElement.attributes;
                for (var _i = 0; _i < attributes.length; _i++) {
                    var name = attributes[_i].name.toLowerCase();
                    switch (name) {
                        case 'value':
                            break;
                        case 'checked':
                            break;
                        case 'selected':
                            break;
                        default:
                            extraAttributeNames.add(attributes[_i].name);
                    }
                }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
                if (!rawProps.hasOwnProperty(propKey)) {
                    continue;
                }
                var nextProp = rawProps[propKey];
                if (propKey === CHILDREN) {
                    if (typeof nextProp === 'string') {
                        if (domElement.textContent !== nextProp) {
                            if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                                checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                            }
                            updatePayload = [CHILDREN, nextProp];
                        }
                    }
                    else if (typeof nextProp === 'number') {
                        if (domElement.textContent !== '' + nextProp) {
                            if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                                checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                            }
                            updatePayload = [CHILDREN, '' + nextProp];
                        }
                    }
                }
                else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                    if (nextProp != null) {
                        if (typeof nextProp !== 'function') {
                            warnForInvalidEventListener(propKey, nextProp);
                        }
                        if (propKey === 'onScroll') {
                            listenToNonDelegatedEvent('scroll', domElement);
                        }
                    }
                }
                else if (shouldWarnDev && true &&
                    typeof isCustomComponentTag === 'boolean') {
                    var serverValue = void 0;
                    var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                        ;
                    else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING ||
                        propKey === 'value' || propKey === 'checked' || propKey === 'selected')
                        ;
                    else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                        var serverHTML = domElement.innerHTML;
                        var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                        if (nextHtml != null) {
                            var expectedHTML = normalizeHTML(domElement, nextHtml);
                            if (expectedHTML !== serverHTML) {
                                warnForPropDifference(propKey, serverHTML, expectedHTML);
                            }
                        }
                    }
                    else if (propKey === STYLE) {
                        extraAttributeNames.delete(propKey);
                        if (canDiffStyleForHydrationWarning) {
                            var expectedStyle = createDangerousStringForStyles(nextProp);
                            serverValue = domElement.getAttribute('style');
                            if (expectedStyle !== serverValue) {
                                warnForPropDifference(propKey, serverValue, expectedStyle);
                            }
                        }
                    }
                    else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                        extraAttributeNames.delete(propKey.toLowerCase());
                        serverValue = getValueForAttribute(domElement, propKey, nextProp);
                        if (nextProp !== serverValue) {
                            warnForPropDifference(propKey, serverValue, nextProp);
                        }
                    }
                    else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                        var isMismatchDueToBadCasing = false;
                        if (propertyInfo !== null) {
                            extraAttributeNames.delete(propertyInfo.attributeName);
                            serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                        }
                        else {
                            var ownNamespace = parentNamespace;
                            if (ownNamespace === HTML_NAMESPACE) {
                                ownNamespace = getIntrinsicNamespace(tag);
                            }
                            if (ownNamespace === HTML_NAMESPACE) {
                                extraAttributeNames.delete(propKey.toLowerCase());
                            }
                            else {
                                var standardName = getPossibleStandardName(propKey);
                                if (standardName !== null && standardName !== propKey) {
                                    isMismatchDueToBadCasing = true;
                                    extraAttributeNames.delete(standardName);
                                }
                                extraAttributeNames.delete(propKey);
                            }
                            serverValue = getValueForAttribute(domElement, propKey, nextProp);
                        }
                        var dontWarnCustomElement = enableCustomElementPropertySupport;
                        if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                            warnForPropDifference(propKey, serverValue, nextProp);
                        }
                    }
                }
            }
            {
                if (shouldWarnDev) {
                    if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                        warnForExtraAttributes(extraAttributeNames);
                    }
                }
            }
            switch (tag) {
                case 'input':
                    track(domElement);
                    postMountWrapper(domElement, rawProps, true);
                    break;
                case 'textarea':
                    track(domElement);
                    postMountWrapper$3(domElement);
                    break;
                case 'select':
                case 'option':
                    break;
                default:
                    if (typeof rawProps.onClick === 'function') {
                        trapClickOnNonInteractiveElement(domElement);
                    }
                    break;
            }
            return updatePayload;
        }
        function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
            {
                if (didWarnInvalidHydration) {
                    return;
                }
                didWarnInvalidHydration = true;
                error('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
        }
        function warnForDeletedHydratableText(parentNode, child) {
            {
                if (didWarnInvalidHydration) {
                    return;
                }
                didWarnInvalidHydration = true;
                error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
                if (didWarnInvalidHydration) {
                    return;
                }
                didWarnInvalidHydration = true;
                error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
            }
        }
        function warnForInsertedHydratedText(parentNode, text) {
            {
                if (text === '') {
                    return;
                }
                if (didWarnInvalidHydration) {
                    return;
                }
                didWarnInvalidHydration = true;
                error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
        }
        function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
                case 'input':
                    restoreControlledState(domElement, props);
                    return;
                case 'textarea':
                    restoreControlledState$2(domElement, props);
                    return;
                case 'select':
                    restoreControlledState$1(domElement, props);
                    return;
            }
        }
        var validateDOMNesting = function () { };
        var updatedAncestorInfo = function () { };
        {
            var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
            var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
                'foreignObject', 'desc', 'title'];
            var buttonScopeTags = inScopeTags.concat(['button']);
            var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
            var emptyAncestorInfo = {
                current: null,
                formTag: null,
                aTagInScope: null,
                buttonTagInScope: null,
                nobrTagInScope: null,
                pTagInButtonScope: null,
                listItemTagAutoclosing: null,
                dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function (oldInfo, tag) {
                var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
                var info = {
                    tag: tag
                };
                if (inScopeTags.indexOf(tag) !== -1) {
                    ancestorInfo.aTagInScope = null;
                    ancestorInfo.buttonTagInScope = null;
                    ancestorInfo.nobrTagInScope = null;
                }
                if (buttonScopeTags.indexOf(tag) !== -1) {
                    ancestorInfo.pTagInButtonScope = null;
                }
                if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
                    ancestorInfo.listItemTagAutoclosing = null;
                    ancestorInfo.dlItemTagAutoclosing = null;
                }
                ancestorInfo.current = info;
                if (tag === 'form') {
                    ancestorInfo.formTag = info;
                }
                if (tag === 'a') {
                    ancestorInfo.aTagInScope = info;
                }
                if (tag === 'button') {
                    ancestorInfo.buttonTagInScope = info;
                }
                if (tag === 'nobr') {
                    ancestorInfo.nobrTagInScope = info;
                }
                if (tag === 'p') {
                    ancestorInfo.pTagInButtonScope = info;
                }
                if (tag === 'li') {
                    ancestorInfo.listItemTagAutoclosing = info;
                }
                if (tag === 'dd' || tag === 'dt') {
                    ancestorInfo.dlItemTagAutoclosing = info;
                }
                return ancestorInfo;
            };
            var isTagValidWithParent = function (tag, parentTag) {
                switch (parentTag) {
                    case 'select':
                        return tag === 'option' || tag === 'optgroup' || tag === '#text';
                    case 'optgroup':
                        return tag === 'option' || tag === '#text';
                    case 'option':
                        return tag === '#text';
                    case 'tr':
                        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
                    case 'tbody':
                    case 'thead':
                    case 'tfoot':
                        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
                    case 'colgroup':
                        return tag === 'col' || tag === 'template';
                    case 'table':
                        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
                    case 'head':
                        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
                    case 'html':
                        return tag === 'head' || tag === 'body' || tag === 'frameset';
                    case 'frameset':
                        return tag === 'frame';
                    case '#document':
                        return tag === 'html';
                }
                switch (tag) {
                    case 'h1':
                    case 'h2':
                    case 'h3':
                    case 'h4':
                    case 'h5':
                    case 'h6':
                        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
                    case 'rp':
                    case 'rt':
                        return impliedEndTags.indexOf(parentTag) === -1;
                    case 'body':
                    case 'caption':
                    case 'col':
                    case 'colgroup':
                    case 'frameset':
                    case 'frame':
                    case 'head':
                    case 'html':
                    case 'tbody':
                    case 'td':
                    case 'tfoot':
                    case 'th':
                    case 'thead':
                    case 'tr':
                        return parentTag == null;
                }
                return true;
            };
            var findInvalidAncestorForTag = function (tag, ancestorInfo) {
                switch (tag) {
                    case 'address':
                    case 'article':
                    case 'aside':
                    case 'blockquote':
                    case 'center':
                    case 'details':
                    case 'dialog':
                    case 'dir':
                    case 'div':
                    case 'dl':
                    case 'fieldset':
                    case 'figcaption':
                    case 'figure':
                    case 'footer':
                    case 'header':
                    case 'hgroup':
                    case 'main':
                    case 'menu':
                    case 'nav':
                    case 'ol':
                    case 'p':
                    case 'section':
                    case 'summary':
                    case 'ul':
                    case 'pre':
                    case 'listing':
                    case 'table':
                    case 'hr':
                    case 'xmp':
                    case 'h1':
                    case 'h2':
                    case 'h3':
                    case 'h4':
                    case 'h5':
                    case 'h6':
                        return ancestorInfo.pTagInButtonScope;
                    case 'form':
                        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                    case 'li':
                        return ancestorInfo.listItemTagAutoclosing;
                    case 'dd':
                    case 'dt':
                        return ancestorInfo.dlItemTagAutoclosing;
                    case 'button':
                        return ancestorInfo.buttonTagInScope;
                    case 'a':
                        return ancestorInfo.aTagInScope;
                    case 'nobr':
                        return ancestorInfo.nobrTagInScope;
                }
                return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function (childTag, childText, ancestorInfo) {
                ancestorInfo = ancestorInfo || emptyAncestorInfo;
                var parentInfo = ancestorInfo.current;
                var parentTag = parentInfo && parentInfo.tag;
                if (childText != null) {
                    if (childTag != null) {
                        error('validateDOMNesting: when childText is passed, childTag should be null');
                    }
                    childTag = '#text';
                }
                var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
                var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
                var invalidParentOrAncestor = invalidParent || invalidAncestor;
                if (!invalidParentOrAncestor) {
                    return;
                }
                var ancestorTag = invalidParentOrAncestor.tag;
                var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;
                if (didWarn$1[warnKey]) {
                    return;
                }
                didWarn$1[warnKey] = true;
                var tagDisplayName = childTag;
                var whitespaceInfo = '';
                if (childTag === '#text') {
                    if (/\S/.test(childText)) {
                        tagDisplayName = 'Text nodes';
                    }
                    else {
                        tagDisplayName = 'Whitespace text nodes';
                        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
                    }
                }
                else {
                    tagDisplayName = '<' + childTag + '>';
                }
                if (invalidParent) {
                    var info = '';
                    if (ancestorTag === 'table' && childTag === 'tr') {
                        info += ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by ' + 'the browser.';
                    }
                    error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);
                }
                else {
                    error('validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.', tagDisplayName, ancestorTag);
                }
            };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
        var SUSPENSE_START_DATA = '$';
        var SUSPENSE_END_DATA = '/$';
        var SUSPENSE_PENDING_START_DATA = '$?';
        var SUSPENSE_FALLBACK_START_DATA = '$!';
        var STYLE$1 = 'style';
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
                case DOCUMENT_NODE:
                case DOCUMENT_FRAGMENT_NODE:
                    {
                        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
                        var root = rootContainerInstance.documentElement;
                        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
                        break;
                    }
                default:
                    {
                        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                        var ownNamespace = container.namespaceURI || null;
                        type = container.tagName;
                        namespace = getChildNamespace(ownNamespace, type);
                        break;
                    }
            }
            {
                var validatedTag = type.toLowerCase();
                var ancestorInfo = updatedAncestorInfo(null, validatedTag);
                return {
                    namespace: namespace,
                    ancestorInfo: ancestorInfo
                };
            }
        }
        function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
                var parentHostContextDev = parentHostContext;
                var namespace = getChildNamespace(parentHostContextDev.namespace, type);
                var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
                return {
                    namespace: namespace,
                    ancestorInfo: ancestorInfo
                };
            }
        }
        function getPublicInstance(instance) {
            return instance;
        }
        function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
        }
        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
                var hostContextDev = hostContext;
                validateDOMNesting(type, null, hostContextDev.ancestorInfo);
                if (typeof props.children === 'string' || typeof props.children === 'number') {
                    var string = '' + props.children;
                    var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                    validateDOMNesting(null, string, ownAncestorInfo);
                }
                parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
        }
        function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
                case 'button':
                case 'input':
                case 'select':
                case 'textarea':
                    return !!props.autoFocus;
                case 'img':
                    return true;
                default:
                    return false;
            }
        }
        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
                var hostContextDev = hostContext;
                if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
                    var string = '' + newProps.children;
                    var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                    validateDOMNesting(null, string, ownAncestorInfo);
                }
            }
            return diffProperties(domElement, type, oldProps, newProps);
        }
        function shouldSetTextContent(type, props) {
            return type === 'textarea' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
                var hostContextDev = hostContext;
                validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
        }
        function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === undefined) {
                return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
        var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
        var noTimeout = -1;
        var localPromise = typeof Promise === 'function' ? Promise : undefined;
        var scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : typeof localPromise !== 'undefined' ? function (callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error) {
            setTimeout(function () {
                throw error;
            });
        }
        function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
                case 'button':
                case 'input':
                case 'select':
                case 'textarea':
                    if (newProps.autoFocus) {
                        domElement.focus();
                    }
                    return;
                case 'img':
                    {
                        if (newProps.src) {
                            domElement.src = newProps.src;
                        }
                        return;
                    }
            }
        }
        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
            setTextContent(domElement, '');
        }
        function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
        }
        function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
                parentNode = container.parentNode;
                parentNode.insertBefore(child, container);
            }
            else {
                parentNode = container;
                parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
                trapClickOnNonInteractiveElement(parentNode);
            }
        }
        function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
                container.parentNode.insertBefore(child, beforeChild);
            }
            else {
                container.insertBefore(child, beforeChild);
            }
        }
        function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
                container.parentNode.removeChild(child);
            }
            else {
                container.removeChild(child);
            }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
                var nextNode = node.nextSibling;
                parentInstance.removeChild(node);
                if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                    var data = nextNode.data;
                    if (data === SUSPENSE_END_DATA) {
                        if (depth === 0) {
                            parentInstance.removeChild(nextNode);
                            retryIfBlockedOn(suspenseInstance);
                            return;
                        }
                        else {
                            depth--;
                        }
                    }
                    else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                        depth++;
                    }
                }
                node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
            if (container.nodeType === COMMENT_NODE) {
                clearSuspenseBoundary(container.parentNode, suspenseInstance);
            }
            else if (container.nodeType === ELEMENT_NODE) {
                clearSuspenseBoundary(container, suspenseInstance);
            }
            retryIfBlockedOn(container);
        }
        function hideInstance(instance) {
            instance = instance;
            var style = instance.style;
            if (typeof style.setProperty === 'function') {
                style.setProperty('display', 'none', 'important');
            }
            else {
                style.display = 'none';
            }
        }
        function hideTextInstance(textInstance) {
            textInstance.nodeValue = '';
        }
        function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
            instance.style.display = dangerousStyleValue('display', display);
        }
        function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
        }
        function clearContainer(container) {
            if (container.nodeType === ELEMENT_NODE) {
                container.textContent = '';
            }
            else if (container.nodeType === DOCUMENT_NODE) {
                if (container.documentElement) {
                    container.removeChild(container.documentElement);
                }
            }
        }
        function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
                return null;
            }
            return instance;
        }
        function canHydrateTextInstance(instance, text) {
            if (text === '' || instance.nodeType !== TEXT_NODE) {
                return null;
            }
            return instance;
        }
        function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
                return null;
            }
            return instance;
        }
        function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message, stack;
            if (dataset) {
                digest = dataset.dgst;
                {
                    message = dataset.msg;
                    stack = dataset.stck;
                }
            }
            {
                return {
                    message: message,
                    digest: digest,
                    stack: stack
                };
            }
        }
        function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
        }
        function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
                var nodeType = node.nodeType;
                if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                    break;
                }
                if (nodeType === COMMENT_NODE) {
                    var nodeData = node.data;
                    if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                        break;
                    }
                    if (nodeData === SUSPENSE_END_DATA) {
                        return null;
                    }
                }
            }
            return node;
        }
        function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
                var hostContextDev = hostContext;
                parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
                if (node.nodeType === COMMENT_NODE) {
                    var data = node.data;
                    if (data === SUSPENSE_END_DATA) {
                        if (depth === 0) {
                            return getNextHydratableSibling(node);
                        }
                        else {
                            depth--;
                        }
                    }
                    else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                        depth++;
                    }
                }
                node = node.nextSibling;
            }
            return null;
        }
        function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
                if (node.nodeType === COMMENT_NODE) {
                    var data = node.data;
                    if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                        if (depth === 0) {
                            return node;
                        }
                        else {
                            depth--;
                        }
                    }
                    else if (data === SUSPENSE_END_DATA) {
                        depth++;
                    }
                }
                node = node.previousSibling;
            }
            return null;
        }
        function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== 'head' && parentType !== 'body';
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                var shouldWarnDev = true;
                checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
                if (instance.nodeType === ELEMENT_NODE) {
                    warnForDeletedHydratableElement(parentContainer, instance);
                }
                else if (instance.nodeType === COMMENT_NODE)
                    ;
                else {
                    warnForDeletedHydratableText(parentContainer, instance);
                }
            }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
                var parentNode = parentInstance.parentNode;
                if (parentNode !== null) {
                    if (instance.nodeType === ELEMENT_NODE) {
                        warnForDeletedHydratableElement(parentNode, instance);
                    }
                    else if (instance.nodeType === COMMENT_NODE)
                        ;
                    else {
                        warnForDeletedHydratableText(parentNode, instance);
                    }
                }
            }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
                if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                    if (instance.nodeType === ELEMENT_NODE) {
                        warnForDeletedHydratableElement(parentInstance, instance);
                    }
                    else if (instance.nodeType === COMMENT_NODE)
                        ;
                    else {
                        warnForDeletedHydratableText(parentInstance, instance);
                    }
                }
            }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
                warnForInsertedHydratedElement(parentContainer, type);
            }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
                warnForInsertedHydratedText(parentContainer, text);
            }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
                var parentNode = parentInstance.parentNode;
                if (parentNode !== null)
                    warnForInsertedHydratedElement(parentNode, type);
            }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
                var parentNode = parentInstance.parentNode;
                if (parentNode !== null)
                    warnForInsertedHydratedText(parentNode, text);
            }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
                if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                    warnForInsertedHydratedElement(parentInstance, type);
                }
            }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
                if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                    warnForInsertedHydratedText(parentInstance, text);
                }
            }
        }
        function errorHydratingContainer(parentContainer) {
            {
                error('An error occurred during hydration. The server HTML was replaced with client content in <%s>.', parentContainer.nodeName.toLowerCase());
            }
        }
        function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = '__reactFiber$' + randomKey;
        var internalPropsKey = '__reactProps$' + randomKey;
        var internalContainerInstanceKey = '__reactContainer$' + randomKey;
        var internalEventHandlersKey = '__reactEvents$' + randomKey;
        var internalEventHandlerListenersKey = '__reactListeners$' + randomKey;
        var internalEventHandlesSetKey = '__reactHandles$' + randomKey;
        function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
                return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
                targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
                if (targetInst) {
                    var alternate = targetInst.alternate;
                    if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                        var suspenseInstance = getParentSuspenseInstance(targetNode);
                        while (suspenseInstance !== null) {
                            var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                            if (targetSuspenseInst) {
                                return targetSuspenseInst;
                            }
                            suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                        }
                    }
                    return targetInst;
                }
                targetNode = parentNode;
                parentNode = targetNode.parentNode;
            }
            return null;
        }
        function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
                if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                    return inst;
                }
                else {
                    return null;
                }
            }
            return null;
        }
        function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
                return inst.stateNode;
            }
            throw new Error('getNodeFromInstance: Invalid argument.');
        }
        function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
        }
        function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === undefined) {
                elementListenerSet = node[internalEventHandlersKey] = new Set();
            }
            return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                }
                else {
                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for (var typeSpecName in typeSpecs) {
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        }
                        catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement(null);
                        }
                    }
                }
            }
        }
        var valueStack = [];
        var fiberStack;
        {
            fiberStack = [];
        }
        var index = -1;
        function createCursor(defaultValue) {
            return {
                current: defaultValue
            };
        }
        function pop(cursor, fiber) {
            if (index < 0) {
                {
                    error('Unexpected pop.');
                }
                return;
            }
            {
                if (fiber !== fiberStack[index]) {
                    error('Unexpected Fiber popped.');
                }
            }
            cursor.current = valueStack[index];
            valueStack[index] = null;
            {
                fiberStack[index] = null;
            }
            index--;
        }
        function push(cursor, value, fiber) {
            index++;
            valueStack[index] = cursor.current;
            {
                fiberStack[index] = fiber;
            }
            cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
            warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
            Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
            {
                if (didPushOwnContextIfProvider && isContextProvider(Component)) {
                    return previousContext;
                }
                return contextStackCursor.current;
            }
        }
        function cacheContext(workInProgress, unmaskedContext, maskedContext) {
            {
                var instance = workInProgress.stateNode;
                instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
                instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
        }
        function getMaskedContext(workInProgress, unmaskedContext) {
            {
                var type = workInProgress.type;
                var contextTypes = type.contextTypes;
                if (!contextTypes) {
                    return emptyContextObject;
                }
                var instance = workInProgress.stateNode;
                if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                    return instance.__reactInternalMemoizedMaskedChildContext;
                }
                var context = {};
                for (var key in contextTypes) {
                    context[key] = unmaskedContext[key];
                }
                {
                    var name = getComponentNameFromFiber(workInProgress) || 'Unknown';
                    checkPropTypes(contextTypes, context, 'context', name);
                }
                if (instance) {
                    cacheContext(workInProgress, unmaskedContext, context);
                }
                return context;
            }
        }
        function hasContextChanged() {
            {
                return didPerformWorkStackCursor.current;
            }
        }
        function isContextProvider(type) {
            {
                var childContextTypes = type.childContextTypes;
                return childContextTypes !== null && childContextTypes !== undefined;
            }
        }
        function popContext(fiber) {
            {
                pop(didPerformWorkStackCursor, fiber);
                pop(contextStackCursor, fiber);
            }
        }
        function popTopLevelContextObject(fiber) {
            {
                pop(didPerformWorkStackCursor, fiber);
                pop(contextStackCursor, fiber);
            }
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
            {
                if (contextStackCursor.current !== emptyContextObject) {
                    throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                push(contextStackCursor, context, fiber);
                push(didPerformWorkStackCursor, didChange, fiber);
            }
        }
        function processChildContext(fiber, type, parentContext) {
            {
                var instance = fiber.stateNode;
                var childContextTypes = type.childContextTypes;
                if (typeof instance.getChildContext !== 'function') {
                    {
                        var componentName = getComponentNameFromFiber(fiber) || 'Unknown';
                        if (!warnedAboutMissingGetChildContext[componentName]) {
                            warnedAboutMissingGetChildContext[componentName] = true;
                            error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
                        }
                    }
                    return parentContext;
                }
                var childContext = instance.getChildContext();
                for (var contextKey in childContext) {
                    if (!(contextKey in childContextTypes)) {
                        throw new Error((getComponentNameFromFiber(fiber) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
                    }
                }
                {
                    var name = getComponentNameFromFiber(fiber) || 'Unknown';
                    checkPropTypes(childContextTypes, childContext, 'child context', name);
                }
                return assign({}, parentContext, childContext);
            }
        }
        function pushContextProvider(workInProgress) {
            {
                var instance = workInProgress.stateNode;
                var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
                previousContext = contextStackCursor.current;
                push(contextStackCursor, memoizedMergedChildContext, workInProgress);
                push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
                return true;
            }
        }
        function invalidateContextProvider(workInProgress, type, didChange) {
            {
                var instance = workInProgress.stateNode;
                if (!instance) {
                    throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                if (didChange) {
                    var mergedContext = processChildContext(workInProgress, type, previousContext);
                    instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                    pop(didPerformWorkStackCursor, workInProgress);
                    pop(contextStackCursor, workInProgress);
                    push(contextStackCursor, mergedContext, workInProgress);
                    push(didPerformWorkStackCursor, didChange, workInProgress);
                }
                else {
                    pop(didPerformWorkStackCursor, workInProgress);
                    push(didPerformWorkStackCursor, didChange, workInProgress);
                }
            }
        }
        function findCurrentUnmaskedContext(fiber) {
            {
                if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                    throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                var node = fiber;
                do {
                    switch (node.tag) {
                        case HostRoot:
                            return node.stateNode.context;
                        case ClassComponent:
                            {
                                var Component = node.type;
                                if (isContextProvider(Component)) {
                                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                                }
                                break;
                            }
                    }
                    node = node.return;
                } while (node !== null);
                throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');
            }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
                syncQueue = [callback];
            }
            else {
                syncQueue.push(callback);
            }
        }
        function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
                flushSyncCallbacks();
            }
        }
        function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
                isFlushingSyncQueue = true;
                var i = 0;
                var previousUpdatePriority = getCurrentUpdatePriority();
                try {
                    var isSync = true;
                    var queue = syncQueue;
                    setCurrentUpdatePriority(DiscreteEventPriority);
                    for (; i < queue.length; i++) {
                        var callback = queue[i];
                        do {
                            callback = callback(isSync);
                        } while (callback !== null);
                    }
                    syncQueue = null;
                    includesLegacySyncCallbacks = false;
                }
                catch (error) {
                    if (syncQueue !== null) {
                        syncQueue = syncQueue.slice(i + 1);
                    }
                    scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                    throw error;
                }
                finally {
                    setCurrentUpdatePriority(previousUpdatePriority);
                    isFlushingSyncQueue = false;
                }
            }
            return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = '';
        function isForkedChild(workInProgress) {
            warnIfNotHydrating();
            return (workInProgress.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress) {
            warnIfNotHydrating();
            return treeForkCount;
        }
        function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress;
            treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress, totalChildren, index) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
                var numberOfOverflowBits = baseLength - baseLength % 5;
                var newOverflowBits = (1 << numberOfOverflowBits) - 1;
                var newOverflow = (baseId & newOverflowBits).toString(32);
                var restOfBaseId = baseId >> numberOfOverflowBits;
                var restOfBaseLength = baseLength - numberOfOverflowBits;
                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
                var restOfNewBits = slot << restOfBaseLength;
                var id = restOfNewBits | restOfBaseId;
                var overflow = newOverflow + baseOverflow;
                treeContextId = 1 << restOfLength | id;
                treeContextOverflow = overflow;
            }
            else {
                var newBits = slot << baseLength;
                var _id = newBits | baseId;
                var _overflow = baseOverflow;
                treeContextId = 1 << length | _id;
                treeContextOverflow = _overflow;
            }
        }
        function pushMaterializedTreeId(workInProgress) {
            warnIfNotHydrating();
            var returnFiber = workInProgress.return;
            if (returnFiber !== null) {
                var numberOfForks = 1;
                var slotIndex = 0;
                pushTreeFork(workInProgress, numberOfForks);
                pushTreeId(workInProgress, numberOfForks, slotIndex);
            }
        }
        function getBitLength(number) {
            return 32 - clz32(number);
        }
        function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
        }
        function popTreeContext(workInProgress) {
            while (workInProgress === treeForkProvider) {
                treeForkProvider = forkStack[--forkStackIndex];
                forkStack[forkStackIndex] = null;
                treeForkCount = forkStack[--forkStackIndex];
                forkStack[forkStackIndex] = null;
            }
            while (workInProgress === treeContextProvider) {
                treeContextProvider = idStack[--idStackIndex];
                idStack[idStackIndex] = null;
                treeContextOverflow = idStack[--idStackIndex];
                idStack[idStackIndex] = null;
                treeContextId = idStack[--idStackIndex];
                idStack[idStackIndex] = null;
            }
        }
        function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
                return {
                    id: treeContextId,
                    overflow: treeContextOverflow
                };
            }
            else {
                return null;
            }
        }
        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress;
        }
        function warnIfNotHydrating() {
            {
                if (!getIsHydrating()) {
                    error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');
                }
            }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
            {
                if (isHydrating) {
                    error('We should not be hydrating here. This is a bug in React. Please file a bug.');
                }
            }
        }
        function markDidThrowWhileHydratingDEV() {
            {
                didSuspendOrErrorDEV = true;
            }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
            {
                return didSuspendOrErrorDEV;
            }
        }
        function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
                restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
        }
        function warnUnhydratedInstance(returnFiber, instance) {
            {
                switch (returnFiber.tag) {
                    case HostRoot:
                        {
                            didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                            break;
                        }
                    case HostComponent:
                        {
                            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                            didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, isConcurrentMode);
                            break;
                        }
                    case SuspenseComponent:
                        {
                            var suspenseState = returnFiber.memoizedState;
                            if (suspenseState.dehydrated !== null)
                                didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                            break;
                        }
                }
            }
        }
        function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
            }
            else {
                deletions.push(childToDelete);
            }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
            {
                if (didSuspendOrErrorDEV) {
                    return;
                }
                switch (returnFiber.tag) {
                    case HostRoot:
                        {
                            var parentContainer = returnFiber.stateNode.containerInfo;
                            switch (fiber.tag) {
                                case HostComponent:
                                    var type = fiber.type;
                                    var props = fiber.pendingProps;
                                    didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                                    break;
                                case HostText:
                                    var text = fiber.pendingProps;
                                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                                    break;
                            }
                            break;
                        }
                    case HostComponent:
                        {
                            var parentType = returnFiber.type;
                            var parentProps = returnFiber.memoizedProps;
                            var parentInstance = returnFiber.stateNode;
                            switch (fiber.tag) {
                                case HostComponent:
                                    {
                                        var _type = fiber.type;
                                        var _props = fiber.pendingProps;
                                        var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                        didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, isConcurrentMode);
                                        break;
                                    }
                                case HostText:
                                    {
                                        var _text = fiber.pendingProps;
                                        var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                        didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, _isConcurrentMode);
                                        break;
                                    }
                            }
                            break;
                        }
                    case SuspenseComponent:
                        {
                            var suspenseState = returnFiber.memoizedState;
                            var _parentInstance = suspenseState.dehydrated;
                            if (_parentInstance !== null)
                                switch (fiber.tag) {
                                    case HostComponent:
                                        var _type2 = fiber.type;
                                        var _props2 = fiber.pendingProps;
                                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                                        break;
                                    case HostText:
                                        var _text2 = fiber.pendingProps;
                                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                                        break;
                                }
                            break;
                        }
                    default:
                        return;
                }
            }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
                case HostComponent:
                    {
                        var type = fiber.type;
                        var props = fiber.pendingProps;
                        var instance = canHydrateInstance(nextInstance, type);
                        if (instance !== null) {
                            fiber.stateNode = instance;
                            hydrationParentFiber = fiber;
                            nextHydratableInstance = getFirstHydratableChild(instance);
                            return true;
                        }
                        return false;
                    }
                case HostText:
                    {
                        var text = fiber.pendingProps;
                        var textInstance = canHydrateTextInstance(nextInstance, text);
                        if (textInstance !== null) {
                            fiber.stateNode = textInstance;
                            hydrationParentFiber = fiber;
                            nextHydratableInstance = null;
                            return true;
                        }
                        return false;
                    }
                case SuspenseComponent:
                    {
                        var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                        if (suspenseInstance !== null) {
                            var suspenseState = {
                                dehydrated: suspenseInstance,
                                treeContext: getSuspendedTreeContext(),
                                retryLane: OffscreenLane
                            };
                            fiber.memoizedState = suspenseState;
                            var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                            dehydratedFragment.return = fiber;
                            fiber.child = dehydratedFragment;
                            hydrationParentFiber = fiber;
                            nextHydratableInstance = null;
                            return true;
                        }
                        return false;
                    }
                default:
                    return false;
            }
        }
        function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
            throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');
        }
        function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
                return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                    warnNonhydratedInstance(hydrationParentFiber, fiber);
                    throwOnHydrationMismatch();
                }
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
                if (shouldClientRenderOnMismatch(fiber)) {
                    warnNonhydratedInstance(hydrationParentFiber, fiber);
                    throwOnHydrationMismatch();
                }
                nextInstance = getNextHydratableSibling(firstAttemptedInstance);
                var prevHydrationParentFiber = hydrationParentFiber;
                if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                    insertNonHydratedInstance(hydrationParentFiber, fiber);
                    isHydrating = false;
                    hydrationParentFiber = fiber;
                    return;
                }
                deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
                return true;
            }
            return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
                var returnFiber = hydrationParentFiber;
                if (returnFiber !== null) {
                    switch (returnFiber.tag) {
                        case HostRoot:
                            {
                                var parentContainer = returnFiber.stateNode.containerInfo;
                                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);
                                break;
                            }
                        case HostComponent:
                            {
                                var parentType = returnFiber.type;
                                var parentProps = returnFiber.memoizedProps;
                                var parentInstance = returnFiber.stateNode;
                                var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, _isConcurrentMode2);
                                break;
                            }
                    }
                }
            }
            return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
                parent = parent.return;
            }
            hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
                return false;
            }
            if (!isHydrating) {
                popToNextHostParent(fiber);
                isHydrating = true;
                return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
                var nextInstance = nextHydratableInstance;
                if (nextInstance) {
                    if (shouldClientRenderOnMismatch(fiber)) {
                        warnIfUnhydratedTailNodes(fiber);
                        throwOnHydrationMismatch();
                    }
                    else {
                        while (nextInstance) {
                            deleteHydratableInstance(fiber, nextInstance);
                            nextInstance = getNextHydratableSibling(nextInstance);
                        }
                    }
                }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            }
            else {
                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
        }
        function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
                warnUnhydratedInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
            }
        }
        function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
                queueRecoverableErrors(hydrationErrors);
                hydrationErrors = null;
            }
        }
        function getIsHydrating() {
            return isHydrating;
        }
        function queueHydrationError(error) {
            if (hydrationErrors === null) {
                hydrationErrors = [error];
            }
            else {
                hydrationErrors.push(error);
            }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function (fiber, instance) { },
            flushPendingUnsafeLifecycleWarnings: function () { },
            recordLegacyContextWarning: function (fiber, instance) { },
            flushLegacyContextWarning: function () { },
            discardPendingWarnings: function () { }
        };
        {
            var findStrictRoot = function (fiber) {
                var maybeStrictRoot = null;
                var node = fiber;
                while (node !== null) {
                    if (node.mode & StrictLegacyMode) {
                        maybeStrictRoot = node;
                    }
                    node = node.return;
                }
                return maybeStrictRoot;
            };
            var setToSortedString = function (set) {
                var array = [];
                set.forEach(function (value) {
                    array.push(value);
                });
                return array.sort().join(', ');
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                    return;
                }
                if (typeof instance.componentWillMount === 'function' &&
                    instance.componentWillMount.__suppressDeprecationWarning !== true) {
                    pendingComponentWillMountWarnings.push(fiber);
                }
                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {
                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
                }
                if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                    pendingComponentWillReceivePropsWarnings.push(fiber);
                }
                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
                }
                if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                    pendingComponentWillUpdateWarnings.push(fiber);
                }
                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {
                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
                }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
                var componentWillMountUniqueNames = new Set();
                if (pendingComponentWillMountWarnings.length > 0) {
                    pendingComponentWillMountWarnings.forEach(function (fiber) {
                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingComponentWillMountWarnings = [];
                }
                var UNSAFE_componentWillMountUniqueNames = new Set();
                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingUNSAFE_ComponentWillMountWarnings = [];
                }
                var componentWillReceivePropsUniqueNames = new Set();
                if (pendingComponentWillReceivePropsWarnings.length > 0) {
                    pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingComponentWillReceivePropsWarnings = [];
                }
                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                }
                var componentWillUpdateUniqueNames = new Set();
                if (pendingComponentWillUpdateWarnings.length > 0) {
                    pendingComponentWillUpdateWarnings.forEach(function (fiber) {
                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingComponentWillUpdateWarnings = [];
                }
                var UNSAFE_componentWillUpdateUniqueNames = new Set();
                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingUNSAFE_ComponentWillUpdateWarnings = [];
                }
                if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                    error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '\nPlease update the following components: %s', sortedNames);
                }
                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                    error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, " + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '\nPlease update the following components: %s', _sortedNames);
                }
                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                    error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '\nPlease update the following components: %s', _sortedNames2);
                }
                if (componentWillMountUniqueNames.size > 0) {
                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                    warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames3);
                }
                if (componentWillReceivePropsUniqueNames.size > 0) {
                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                    warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, refactor your " + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames4);
                }
                if (componentWillUpdateUniqueNames.size > 0) {
                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                    warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames5);
                }
            };
            var pendingLegacyContextWarning = new Map();
            var didWarnAboutLegacyContext = new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
                var strictRoot = findStrictRoot(fiber);
                if (strictRoot === null) {
                    error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                    return;
                }
                if (didWarnAboutLegacyContext.has(fiber.type)) {
                    return;
                }
                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
                    if (warningsForRoot === undefined) {
                        warningsForRoot = [];
                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                    }
                    warningsForRoot.push(fiber);
                }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function () {
                pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
                    if (fiberArray.length === 0) {
                        return;
                    }
                    var firstFiber = fiberArray[0];
                    var uniqueNames = new Set();
                    fiberArray.forEach(function (fiber) {
                        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutLegacyContext.add(fiber.type);
                    });
                    var sortedNames = setToSortedString(uniqueNames);
                    try {
                        setCurrentFiber(firstFiber);
                        error('Legacy context API has been detected within a strict-mode tree.' + '\n\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);
                    }
                    finally {
                        resetCurrentFiber();
                    }
                });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function () {
                pendingComponentWillMountWarnings = [];
                pendingUNSAFE_ComponentWillMountWarnings = [];
                pendingComponentWillReceivePropsWarnings = [];
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                pendingComponentWillUpdateWarnings = [];
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
                pendingLegacyContextWarning = new Map();
            };
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function (child, returnFiber) { };
        {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function (child, returnFiber) {
                if (child === null || typeof child !== 'object') {
                    return;
                }
                if (!child._store || child._store.validated || child.key != null) {
                    return;
                }
                if (typeof child._store !== 'object') {
                    throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                child._store.validated = true;
                var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                if (ownerHasKeyUseWarning[componentName]) {
                    return;
                }
                ownerHasKeyUseWarning[componentName] = true;
                error('Each child in a list should have a unique ' + '"key" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');
            };
        }
        function isReactClass(type) {
            return type.prototype && type.prototype.isReactComponent;
        }
        function coerceRef(returnFiber, current, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
                {
                    if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) &&
                        !(element._owner && element._self && element._owner.stateNode !== element._self) &&
                        !(element._owner && element._owner.tag !== ClassComponent) &&
                        !(typeof element.type === 'function' && !isReactClass(element.type)) &&
                        element._owner) {
                        var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                        if (!didWarnAboutStringRefs[componentName]) {
                            {
                                error('Component "%s" contains the string ref "%s". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                            }
                            didWarnAboutStringRefs[componentName] = true;
                        }
                    }
                }
                if (element._owner) {
                    var owner = element._owner;
                    var inst;
                    if (owner) {
                        var ownerFiber = owner;
                        if (ownerFiber.tag !== ClassComponent) {
                            throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');
                        }
                        inst = ownerFiber.stateNode;
                    }
                    if (!inst) {
                        throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a " + 'bug in React. Please file an issue.');
                    }
                    var resolvedInst = inst;
                    {
                        checkPropStringCoercion(mixedRef, 'ref');
                    }
                    var stringRef = '' + mixedRef;
                    if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
                        return current.ref;
                    }
                    var ref = function (value) {
                        var refs = resolvedInst.refs;
                        if (value === null) {
                            delete refs[stringRef];
                        }
                        else {
                            refs[stringRef] = value;
                        }
                    };
                    ref._stringRef = stringRef;
                    return ref;
                }
                else {
                    if (typeof mixedRef !== 'string') {
                        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');
                    }
                    if (!element._owner) {
                        throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of" + ' the following reasons:\n' + '1. You may be adding a ref to a function component\n' + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + '3. You have multiple copies of React loaded\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');
                    }
                }
            }
            return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
        }
        function warnOnFunctionType(returnFiber) {
            {
                var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                if (ownerHasFunctionTypeWarning[componentName]) {
                    return;
                }
                ownerHasFunctionTypeWarning[componentName] = true;
                error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
            }
        }
        function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init = lazyType._init;
            return init(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
                if (!shouldTrackSideEffects) {
                    return;
                }
                var deletions = returnFiber.deletions;
                if (deletions === null) {
                    returnFiber.deletions = [childToDelete];
                    returnFiber.flags |= ChildDeletion;
                }
                else {
                    deletions.push(childToDelete);
                }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
                if (!shouldTrackSideEffects) {
                    return null;
                }
                var childToDelete = currentFirstChild;
                while (childToDelete !== null) {
                    deleteChild(returnFiber, childToDelete);
                    childToDelete = childToDelete.sibling;
                }
                return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
                var existingChildren = new Map();
                var existingChild = currentFirstChild;
                while (existingChild !== null) {
                    if (existingChild.key !== null) {
                        existingChildren.set(existingChild.key, existingChild);
                    }
                    else {
                        existingChildren.set(existingChild.index, existingChild);
                    }
                    existingChild = existingChild.sibling;
                }
                return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
                var clone = createWorkInProgress(fiber, pendingProps);
                clone.index = 0;
                clone.sibling = null;
                return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
                newFiber.index = newIndex;
                if (!shouldTrackSideEffects) {
                    newFiber.flags |= Forked;
                    return lastPlacedIndex;
                }
                var current = newFiber.alternate;
                if (current !== null) {
                    var oldIndex = current.index;
                    if (oldIndex < lastPlacedIndex) {
                        newFiber.flags |= Placement;
                        return lastPlacedIndex;
                    }
                    else {
                        return oldIndex;
                    }
                }
                else {
                    newFiber.flags |= Placement;
                    return lastPlacedIndex;
                }
            }
            function placeSingleChild(newFiber) {
                if (shouldTrackSideEffects && newFiber.alternate === null) {
                    newFiber.flags |= Placement;
                }
                return newFiber;
            }
            function updateTextNode(returnFiber, current, textContent, lanes) {
                if (current === null || current.tag !== HostText) {
                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    return created;
                }
                else {
                    var existing = useFiber(current, textContent);
                    existing.return = returnFiber;
                    return existing;
                }
            }
            function updateElement(returnFiber, current, element, lanes) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
                }
                if (current !== null) {
                    if (current.elementType === elementType || (isCompatibleFamilyForHotReloading(current, element)) ||
                        typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {
                        var existing = useFiber(current, element.props);
                        existing.ref = coerceRef(returnFiber, current, element);
                        existing.return = returnFiber;
                        {
                            existing._debugSource = element._source;
                            existing._debugOwner = element._owner;
                        }
                        return existing;
                    }
                }
                var created = createFiberFromElement(element, returnFiber.mode, lanes);
                created.ref = coerceRef(returnFiber, current, element);
                created.return = returnFiber;
                return created;
            }
            function updatePortal(returnFiber, current, portal, lanes) {
                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    return created;
                }
                else {
                    var existing = useFiber(current, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                }
            }
            function updateFragment(returnFiber, current, fragment, lanes, key) {
                if (current === null || current.tag !== Fragment) {
                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                    created.return = returnFiber;
                    return created;
                }
                else {
                    var existing = useFiber(current, fragment);
                    existing.return = returnFiber;
                    return existing;
                }
            }
            function createChild(returnFiber, newChild, lanes) {
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    return created;
                }
                if (typeof newChild === 'object' && newChild !== null) {
                    switch (newChild.$$typeof) {
                        case REACT_ELEMENT_TYPE:
                            {
                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                                _created.ref = coerceRef(returnFiber, null, newChild);
                                _created.return = returnFiber;
                                return _created;
                            }
                        case REACT_PORTAL_TYPE:
                            {
                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                                _created2.return = returnFiber;
                                return _created2;
                            }
                        case REACT_LAZY_TYPE:
                            {
                                var payload = newChild._payload;
                                var init = newChild._init;
                                return createChild(returnFiber, init(payload), lanes);
                            }
                    }
                    if (isArray(newChild) || getIteratorFn(newChild)) {
                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                        _created3.return = returnFiber;
                        return _created3;
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber);
                    }
                }
                return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
                var key = oldFiber !== null ? oldFiber.key : null;
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    if (key !== null) {
                        return null;
                    }
                    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
                }
                if (typeof newChild === 'object' && newChild !== null) {
                    switch (newChild.$$typeof) {
                        case REACT_ELEMENT_TYPE:
                            {
                                if (newChild.key === key) {
                                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                                }
                                else {
                                    return null;
                                }
                            }
                        case REACT_PORTAL_TYPE:
                            {
                                if (newChild.key === key) {
                                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                                }
                                else {
                                    return null;
                                }
                            }
                        case REACT_LAZY_TYPE:
                            {
                                var payload = newChild._payload;
                                var init = newChild._init;
                                return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                            }
                    }
                    if (isArray(newChild) || getIteratorFn(newChild)) {
                        if (key !== null) {
                            return null;
                        }
                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber);
                    }
                }
                return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    var matchedFiber = existingChildren.get(newIdx) || null;
                    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
                }
                if (typeof newChild === 'object' && newChild !== null) {
                    switch (newChild.$$typeof) {
                        case REACT_ELEMENT_TYPE:
                            {
                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                            }
                        case REACT_PORTAL_TYPE:
                            {
                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                            }
                        case REACT_LAZY_TYPE:
                            var payload = newChild._payload;
                            var init = newChild._init;
                            return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
                    }
                    if (isArray(newChild) || getIteratorFn(newChild)) {
                        var _matchedFiber3 = existingChildren.get(newIdx) || null;
                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber);
                    }
                }
                return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
                {
                    if (typeof child !== 'object' || child === null) {
                        return knownKeys;
                    }
                    switch (child.$$typeof) {
                        case REACT_ELEMENT_TYPE:
                        case REACT_PORTAL_TYPE:
                            warnForMissingKey(child, returnFiber);
                            var key = child.key;
                            if (typeof key !== 'string') {
                                break;
                            }
                            if (knownKeys === null) {
                                knownKeys = new Set();
                                knownKeys.add(key);
                                break;
                            }
                            if (!knownKeys.has(key)) {
                                knownKeys.add(key);
                                break;
                            }
                            error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);
                            break;
                        case REACT_LAZY_TYPE:
                            var payload = child._payload;
                            var init = child._init;
                            warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                            break;
                    }
                }
                return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
                {
                    var knownKeys = null;
                    for (var i = 0; i < newChildren.length; i++) {
                        var child = newChildren[i];
                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                    }
                }
                var resultingFirstChild = null;
                var previousNewFiber = null;
                var oldFiber = currentFirstChild;
                var lastPlacedIndex = 0;
                var newIdx = 0;
                var nextOldFiber = null;
                for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                    if (oldFiber.index > newIdx) {
                        nextOldFiber = oldFiber;
                        oldFiber = null;
                    }
                    else {
                        nextOldFiber = oldFiber.sibling;
                    }
                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                    if (newFiber === null) {
                        if (oldFiber === null) {
                            oldFiber = nextOldFiber;
                        }
                        break;
                    }
                    if (shouldTrackSideEffects) {
                        if (oldFiber && newFiber.alternate === null) {
                            deleteChild(returnFiber, oldFiber);
                        }
                    }
                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) {
                        resultingFirstChild = newFiber;
                    }
                    else {
                        previousNewFiber.sibling = newFiber;
                    }
                    previousNewFiber = newFiber;
                    oldFiber = nextOldFiber;
                }
                if (newIdx === newChildren.length) {
                    deleteRemainingChildren(returnFiber, oldFiber);
                    if (getIsHydrating()) {
                        var numberOfForks = newIdx;
                        pushTreeFork(returnFiber, numberOfForks);
                    }
                    return resultingFirstChild;
                }
                if (oldFiber === null) {
                    for (; newIdx < newChildren.length; newIdx++) {
                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                        if (_newFiber === null) {
                            continue;
                        }
                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            resultingFirstChild = _newFiber;
                        }
                        else {
                            previousNewFiber.sibling = _newFiber;
                        }
                        previousNewFiber = _newFiber;
                    }
                    if (getIsHydrating()) {
                        var _numberOfForks = newIdx;
                        pushTreeFork(returnFiber, _numberOfForks);
                    }
                    return resultingFirstChild;
                }
                var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
                for (; newIdx < newChildren.length; newIdx++) {
                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                    if (_newFiber2 !== null) {
                        if (shouldTrackSideEffects) {
                            if (_newFiber2.alternate !== null) {
                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                            }
                        }
                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            resultingFirstChild = _newFiber2;
                        }
                        else {
                            previousNewFiber.sibling = _newFiber2;
                        }
                        previousNewFiber = _newFiber2;
                    }
                }
                if (shouldTrackSideEffects) {
                    existingChildren.forEach(function (child) {
                        return deleteChild(returnFiber, child);
                    });
                }
                if (getIsHydrating()) {
                    var _numberOfForks2 = newIdx;
                    pushTreeFork(returnFiber, _numberOfForks2);
                }
                return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
                var iteratorFn = getIteratorFn(newChildrenIterable);
                if (typeof iteratorFn !== 'function') {
                    throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');
                }
                {
                    if (typeof Symbol === 'function' &&
                        newChildrenIterable[Symbol.toStringTag] === 'Generator') {
                        if (!didWarnAboutGenerators) {
                            error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
                        }
                        didWarnAboutGenerators = true;
                    }
                    if (newChildrenIterable.entries === iteratorFn) {
                        if (!didWarnAboutMaps) {
                            error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                        }
                        didWarnAboutMaps = true;
                    }
                    var _newChildren = iteratorFn.call(newChildrenIterable);
                    if (_newChildren) {
                        var knownKeys = null;
                        var _step = _newChildren.next();
                        for (; !_step.done; _step = _newChildren.next()) {
                            var child = _step.value;
                            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                        }
                    }
                }
                var newChildren = iteratorFn.call(newChildrenIterable);
                if (newChildren == null) {
                    throw new Error('An iterable object provided no iterator.');
                }
                var resultingFirstChild = null;
                var previousNewFiber = null;
                var oldFiber = currentFirstChild;
                var lastPlacedIndex = 0;
                var newIdx = 0;
                var nextOldFiber = null;
                var step = newChildren.next();
                for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                    if (oldFiber.index > newIdx) {
                        nextOldFiber = oldFiber;
                        oldFiber = null;
                    }
                    else {
                        nextOldFiber = oldFiber.sibling;
                    }
                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                    if (newFiber === null) {
                        if (oldFiber === null) {
                            oldFiber = nextOldFiber;
                        }
                        break;
                    }
                    if (shouldTrackSideEffects) {
                        if (oldFiber && newFiber.alternate === null) {
                            deleteChild(returnFiber, oldFiber);
                        }
                    }
                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) {
                        resultingFirstChild = newFiber;
                    }
                    else {
                        previousNewFiber.sibling = newFiber;
                    }
                    previousNewFiber = newFiber;
                    oldFiber = nextOldFiber;
                }
                if (step.done) {
                    deleteRemainingChildren(returnFiber, oldFiber);
                    if (getIsHydrating()) {
                        var numberOfForks = newIdx;
                        pushTreeFork(returnFiber, numberOfForks);
                    }
                    return resultingFirstChild;
                }
                if (oldFiber === null) {
                    for (; !step.done; newIdx++, step = newChildren.next()) {
                        var _newFiber3 = createChild(returnFiber, step.value, lanes);
                        if (_newFiber3 === null) {
                            continue;
                        }
                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            resultingFirstChild = _newFiber3;
                        }
                        else {
                            previousNewFiber.sibling = _newFiber3;
                        }
                        previousNewFiber = _newFiber3;
                    }
                    if (getIsHydrating()) {
                        var _numberOfForks3 = newIdx;
                        pushTreeFork(returnFiber, _numberOfForks3);
                    }
                    return resultingFirstChild;
                }
                var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
                for (; !step.done; newIdx++, step = newChildren.next()) {
                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                    if (_newFiber4 !== null) {
                        if (shouldTrackSideEffects) {
                            if (_newFiber4.alternate !== null) {
                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                            }
                        }
                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            resultingFirstChild = _newFiber4;
                        }
                        else {
                            previousNewFiber.sibling = _newFiber4;
                        }
                        previousNewFiber = _newFiber4;
                    }
                }
                if (shouldTrackSideEffects) {
                    existingChildren.forEach(function (child) {
                        return deleteChild(returnFiber, child);
                    });
                }
                if (getIsHydrating()) {
                    var _numberOfForks4 = newIdx;
                    pushTreeFork(returnFiber, _numberOfForks4);
                }
                return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    var existing = useFiber(currentFirstChild, textContent);
                    existing.return = returnFiber;
                    return existing;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
                var key = element.key;
                var child = currentFirstChild;
                while (child !== null) {
                    if (child.key === key) {
                        var elementType = element.type;
                        if (elementType === REACT_FRAGMENT_TYPE) {
                            if (child.tag === Fragment) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var existing = useFiber(child, element.props.children);
                                existing.return = returnFiber;
                                {
                                    existing._debugSource = element._source;
                                    existing._debugOwner = element._owner;
                                }
                                return existing;
                            }
                        }
                        else {
                            if (child.elementType === elementType || (isCompatibleFamilyForHotReloading(child, element)) ||
                                typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var _existing = useFiber(child, element.props);
                                _existing.ref = coerceRef(returnFiber, child, element);
                                _existing.return = returnFiber;
                                {
                                    _existing._debugSource = element._source;
                                    _existing._debugOwner = element._owner;
                                }
                                return _existing;
                            }
                        }
                        deleteRemainingChildren(returnFiber, child);
                        break;
                    }
                    else {
                        deleteChild(returnFiber, child);
                    }
                    child = child.sibling;
                }
                if (element.type === REACT_FRAGMENT_TYPE) {
                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                    created.return = returnFiber;
                    return created;
                }
                else {
                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                    _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                    _created4.return = returnFiber;
                    return _created4;
                }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
                var key = portal.key;
                var child = currentFirstChild;
                while (child !== null) {
                    if (child.key === key) {
                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                            deleteRemainingChildren(returnFiber, child.sibling);
                            var existing = useFiber(child, portal.children || []);
                            existing.return = returnFiber;
                            return existing;
                        }
                        else {
                            deleteRemainingChildren(returnFiber, child);
                            break;
                        }
                    }
                    else {
                        deleteChild(returnFiber, child);
                    }
                    child = child.sibling;
                }
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            }
            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
                var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
                if (isUnkeyedTopLevelFragment) {
                    newChild = newChild.props.children;
                }
                if (typeof newChild === 'object' && newChild !== null) {
                    switch (newChild.$$typeof) {
                        case REACT_ELEMENT_TYPE:
                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                        case REACT_PORTAL_TYPE:
                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                        case REACT_LAZY_TYPE:
                            var payload = newChild._payload;
                            var init = newChild._init;
                            return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);
                    }
                    if (isArray(newChild)) {
                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                    }
                    if (getIteratorFn(newChild)) {
                        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber);
                    }
                }
                return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current, workInProgress) {
            if (current !== null && workInProgress.child !== current.child) {
                throw new Error('Resuming work not yet implemented.');
            }
            if (workInProgress.child === null) {
                return;
            }
            var currentChild = workInProgress.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress.child = newChild;
            newChild.return = workInProgress;
            while (currentChild.sibling !== null) {
                currentChild = currentChild.sibling;
                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
                newChild.return = workInProgress;
            }
            newChild.sibling = null;
        }
        function resetChildFibers(workInProgress, lanes) {
            var child = workInProgress.child;
            while (child !== null) {
                resetWorkInProgress(child, lanes);
                child = child.sibling;
            }
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
            rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
                isDisallowedContextReadInDEV = false;
            }
        }
        function enterDisallowedContextReadInDEV() {
            {
                isDisallowedContextReadInDEV = true;
            }
        }
        function exitDisallowedContextReadInDEV() {
            {
                isDisallowedContextReadInDEV = false;
            }
        }
        function pushProvider(providerFiber, context, nextValue) {
            {
                push(valueCursor, context._currentValue, providerFiber);
                context._currentValue = nextValue;
                {
                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
                    }
                    context._currentRenderer = rendererSigil;
                }
            }
        }
        function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
                {
                    context._currentValue = currentValue;
                }
            }
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
            var node = parent;
            while (node !== null) {
                var alternate = node.alternate;
                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
                    node.childLanes = mergeLanes(node.childLanes, renderLanes);
                    if (alternate !== null) {
                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
                    }
                }
                else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {
                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
                }
                if (node === propagationRoot) {
                    break;
                }
                node = node.return;
            }
            {
                if (node !== propagationRoot) {
                    error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
            }
        }
        function propagateContextChange(workInProgress, context, renderLanes) {
            {
                propagateContextChange_eager(workInProgress, context, renderLanes);
            }
        }
        function propagateContextChange_eager(workInProgress, context, renderLanes) {
            var fiber = workInProgress.child;
            if (fiber !== null) {
                fiber.return = workInProgress;
            }
            while (fiber !== null) {
                var nextFiber = void 0;
                var list = fiber.dependencies;
                if (list !== null) {
                    nextFiber = fiber.child;
                    var dependency = list.firstContext;
                    while (dependency !== null) {
                        if (dependency.context === context) {
                            if (fiber.tag === ClassComponent) {
                                var lane = pickArbitraryLane(renderLanes);
                                var update = createUpdate(NoTimestamp, lane);
                                update.tag = ForceUpdate;
                                var updateQueue = fiber.updateQueue;
                                if (updateQueue === null)
                                    ;
                                else {
                                    var sharedQueue = updateQueue.shared;
                                    var pending = sharedQueue.pending;
                                    if (pending === null) {
                                        update.next = update;
                                    }
                                    else {
                                        update.next = pending.next;
                                        pending.next = update;
                                    }
                                    sharedQueue.pending = update;
                                }
                            }
                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
                            var alternate = fiber.alternate;
                            if (alternate !== null) {
                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
                            }
                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress);
                            list.lanes = mergeLanes(list.lanes, renderLanes);
                            break;
                        }
                        dependency = dependency.next;
                    }
                }
                else if (fiber.tag === ContextProvider) {
                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
                }
                else if (fiber.tag === DehydratedFragment) {
                    var parentSuspense = fiber.return;
                    if (parentSuspense === null) {
                        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');
                    }
                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);
                    var _alternate = parentSuspense.alternate;
                    if (_alternate !== null) {
                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);
                    }
                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);
                    nextFiber = fiber.sibling;
                }
                else {
                    nextFiber = fiber.child;
                }
                if (nextFiber !== null) {
                    nextFiber.return = fiber;
                }
                else {
                    nextFiber = fiber;
                    while (nextFiber !== null) {
                        if (nextFiber === workInProgress) {
                            nextFiber = null;
                            break;
                        }
                        var sibling = nextFiber.sibling;
                        if (sibling !== null) {
                            sibling.return = nextFiber.return;
                            nextFiber = sibling;
                            break;
                        }
                        nextFiber = nextFiber.return;
                    }
                }
                fiber = nextFiber;
            }
        }
        function prepareToReadContext(workInProgress, renderLanes) {
            currentlyRenderingFiber = workInProgress;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress.dependencies;
            if (dependencies !== null) {
                {
                    var firstContext = dependencies.firstContext;
                    if (firstContext !== null) {
                        if (includesSomeLane(dependencies.lanes, renderLanes)) {
                            markWorkInProgressReceivedUpdate();
                        }
                        dependencies.firstContext = null;
                    }
                }
            }
        }
        function readContext(context) {
            {
                if (isDisallowedContextReadInDEV) {
                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                }
            }
            var value = context._currentValue;
            if (lastFullyObservedContext === context)
                ;
            else {
                var contextItem = {
                    context: context,
                    memoizedValue: value,
                    next: null
                };
                if (lastContextDependency === null) {
                    if (currentlyRenderingFiber === null) {
                        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                    }
                    lastContextDependency = contextItem;
                    currentlyRenderingFiber.dependencies = {
                        lanes: NoLanes,
                        firstContext: contextItem
                    };
                }
                else {
                    lastContextDependency = lastContextDependency.next = contextItem;
                }
            }
            return value;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
                concurrentQueues = [queue];
            }
            else {
                concurrentQueues.push(queue);
            }
        }
        function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
                for (var i = 0; i < concurrentQueues.length; i++) {
                    var queue = concurrentQueues[i];
                    var lastInterleavedUpdate = queue.interleaved;
                    if (lastInterleavedUpdate !== null) {
                        queue.interleaved = null;
                        var firstInterleavedUpdate = lastInterleavedUpdate.next;
                        var lastPendingUpdate = queue.pending;
                        if (lastPendingUpdate !== null) {
                            var firstPendingUpdate = lastPendingUpdate.next;
                            lastPendingUpdate.next = firstInterleavedUpdate;
                            lastInterleavedUpdate.next = firstPendingUpdate;
                        }
                        queue.pending = lastInterleavedUpdate;
                    }
                }
                concurrentQueues = null;
            }
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
                update.next = update;
                pushConcurrentUpdateQueue(queue);
            }
            else {
                update.next = interleaved.next;
                interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
                update.next = update;
                pushConcurrentUpdateQueue(queue);
            }
            else {
                update.next = interleaved.next;
                interleaved.next = update;
            }
            queue.interleaved = update;
        }
        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
                update.next = update;
                pushConcurrentUpdateQueue(queue);
            }
            else {
                update.next = interleaved.next;
                interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
                alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
                if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
                parent.childLanes = mergeLanes(parent.childLanes, lane);
                alternate = parent.alternate;
                if (alternate !== null) {
                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);
                }
                else {
                    {
                        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                        }
                    }
                }
                node = parent;
                parent = parent.return;
            }
            if (node.tag === HostRoot) {
                var root = node.stateNode;
                return root;
            }
            else {
                return null;
            }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
            var queue = {
                baseState: fiber.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    interleaved: null,
                    lanes: NoLanes
                },
                effects: null
            };
            fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current, workInProgress) {
            var queue = workInProgress.updateQueue;
            var currentQueue = current.updateQueue;
            if (queue === currentQueue) {
                var clone = {
                    baseState: currentQueue.baseState,
                    firstBaseUpdate: currentQueue.firstBaseUpdate,
                    lastBaseUpdate: currentQueue.lastBaseUpdate,
                    shared: currentQueue.shared,
                    effects: currentQueue.effects
                };
                workInProgress.updateQueue = clone;
            }
        }
        function createUpdate(eventTime, lane) {
            var update = {
                eventTime: eventTime,
                lane: lane,
                tag: UpdateState,
                payload: null,
                callback: null,
                next: null
            };
            return update;
        }
        function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
                return null;
            }
            var sharedQueue = updateQueue.shared;
            {
                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                    error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
                    didWarnUpdateInsideUpdate = true;
                }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
                var pending = sharedQueue.pending;
                if (pending === null) {
                    update.next = update;
                }
                else {
                    update.next = pending.next;
                    pending.next = update;
                }
                sharedQueue.pending = update;
                return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            }
            else {
                return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
        }
        function entangleTransitions(root, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
                return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
                var queueLanes = sharedQueue.lanes;
                queueLanes = intersectLanes(queueLanes, root.pendingLanes);
                var newQueueLanes = mergeLanes(queueLanes, lane);
                sharedQueue.lanes = newQueueLanes;
                markRootEntangled(root, newQueueLanes);
            }
        }
        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
            var queue = workInProgress.updateQueue;
            var current = workInProgress.alternate;
            if (current !== null) {
                var currentQueue = current.updateQueue;
                if (queue === currentQueue) {
                    var newFirst = null;
                    var newLast = null;
                    var firstBaseUpdate = queue.firstBaseUpdate;
                    if (firstBaseUpdate !== null) {
                        var update = firstBaseUpdate;
                        do {
                            var clone = {
                                eventTime: update.eventTime,
                                lane: update.lane,
                                tag: update.tag,
                                payload: update.payload,
                                callback: update.callback,
                                next: null
                            };
                            if (newLast === null) {
                                newFirst = newLast = clone;
                            }
                            else {
                                newLast.next = clone;
                                newLast = clone;
                            }
                            update = update.next;
                        } while (update !== null);
                        if (newLast === null) {
                            newFirst = newLast = capturedUpdate;
                        }
                        else {
                            newLast.next = capturedUpdate;
                            newLast = capturedUpdate;
                        }
                    }
                    else {
                        newFirst = newLast = capturedUpdate;
                    }
                    queue = {
                        baseState: currentQueue.baseState,
                        firstBaseUpdate: newFirst,
                        lastBaseUpdate: newLast,
                        shared: currentQueue.shared,
                        effects: currentQueue.effects
                    };
                    workInProgress.updateQueue = queue;
                    return;
                }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
                queue.firstBaseUpdate = capturedUpdate;
            }
            else {
                lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
                case ReplaceState:
                    {
                        var payload = update.payload;
                        if (typeof payload === 'function') {
                            {
                                enterDisallowedContextReadInDEV();
                            }
                            var nextState = payload.call(instance, prevState, nextProps);
                            {
                                if (workInProgress.mode & StrictLegacyMode) {
                                    setIsStrictModeForDevtools(true);
                                    try {
                                        payload.call(instance, prevState, nextProps);
                                    }
                                    finally {
                                        setIsStrictModeForDevtools(false);
                                    }
                                }
                                exitDisallowedContextReadInDEV();
                            }
                            return nextState;
                        }
                        return payload;
                    }
                case CaptureUpdate:
                    {
                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
                    }
                case UpdateState:
                    {
                        var _payload = update.payload;
                        var partialState;
                        if (typeof _payload === 'function') {
                            {
                                enterDisallowedContextReadInDEV();
                            }
                            partialState = _payload.call(instance, prevState, nextProps);
                            {
                                if (workInProgress.mode & StrictLegacyMode) {
                                    setIsStrictModeForDevtools(true);
                                    try {
                                        _payload.call(instance, prevState, nextProps);
                                    }
                                    finally {
                                        setIsStrictModeForDevtools(false);
                                    }
                                }
                                exitDisallowedContextReadInDEV();
                            }
                        }
                        else {
                            partialState = _payload;
                        }
                        if (partialState === null || partialState === undefined) {
                            return prevState;
                        }
                        return assign({}, prevState, partialState);
                    }
                case ForceUpdate:
                    {
                        hasForceUpdate = true;
                        return prevState;
                    }
            }
            return prevState;
        }
        function processUpdateQueue(workInProgress, props, instance, renderLanes) {
            var queue = workInProgress.updateQueue;
            hasForceUpdate = false;
            {
                currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
                queue.shared.pending = null;
                var lastPendingUpdate = pendingQueue;
                var firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = null;
                if (lastBaseUpdate === null) {
                    firstBaseUpdate = firstPendingUpdate;
                }
                else {
                    lastBaseUpdate.next = firstPendingUpdate;
                }
                lastBaseUpdate = lastPendingUpdate;
                var current = workInProgress.alternate;
                if (current !== null) {
                    var currentQueue = current.updateQueue;
                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                    if (currentLastBaseUpdate !== lastBaseUpdate) {
                        if (currentLastBaseUpdate === null) {
                            currentQueue.firstBaseUpdate = firstPendingUpdate;
                        }
                        else {
                            currentLastBaseUpdate.next = firstPendingUpdate;
                        }
                        currentQueue.lastBaseUpdate = lastPendingUpdate;
                    }
                }
            }
            if (firstBaseUpdate !== null) {
                var newState = queue.baseState;
                var newLanes = NoLanes;
                var newBaseState = null;
                var newFirstBaseUpdate = null;
                var newLastBaseUpdate = null;
                var update = firstBaseUpdate;
                do {
                    var updateLane = update.lane;
                    var updateEventTime = update.eventTime;
                    if (!isSubsetOfLanes(renderLanes, updateLane)) {
                        var clone = {
                            eventTime: updateEventTime,
                            lane: updateLane,
                            tag: update.tag,
                            payload: update.payload,
                            callback: update.callback,
                            next: null
                        };
                        if (newLastBaseUpdate === null) {
                            newFirstBaseUpdate = newLastBaseUpdate = clone;
                            newBaseState = newState;
                        }
                        else {
                            newLastBaseUpdate = newLastBaseUpdate.next = clone;
                        }
                        newLanes = mergeLanes(newLanes, updateLane);
                    }
                    else {
                        if (newLastBaseUpdate !== null) {
                            var _clone = {
                                eventTime: updateEventTime,
                                lane: NoLane,
                                tag: update.tag,
                                payload: update.payload,
                                callback: update.callback,
                                next: null
                            };
                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                        }
                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
                        var callback = update.callback;
                        if (callback !== null &&
                            update.lane !== NoLane) {
                            workInProgress.flags |= Callback;
                            var effects = queue.effects;
                            if (effects === null) {
                                queue.effects = [update];
                            }
                            else {
                                effects.push(update);
                            }
                        }
                    }
                    update = update.next;
                    if (update === null) {
                        pendingQueue = queue.shared.pending;
                        if (pendingQueue === null) {
                            break;
                        }
                        else {
                            var _lastPendingUpdate = pendingQueue;
                            var _firstPendingUpdate = _lastPendingUpdate.next;
                            _lastPendingUpdate.next = null;
                            update = _firstPendingUpdate;
                            queue.lastBaseUpdate = _lastPendingUpdate;
                            queue.shared.pending = null;
                        }
                    }
                } while (true);
                if (newLastBaseUpdate === null) {
                    newBaseState = newState;
                }
                queue.baseState = newBaseState;
                queue.firstBaseUpdate = newFirstBaseUpdate;
                queue.lastBaseUpdate = newLastBaseUpdate;
                var lastInterleaved = queue.shared.interleaved;
                if (lastInterleaved !== null) {
                    var interleaved = lastInterleaved;
                    do {
                        newLanes = mergeLanes(newLanes, interleaved.lane);
                        interleaved = interleaved.next;
                    } while (interleaved !== lastInterleaved);
                }
                else if (firstBaseUpdate === null) {
                    queue.shared.lanes = NoLanes;
                }
                markSkippedUpdateLanes(newLanes);
                workInProgress.lanes = newLanes;
                workInProgress.memoizedState = newState;
            }
            {
                currentlyProcessingQueue = null;
            }
        }
        function callCallback(callback, context) {
            if (typeof callback !== 'function') {
                throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + ("received: " + callback));
            }
            callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
                for (var i = 0; i < effects.length; i++) {
                    var effect = effects[i];
                    var callback = effect.callback;
                    if (callback !== null) {
                        effect.callback = null;
                        callCallback(callback, instance);
                    }
                }
            }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c) {
            if (c === NO_CONTEXT) {
                throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');
            }
            return c;
        }
        function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
        }
        function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
                return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
                return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
            var nextState = workInProgress.memoizedState;
            if (nextState !== null) {
                if (nextState.dehydrated !== null) {
                    return true;
                }
                return false;
            }
            var props = workInProgress.memoizedProps;
            {
                return true;
            }
        }
        function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
                if (node.tag === SuspenseComponent) {
                    var state = node.memoizedState;
                    if (state !== null) {
                        var dehydrated = state.dehydrated;
                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                            return node;
                        }
                    }
                }
                else if (node.tag === SuspenseListComponent &&
                    node.memoizedProps.revealOrder !== undefined) {
                    var didSuspend = (node.flags & DidCapture) !== NoFlags;
                    if (didSuspend) {
                        return node;
                    }
                }
                else if (node.child !== null) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
                if (node === row) {
                    return null;
                }
                while (node.sibling === null) {
                    if (node.return === null || node.return === row) {
                        return null;
                    }
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
            return null;
        }
        var NoFlags$1 = 0;
        var HasEffect = 1;
        var Insertion = 2;
        var Layout = 4;
        var Passive$1 = 8;
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
                var mutableSource = workInProgressSources[i];
                {
                    mutableSource._workInProgressVersionPrimary = null;
                }
            }
            workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version = getVersion(mutableSource._source);
            if (root.mutableSourceEagerHydrationData == null) {
                root.mutableSourceEagerHydrationData = [mutableSource, version];
            }
            else {
                root.mutableSourceEagerHydrationData.push(mutableSource, version);
            }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
            didWarnAboutMismatchedHooksForComponent = new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
            {
                var hookName = currentHookNameInDev;
                if (hookTypesDev === null) {
                    hookTypesDev = [hookName];
                }
                else {
                    hookTypesDev.push(hookName);
                }
            }
        }
        function updateHookTypesDev() {
            {
                var hookName = currentHookNameInDev;
                if (hookTypesDev !== null) {
                    hookTypesUpdateIndexDev++;
                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                        warnOnHookMismatchInDev(hookName);
                    }
                }
            }
        }
        function checkDepsAreArrayDev(deps) {
            {
                if (deps !== undefined && deps !== null && !isArray(deps)) {
                    error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);
                }
            }
        }
        function warnOnHookMismatchInDev(currentHookName) {
            {
                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                    didWarnAboutMismatchedHooksForComponent.add(componentName);
                    if (hookTypesDev !== null) {
                        var table = '';
                        var secondColumnStart = 30;
                        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                            var oldHookName = hookTypesDev[i];
                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                            var row = i + 1 + ". " + oldHookName;
                            while (row.length < secondColumnStart) {
                                row += ' ';
                            }
                            row += newHookName + '\n';
                            table += row;
                        }
                        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
                    }
                }
            }
        }
        function throwInvalidHookError() {
            throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
            {
                if (ignorePreviousDependencies) {
                    return false;
                }
            }
            if (prevDeps === null) {
                {
                    error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
                }
                return false;
            }
            {
                if (nextDeps.length !== prevDeps.length) {
                    error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
                }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
                if (objectIs(nextDeps[i], prevDeps[i])) {
                    continue;
                }
                return false;
            }
            return true;
        }
        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress;
            {
                hookTypesDev = current !== null ? current._debugHookTypes : null;
                hookTypesUpdateIndexDev = -1;
                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
            }
            workInProgress.memoizedState = null;
            workInProgress.updateQueue = null;
            workInProgress.lanes = NoLanes;
            {
                if (current !== null && current.memoizedState !== null) {
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
                }
                else if (hookTypesDev !== null) {
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
                }
                else {
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
                }
            }
            var children = Component(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
                var numberOfReRenders = 0;
                do {
                    didScheduleRenderPhaseUpdateDuringThisPass = false;
                    localIdCounter = 0;
                    if (numberOfReRenders >= RE_RENDER_LIMIT) {
                        throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');
                    }
                    numberOfReRenders += 1;
                    {
                        ignorePreviousDependencies = false;
                    }
                    currentHook = null;
                    workInProgressHook = null;
                    workInProgress.updateQueue = null;
                    {
                        hookTypesUpdateIndexDev = -1;
                    }
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                    children = Component(props, secondArg);
                } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
                workInProgress._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
                currentHookNameInDev = null;
                hookTypesDev = null;
                hookTypesUpdateIndexDev = -1;
                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) &&
                    (current.mode & ConcurrentMode) !== NoMode) {
                    error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');
                }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
                throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');
            }
            return children;
        }
        function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
        }
        function bailoutHooks(current, workInProgress, lanes) {
            workInProgress.updateQueue = current.updateQueue;
            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            }
            else {
                workInProgress.flags &= ~(Passive | Update);
            }
            current.lanes = removeLanes(current.lanes, lanes);
        }
        function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
                var hook = currentlyRenderingFiber$1.memoizedState;
                while (hook !== null) {
                    var queue = hook.queue;
                    if (queue !== null) {
                        queue.pending = null;
                    }
                    hook = hook.next;
                }
                didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
                hookTypesDev = null;
                hookTypesUpdateIndexDev = -1;
                currentHookNameInDev = null;
                isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
            var hook = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            }
            else {
                workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
        }
        function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
                var current = currentlyRenderingFiber$1.alternate;
                if (current !== null) {
                    nextCurrentHook = current.memoizedState;
                }
                else {
                    nextCurrentHook = null;
                }
            }
            else {
                nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            }
            else {
                nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
                workInProgressHook = nextWorkInProgressHook;
                nextWorkInProgressHook = workInProgressHook.next;
                currentHook = nextCurrentHook;
            }
            else {
                if (nextCurrentHook === null) {
                    throw new Error('Rendered more hooks than during the previous render.');
                }
                currentHook = nextCurrentHook;
                var newHook = {
                    memoizedState: currentHook.memoizedState,
                    baseState: currentHook.baseState,
                    baseQueue: currentHook.baseQueue,
                    queue: currentHook.queue,
                    next: null
                };
                if (workInProgressHook === null) {
                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
                }
                else {
                    workInProgressHook = workInProgressHook.next = newHook;
                }
            }
            return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
            return {
                lastEffect: null,
                stores: null
            };
        }
        function basicStateReducer(state, action) {
            return typeof action === 'function' ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== undefined) {
                initialState = init(initialArg);
            }
            else {
                initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
                pending: null,
                interleaved: null,
                lanes: NoLanes,
                dispatch: null,
                lastRenderedReducer: reducer,
                lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');
            }
            queue.lastRenderedReducer = reducer;
            var current = currentHook;
            var baseQueue = current.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
                if (baseQueue !== null) {
                    var baseFirst = baseQueue.next;
                    var pendingFirst = pendingQueue.next;
                    baseQueue.next = pendingFirst;
                    pendingQueue.next = baseFirst;
                }
                {
                    if (current.baseQueue !== baseQueue) {
                        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');
                    }
                }
                current.baseQueue = baseQueue = pendingQueue;
                queue.pending = null;
            }
            if (baseQueue !== null) {
                var first = baseQueue.next;
                var newState = current.baseState;
                var newBaseState = null;
                var newBaseQueueFirst = null;
                var newBaseQueueLast = null;
                var update = first;
                do {
                    var updateLane = update.lane;
                    if (!isSubsetOfLanes(renderLanes, updateLane)) {
                        var clone = {
                            lane: updateLane,
                            action: update.action,
                            hasEagerState: update.hasEagerState,
                            eagerState: update.eagerState,
                            next: null
                        };
                        if (newBaseQueueLast === null) {
                            newBaseQueueFirst = newBaseQueueLast = clone;
                            newBaseState = newState;
                        }
                        else {
                            newBaseQueueLast = newBaseQueueLast.next = clone;
                        }
                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                        markSkippedUpdateLanes(updateLane);
                    }
                    else {
                        if (newBaseQueueLast !== null) {
                            var _clone = {
                                lane: NoLane,
                                action: update.action,
                                hasEagerState: update.hasEagerState,
                                eagerState: update.eagerState,
                                next: null
                            };
                            newBaseQueueLast = newBaseQueueLast.next = _clone;
                        }
                        if (update.hasEagerState) {
                            newState = update.eagerState;
                        }
                        else {
                            var action = update.action;
                            newState = reducer(newState, action);
                        }
                    }
                    update = update.next;
                } while (update !== null && update !== first);
                if (newBaseQueueLast === null) {
                    newBaseState = newState;
                }
                else {
                    newBaseQueueLast.next = newBaseQueueFirst;
                }
                if (!objectIs(newState, hook.memoizedState)) {
                    markWorkInProgressReceivedUpdate();
                }
                hook.memoizedState = newState;
                hook.baseState = newBaseState;
                hook.baseQueue = newBaseQueueLast;
                queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                    var interleavedLane = interleaved.lane;
                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                    markSkippedUpdateLanes(interleavedLane);
                    interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
            }
            else if (baseQueue === null) {
                queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
                queue.pending = null;
                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                var update = firstRenderPhaseUpdate;
                do {
                    var action = update.action;
                    newState = reducer(newState, action);
                    update = update.next;
                } while (update !== firstRenderPhaseUpdate);
                if (!objectIs(newState, hook.memoizedState)) {
                    markWorkInProgressReceivedUpdate();
                }
                hook.memoizedState = newState;
                if (hook.baseQueue === null) {
                    hook.baseState = newState;
                }
                queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
        }
        function mountMutableSource(source, getSnapshot, subscribe) {
            {
                return undefined;
            }
        }
        function updateMutableSource(source, getSnapshot, subscribe) {
            {
                return undefined;
            }
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating = getIsHydrating();
            if (isHydrating) {
                if (getServerSnapshot === undefined) {
                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');
                }
                nextSnapshot = getServerSnapshot();
                {
                    if (!didWarnUncachedGetSnapshot) {
                        if (nextSnapshot !== getServerSnapshot()) {
                            error('The result of getServerSnapshot should be cached to avoid an infinite loop');
                            didWarnUncachedGetSnapshot = true;
                        }
                    }
                }
            }
            else {
                nextSnapshot = getSnapshot();
                {
                    if (!didWarnUncachedGetSnapshot) {
                        var cachedSnapshot = getSnapshot();
                        if (!objectIs(nextSnapshot, cachedSnapshot)) {
                            error('The result of getSnapshot should be cached to avoid an infinite loop');
                            didWarnUncachedGetSnapshot = true;
                        }
                    }
                }
                var root = getWorkInProgressRoot();
                if (root === null) {
                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');
                }
                if (!includesBlockingLane(root, renderLanes)) {
                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
                value: nextSnapshot,
                getSnapshot: getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);
            return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
                if (!didWarnUncachedGetSnapshot) {
                    var cachedSnapshot = getSnapshot();
                    if (!objectIs(nextSnapshot, cachedSnapshot)) {
                        error('The result of getSnapshot should be cached to avoid an infinite loop');
                        didWarnUncachedGetSnapshot = true;
                    }
                }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
                hook.memoizedState = nextSnapshot;
                markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged ||
                workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
                fiber.flags |= Passive;
                pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);
                var root = getWorkInProgressRoot();
                if (root === null) {
                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');
                }
                if (!includesBlockingLane(root, renderLanes)) {
                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                }
            }
            return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
                getSnapshot: getSnapshot,
                value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
                componentUpdateQueue = createFunctionComponentUpdateQueue();
                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                componentUpdateQueue.stores = [check];
            }
            else {
                var stores = componentUpdateQueue.stores;
                if (stores === null) {
                    componentUpdateQueue.stores = [check];
                }
                else {
                    stores.push(check);
                }
            }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
            }
        }
        function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function () {
                if (checkIfSnapshotChanged(inst)) {
                    forceStoreRerender(fiber);
                }
            };
            return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
                var nextValue = latestGetSnapshot();
                return !objectIs(prevValue, nextValue);
            }
            catch (error) {
                return true;
            }
        }
        function forceStoreRerender(fiber) {
            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root !== null) {
                scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
            }
        }
        function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === 'function') {
                initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
                pending: null,
                interleaved: null,
                lanes: NoLanes,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
            return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create, destroy, deps) {
            var effect = {
                tag: tag,
                create: create,
                destroy: destroy,
                deps: deps,
                next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
                componentUpdateQueue = createFunctionComponentUpdateQueue();
                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                componentUpdateQueue.lastEffect = effect.next = effect;
            }
            else {
                var lastEffect = componentUpdateQueue.lastEffect;
                if (lastEffect === null) {
                    componentUpdateQueue.lastEffect = effect.next = effect;
                }
                else {
                    var firstEffect = lastEffect.next;
                    lastEffect.next = effect;
                    effect.next = firstEffect;
                    componentUpdateQueue.lastEffect = effect;
                }
            }
            return effect;
        }
        function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
                var _ref2 = {
                    current: initialValue
                };
                hook.memoizedState = _ref2;
                return _ref2;
            }
        }
        function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var destroy = undefined;
            if (currentHook !== null) {
                var prevEffect = currentHook.memoizedState;
                destroy = prevEffect.destroy;
                if (nextDeps !== null) {
                    var prevDeps = prevEffect.deps;
                    if (areHookInputsEqual(nextDeps, prevDeps)) {
                        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                        return;
                    }
                }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
        }
        function mountEffect(create, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
            }
            else {
                return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
            }
        }
        function updateEffect(create, deps) {
            return updateEffectImpl(Passive, Passive$1, create, deps);
        }
        function mountInsertionEffect(create, deps) {
            return mountEffectImpl(Update, Insertion, create, deps);
        }
        function updateInsertionEffect(create, deps) {
            return updateEffectImpl(Update, Insertion, create, deps);
        }
        function mountLayoutEffect(create, deps) {
            var fiberFlags = Update;
            {
                fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
            if (typeof ref === 'function') {
                var refCallback = ref;
                var _inst = create();
                refCallback(_inst);
                return function () {
                    refCallback(null);
                };
            }
            else if (ref !== null && ref !== undefined) {
                var refObject = ref;
                {
                    if (!refObject.hasOwnProperty('current')) {
                        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
                    }
                }
                var _inst2 = create();
                refObject.current = _inst2;
                return function () {
                    refObject.current = null;
                };
            }
        }
        function mountImperativeHandle(ref, create, deps) {
            {
                if (typeof create !== 'function') {
                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
                }
            }
            var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
                fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create, deps) {
            {
                if (typeof create !== 'function') {
                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
                }
            }
            var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
        }
        function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
                if (nextDeps !== null) {
                    var prevDeps = prevState[1];
                    if (areHookInputsEqual(nextDeps, prevDeps)) {
                        return prevState[0];
                    }
                }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
        }
        function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
        }
        function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
                if (nextDeps !== null) {
                    var prevDeps = prevState[1];
                    if (areHookInputsEqual(nextDeps, prevDeps)) {
                        return prevState[0];
                    }
                }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
        }
        function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
        }
        function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
                hook.memoizedState = value;
                return value;
            }
            else {
                var prevValue = currentHook.memoizedState;
                return updateDeferredValueImpl(hook, prevValue, value);
            }
        }
        function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
                if (!objectIs(value, prevValue)) {
                    var deferredLane = claimNextTransitionLane();
                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                    markSkippedUpdateLanes(deferredLane);
                    hook.baseState = true;
                }
                return prevValue;
            }
            else {
                if (hook.baseState) {
                    hook.baseState = false;
                    markWorkInProgressReceivedUpdate();
                }
                hook.memoizedState = value;
                return value;
            }
        }
        function startTransition(setPending, callback, options) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
                ReactCurrentBatchConfig$2.transition._updatedFibers = new Set();
            }
            try {
                setPending(false);
                callback();
            }
            finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$2.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                        currentTransition._updatedFibers.clear();
                    }
                }
            }
        }
        function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start;
            return [isPending, start];
        }
        function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
        }
        function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
                return isUpdatingOpaqueValueInRenderPhase;
            }
        }
        function mountId() {
            var hook = mountWorkInProgressHook();
            var root = getWorkInProgressRoot();
            var identifierPrefix = root.identifierPrefix;
            var id;
            if (getIsHydrating()) {
                var treeId = getTreeId();
                id = ':' + identifierPrefix + 'R' + treeId;
                var localId = localIdCounter++;
                if (localId > 0) {
                    id += 'H' + localId.toString(32);
                }
                id += ':';
            }
            else {
                var globalClientId = globalClientIdCounter++;
                id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';
            }
            hook.memoizedState = id;
            return id;
        }
        function updateId() {
            var hook = updateWorkInProgressHook();
            var id = hook.memoizedState;
            return id;
        }
        function dispatchReducerAction(fiber, queue, action) {
            {
                if (typeof arguments[3] === 'function') {
                    error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
                }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
                lane: lane,
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
                enqueueRenderPhaseUpdate(queue, update);
            }
            else {
                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                if (root !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                    entangleTransitionUpdate(root, queue, lane);
                }
            }
            markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue, action) {
            {
                if (typeof arguments[3] === 'function') {
                    error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
                }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
                lane: lane,
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
                enqueueRenderPhaseUpdate(queue, update);
            }
            else {
                var alternate = fiber.alternate;
                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                    var lastRenderedReducer = queue.lastRenderedReducer;
                    if (lastRenderedReducer !== null) {
                        var prevDispatcher;
                        {
                            prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        }
                        try {
                            var currentState = queue.lastRenderedState;
                            var eagerState = lastRenderedReducer(currentState, action);
                            update.hasEagerState = true;
                            update.eagerState = eagerState;
                            if (objectIs(eagerState, currentState)) {
                                enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                                return;
                            }
                        }
                        catch (error) {
                        }
                        finally {
                            {
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        }
                    }
                }
                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                if (root !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                    entangleTransitionUpdate(root, queue, lane);
                }
            }
            markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
                update.next = update;
            }
            else {
                update.next = pending.next;
                pending.next = update;
            }
            queue.pending = update;
        }
        function entangleTransitionUpdate(root, queue, lane) {
            if (isTransitionLane(lane)) {
                var queueLanes = queue.lanes;
                queueLanes = intersectLanes(queueLanes, root.pendingLanes);
                var newQueueLanes = mergeLanes(queueLanes, lane);
                queue.lanes = newQueueLanes;
                markRootEntangled(root, newQueueLanes);
            }
        }
        function markUpdateInDevTools(fiber, lane, action) {
            {
                markStateUpdateScheduled(fiber, lane);
            }
        }
        var ContextOnlyDispatcher = {
            readContext: readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
            var warnInvalidContextAccess = function () {
                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
            };
            var warnInvalidHookAccess = function () {
                error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
            };
            HooksDispatcherOnMountInDEV = {
                readContext: function (context) {
                    return readContext(context);
                },
                useCallback: function (callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountCallback(callback, deps);
                },
                useContext: function (context) {
                    currentHookNameInDev = 'useContext';
                    mountHookTypesDev();
                    return readContext(context);
                },
                useEffect: function (create, deps) {
                    currentHookNameInDev = 'useEffect';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountEffect(create, deps);
                },
                useImperativeHandle: function (ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function (create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountInsertionEffect(create, deps);
                },
                useLayoutEffect: function (create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountLayoutEffect(create, deps);
                },
                useMemo: function (create, deps) {
                    currentHookNameInDev = 'useMemo';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountMemo(create, deps);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function (reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountReducer(reducer, initialArg, init);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function (initialValue) {
                    currentHookNameInDev = 'useRef';
                    mountHookTypesDev();
                    return mountRef(initialValue);
                },
                useState: function (initialState) {
                    currentHookNameInDev = 'useState';
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountState(initialState);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function (value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    mountHookTypesDev();
                    return mountDebugValue();
                },
                useDeferredValue: function (value) {
                    currentHookNameInDev = 'useDeferredValue';
                    mountHookTypesDev();
                    return mountDeferredValue(value);
                },
                useTransition: function () {
                    currentHookNameInDev = 'useTransition';
                    mountHookTypesDev();
                    return mountTransition();
                },
                useMutableSource: function (source, getSnapshot, subscribe) {
                    currentHookNameInDev = 'useMutableSource';
                    mountHookTypesDev();
                    return mountMutableSource();
                },
                useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    mountHookTypesDev();
                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function () {
                    currentHookNameInDev = 'useId';
                    mountHookTypesDev();
                    return mountId();
                },
                unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
                readContext: function (context) {
                    return readContext(context);
                },
                useCallback: function (callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    updateHookTypesDev();
                    return mountCallback(callback, deps);
                },
                useContext: function (context) {
                    currentHookNameInDev = 'useContext';
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function (create, deps) {
                    currentHookNameInDev = 'useEffect';
                    updateHookTypesDev();
                    return mountEffect(create, deps);
                },
                useImperativeHandle: function (ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    updateHookTypesDev();
                    return mountImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function (create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    updateHookTypesDev();
                    return mountInsertionEffect(create, deps);
                },
                useLayoutEffect: function (create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    updateHookTypesDev();
                    return mountLayoutEffect(create, deps);
                },
                useMemo: function (create, deps) {
                    currentHookNameInDev = 'useMemo';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountMemo(create, deps);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function (reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountReducer(reducer, initialArg, init);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function (initialValue) {
                    currentHookNameInDev = 'useRef';
                    updateHookTypesDev();
                    return mountRef(initialValue);
                },
                useState: function (initialState) {
                    currentHookNameInDev = 'useState';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountState(initialState);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function (value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    updateHookTypesDev();
                    return mountDebugValue();
                },
                useDeferredValue: function (value) {
                    currentHookNameInDev = 'useDeferredValue';
                    updateHookTypesDev();
                    return mountDeferredValue(value);
                },
                useTransition: function () {
                    currentHookNameInDev = 'useTransition';
                    updateHookTypesDev();
                    return mountTransition();
                },
                useMutableSource: function (source, getSnapshot, subscribe) {
                    currentHookNameInDev = 'useMutableSource';
                    updateHookTypesDev();
                    return mountMutableSource();
                },
                useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    updateHookTypesDev();
                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function () {
                    currentHookNameInDev = 'useId';
                    updateHookTypesDev();
                    return mountId();
                },
                unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
                readContext: function (context) {
                    return readContext(context);
                },
                useCallback: function (callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function (context) {
                    currentHookNameInDev = 'useContext';
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function (create, deps) {
                    currentHookNameInDev = 'useEffect';
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function (ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function (create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function (create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function (create, deps) {
                    currentHookNameInDev = 'useMemo';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateMemo(create, deps);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function (reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateReducer(reducer, initialArg, init);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function (initialValue) {
                    currentHookNameInDev = 'useRef';
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function (initialState) {
                    currentHookNameInDev = 'useState';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateState(initialState);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function (value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function (value) {
                    currentHookNameInDev = 'useDeferredValue';
                    updateHookTypesDev();
                    return updateDeferredValue(value);
                },
                useTransition: function () {
                    currentHookNameInDev = 'useTransition';
                    updateHookTypesDev();
                    return updateTransition();
                },
                useMutableSource: function (source, getSnapshot, subscribe) {
                    currentHookNameInDev = 'useMutableSource';
                    updateHookTypesDev();
                    return updateMutableSource();
                },
                useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot);
                },
                useId: function () {
                    currentHookNameInDev = 'useId';
                    updateHookTypesDev();
                    return updateId();
                },
                unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
                readContext: function (context) {
                    return readContext(context);
                },
                useCallback: function (callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function (context) {
                    currentHookNameInDev = 'useContext';
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function (create, deps) {
                    currentHookNameInDev = 'useEffect';
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function (ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function (create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function (create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function (create, deps) {
                    currentHookNameInDev = 'useMemo';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                    try {
                        return updateMemo(create, deps);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function (reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                    try {
                        return rerenderReducer(reducer, initialArg, init);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function (initialValue) {
                    currentHookNameInDev = 'useRef';
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function (initialState) {
                    currentHookNameInDev = 'useState';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                    try {
                        return rerenderState(initialState);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function (value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function (value) {
                    currentHookNameInDev = 'useDeferredValue';
                    updateHookTypesDev();
                    return rerenderDeferredValue(value);
                },
                useTransition: function () {
                    currentHookNameInDev = 'useTransition';
                    updateHookTypesDev();
                    return rerenderTransition();
                },
                useMutableSource: function (source, getSnapshot, subscribe) {
                    currentHookNameInDev = 'useMutableSource';
                    updateHookTypesDev();
                    return updateMutableSource();
                },
                useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot);
                },
                useId: function () {
                    currentHookNameInDev = 'useId';
                    updateHookTypesDev();
                    return updateId();
                },
                unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
                readContext: function (context) {
                    warnInvalidContextAccess();
                    return readContext(context);
                },
                useCallback: function (callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountCallback(callback, deps);
                },
                useContext: function (context) {
                    currentHookNameInDev = 'useContext';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return readContext(context);
                },
                useEffect: function (create, deps) {
                    currentHookNameInDev = 'useEffect';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountEffect(create, deps);
                },
                useImperativeHandle: function (ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function (create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountInsertionEffect(create, deps);
                },
                useLayoutEffect: function (create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountLayoutEffect(create, deps);
                },
                useMemo: function (create, deps) {
                    currentHookNameInDev = 'useMemo';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountMemo(create, deps);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function (reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountReducer(reducer, initialArg, init);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function (initialValue) {
                    currentHookNameInDev = 'useRef';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountRef(initialValue);
                },
                useState: function (initialState) {
                    currentHookNameInDev = 'useState';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountState(initialState);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function (value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountDebugValue();
                },
                useDeferredValue: function (value) {
                    currentHookNameInDev = 'useDeferredValue';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountDeferredValue(value);
                },
                useTransition: function () {
                    currentHookNameInDev = 'useTransition';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountTransition();
                },
                useMutableSource: function (source, getSnapshot, subscribe) {
                    currentHookNameInDev = 'useMutableSource';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountMutableSource();
                },
                useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function () {
                    currentHookNameInDev = 'useId';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountId();
                },
                unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
                readContext: function (context) {
                    warnInvalidContextAccess();
                    return readContext(context);
                },
                useCallback: function (callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function (context) {
                    currentHookNameInDev = 'useContext';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function (create, deps) {
                    currentHookNameInDev = 'useEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function (ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function (create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function (create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function (create, deps) {
                    currentHookNameInDev = 'useMemo';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateMemo(create, deps);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function (reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateReducer(reducer, initialArg, init);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function (initialValue) {
                    currentHookNameInDev = 'useRef';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function (initialState) {
                    currentHookNameInDev = 'useState';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateState(initialState);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function (value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function (value) {
                    currentHookNameInDev = 'useDeferredValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateDeferredValue(value);
                },
                useTransition: function () {
                    currentHookNameInDev = 'useTransition';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateTransition();
                },
                useMutableSource: function (source, getSnapshot, subscribe) {
                    currentHookNameInDev = 'useMutableSource';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateMutableSource();
                },
                useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot);
                },
                useId: function () {
                    currentHookNameInDev = 'useId';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateId();
                },
                unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
                readContext: function (context) {
                    warnInvalidContextAccess();
                    return readContext(context);
                },
                useCallback: function (callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function (context) {
                    currentHookNameInDev = 'useContext';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function (create, deps) {
                    currentHookNameInDev = 'useEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function (ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function (create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function (create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function (create, deps) {
                    currentHookNameInDev = 'useMemo';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateMemo(create, deps);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function (reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return rerenderReducer(reducer, initialArg, init);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function (initialValue) {
                    currentHookNameInDev = 'useRef';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function (initialState) {
                    currentHookNameInDev = 'useState';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return rerenderState(initialState);
                    }
                    finally {
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function (value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function (value) {
                    currentHookNameInDev = 'useDeferredValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return rerenderDeferredValue(value);
                },
                useTransition: function () {
                    currentHookNameInDev = 'useTransition';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return rerenderTransition();
                },
                useMutableSource: function (source, getSnapshot, subscribe) {
                    currentHookNameInDev = 'useMutableSource';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateMutableSource();
                },
                useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot);
                },
                useId: function () {
                    currentHookNameInDev = 'useId';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateId();
                },
                unstable_isNewReconciler: enableNewReconciler
            };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
            return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
            {
                nestedUpdateScheduled = true;
            }
        }
        function resetNestedUpdateFlag() {
            {
                currentUpdateIsNested = false;
                nestedUpdateScheduled = false;
            }
        }
        function syncNestedUpdateFlag() {
            {
                currentUpdateIsNested = nestedUpdateScheduled;
                nestedUpdateScheduled = false;
            }
        }
        function getCommitTime() {
            return commitTime;
        }
        function recordCommitTime() {
            commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
                fiber.actualStartTime = now$1();
            }
        }
        function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
                var elapsedTime = now$1() - profilerStartTime;
                fiber.actualDuration += elapsedTime;
                if (overrideBaseTime) {
                    fiber.selfBaseDuration = elapsedTime;
                }
                profilerStartTime = -1;
            }
        }
        function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
                var elapsedTime = now$1() - layoutEffectStartTime;
                layoutEffectStartTime = -1;
                var parentFiber = fiber.return;
                while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                        case HostRoot:
                            var root = parentFiber.stateNode;
                            root.effectDuration += elapsedTime;
                            return;
                        case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += elapsedTime;
                            return;
                    }
                    parentFiber = parentFiber.return;
                }
            }
        }
        function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
                var elapsedTime = now$1() - passiveEffectStartTime;
                passiveEffectStartTime = -1;
                var parentFiber = fiber.return;
                while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                        case HostRoot:
                            var root = parentFiber.stateNode;
                            if (root !== null) {
                                root.passiveEffectDuration += elapsedTime;
                            }
                            return;
                        case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            if (parentStateNode !== null) {
                                parentStateNode.passiveEffectDuration += elapsedTime;
                            }
                            return;
                    }
                    parentFiber = parentFiber.return;
                }
            }
        }
        function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
                fiber.actualDuration += child.actualDuration;
                child = child.sibling;
            }
        }
        function resolveDefaultProps(Component, baseProps) {
            if (Component && Component.defaultProps) {
                var props = assign({}, baseProps);
                var defaultProps = Component.defaultProps;
                for (var propName in defaultProps) {
                    if (props[propName] === undefined) {
                        props[propName] = defaultProps[propName];
                    }
                }
                return props;
            }
            return baseProps;
        }
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        var didWarnAboutLegacyContext$1;
        {
            didWarnAboutStateAssignmentForComponent = new Set();
            didWarnAboutUninitializedState = new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
            didWarnAboutDirectlyAssigningPropsToState = new Set();
            didWarnAboutUndefinedDerivedState = new Set();
            didWarnAboutContextTypeAndContextTypes = new Set();
            didWarnAboutInvalidateContextType = new Set();
            didWarnAboutLegacyContext$1 = new Set();
            var didWarnOnInvalidCallback = new Set();
            warnOnInvalidCallback = function (callback, callerName) {
                if (callback === null || typeof callback === 'function') {
                    return;
                }
                var key = callerName + '_' + callback;
                if (!didWarnOnInvalidCallback.has(key)) {
                    didWarnOnInvalidCallback.add(key);
                    error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
                }
            };
            warnOnUndefinedDerivedState = function (type, partialState) {
                if (partialState === undefined) {
                    var componentName = getComponentNameFromType(type) || 'Component';
                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                        didWarnAboutUndefinedDerivedState.add(componentName);
                        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
                    }
                }
            };
            Object.defineProperty(fakeInternalInstance, '_processChildContext', {
                enumerable: false,
                value: function () {
                    throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');
                }
            });
            Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
                if (workInProgress.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                        partialState = getDerivedStateFromProps(nextProps, prevState);
                    }
                    finally {
                        setIsStrictModeForDevtools(false);
                    }
                }
                warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
            workInProgress.memoizedState = memoizedState;
            if (workInProgress.lanes === NoLanes) {
                var updateQueue = workInProgress.updateQueue;
                updateQueue.baseState = memoizedState;
            }
        }
        var classComponentUpdater = {
            isMounted: isMounted,
            enqueueSetState: function (inst, payload, callback) {
                var fiber = get(inst);
                var eventTime = requestEventTime();
                var lane = requestUpdateLane(fiber);
                var update = createUpdate(eventTime, lane);
                update.payload = payload;
                if (callback !== undefined && callback !== null) {
                    {
                        warnOnInvalidCallback(callback, 'setState');
                    }
                    update.callback = callback;
                }
                var root = enqueueUpdate(fiber, update, lane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                    entangleTransitions(root, fiber, lane);
                }
                {
                    markStateUpdateScheduled(fiber, lane);
                }
            },
            enqueueReplaceState: function (inst, payload, callback) {
                var fiber = get(inst);
                var eventTime = requestEventTime();
                var lane = requestUpdateLane(fiber);
                var update = createUpdate(eventTime, lane);
                update.tag = ReplaceState;
                update.payload = payload;
                if (callback !== undefined && callback !== null) {
                    {
                        warnOnInvalidCallback(callback, 'replaceState');
                    }
                    update.callback = callback;
                }
                var root = enqueueUpdate(fiber, update, lane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                    entangleTransitions(root, fiber, lane);
                }
                {
                    markStateUpdateScheduled(fiber, lane);
                }
            },
            enqueueForceUpdate: function (inst, callback) {
                var fiber = get(inst);
                var eventTime = requestEventTime();
                var lane = requestUpdateLane(fiber);
                var update = createUpdate(eventTime, lane);
                update.tag = ForceUpdate;
                if (callback !== undefined && callback !== null) {
                    {
                        warnOnInvalidCallback(callback, 'forceUpdate');
                    }
                    update.callback = callback;
                }
                var root = enqueueUpdate(fiber, update, lane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                    entangleTransitions(root, fiber, lane);
                }
                {
                    markForceUpdateScheduled(fiber, lane);
                }
            }
        };
        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress.stateNode;
            if (typeof instance.shouldComponentUpdate === 'function') {
                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                {
                    if (workInProgress.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                        }
                        finally {
                            setIsStrictModeForDevtools(false);
                        }
                    }
                    if (shouldUpdate === undefined) {
                        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');
                    }
                }
                return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
        }
        function checkClassInstance(workInProgress, ctor, newProps) {
            var instance = workInProgress.stateNode;
            {
                var name = getComponentNameFromType(ctor) || 'Component';
                var renderPresent = instance.render;
                if (!renderPresent) {
                    if (ctor.prototype && typeof ctor.prototype.render === 'function') {
                        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
                    }
                    else {
                        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
                    }
                }
                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                    error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
                }
                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
                }
                if (instance.propTypes) {
                    error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
                }
                if (instance.contextType) {
                    error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);
                }
                {
                    if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) &&
                        (workInProgress.mode & StrictLegacyMode) === NoMode) {
                        didWarnAboutLegacyContext$1.add(ctor);
                        error('%s uses the legacy childContextTypes API which is no longer ' + 'supported and will be removed in the next major release. Use ' + 'React.createContext() instead\n\n.' + 'Learn more about this warning here: https://reactjs.org/link/legacy-context', name);
                    }
                    if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) &&
                        (workInProgress.mode & StrictLegacyMode) === NoMode) {
                        didWarnAboutLegacyContext$1.add(ctor);
                        error('%s uses the legacy contextTypes API which is no longer supported ' + 'and will be removed in the next major release. Use ' + 'React.createContext() with static contextType instead.\n\n' + 'Learn more about this warning here: https://reactjs.org/link/legacy-context', name);
                    }
                    if (instance.contextTypes) {
                        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
                    }
                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                        didWarnAboutContextTypeAndContextTypes.add(ctor);
                        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
                    }
                }
                if (typeof instance.componentShouldUpdate === 'function') {
                    error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
                }
                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
                    error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');
                }
                if (typeof instance.componentDidUnmount === 'function') {
                    error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
                }
                if (typeof instance.componentDidReceiveProps === 'function') {
                    error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
                }
                if (typeof instance.componentWillRecieveProps === 'function') {
                    error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
                }
                if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
                    error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);
                }
                var hasMutatedProps = instance.props !== newProps;
                if (instance.props !== undefined && hasMutatedProps) {
                    error('%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
                }
                if (instance.defaultProps) {
                    error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
                }
                if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                    error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));
                }
                if (typeof instance.getDerivedStateFromProps === 'function') {
                    error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
                }
                if (typeof instance.getDerivedStateFromError === 'function') {
                    error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
                }
                if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
                    error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);
                }
                var _state = instance.state;
                if (_state && (typeof _state !== 'object' || isArray(_state))) {
                    error('%s.state: must be set to an object or null', name);
                }
                if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {
                    error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);
                }
            }
        }
        function adoptClassInstance(workInProgress, instance) {
            instance.updater = classComponentUpdater;
            workInProgress.stateNode = instance;
            set(instance, workInProgress);
            {
                instance._reactInternalInstance = fakeInternalInstance;
            }
        }
        function constructClassInstance(workInProgress, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
                if ('contextType' in ctor) {
                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                        didWarnAboutInvalidateContextType.add(ctor);
                        var addendum = '';
                        if (contextType === undefined) {
                            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
                        }
                        else if (typeof contextType !== 'object') {
                            addendum = ' However, it is set to a ' + typeof contextType + '.';
                        }
                        else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                            addendum = ' Did you accidentally pass the Context.Provider instead?';
                        }
                        else if (contextType._context !== undefined) {
                            addendum = ' Did you accidentally pass the Context.Consumer instead?';
                        }
                        else {
                            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
                        }
                        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);
                    }
                }
            }
            if (typeof contextType === 'object' && contextType !== null) {
                context = readContext(contextType);
            }
            else {
                unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                var contextTypes = ctor.contextTypes;
                isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
                context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
                if (workInProgress.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                        instance = new ctor(props, context);
                    }
                    finally {
                        setIsStrictModeForDevtools(false);
                    }
                }
            }
            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
            adoptClassInstance(workInProgress, instance);
            {
                if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
                    var componentName = getComponentNameFromType(ctor) || 'Component';
                    if (!didWarnAboutUninitializedState.has(componentName)) {
                        didWarnAboutUninitializedState.add(componentName);
                        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
                    }
                }
                if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
                    var foundWillMountName = null;
                    var foundWillReceivePropsName = null;
                    var foundWillUpdateName = null;
                    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                        foundWillMountName = 'componentWillMount';
                    }
                    else if (typeof instance.UNSAFE_componentWillMount === 'function') {
                        foundWillMountName = 'UNSAFE_componentWillMount';
                    }
                    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                        foundWillReceivePropsName = 'componentWillReceiveProps';
                    }
                    else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
                        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
                    }
                    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                        foundWillUpdateName = 'componentWillUpdate';
                    }
                    else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
                        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
                    }
                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                        var _componentName = getComponentNameFromType(ctor) || 'Component';
                        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                            error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
                        }
                    }
                }
            }
            if (isLegacyContextConsumer) {
                cacheContext(workInProgress, unmaskedContext, context);
            }
            return instance;
        }
        function callComponentWillMount(workInProgress, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === 'function') {
                instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === 'function') {
                instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
                {
                    error('%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');
                }
                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
        }
        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === 'function') {
                instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
                {
                    var componentName = getComponentNameFromFiber(workInProgress) || 'Component';
                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                        didWarnAboutStateAssignmentForComponent.add(componentName);
                        error('%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
                    }
                }
                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
        }
        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
            {
                checkClassInstance(workInProgress, ctor, newProps);
            }
            var instance = workInProgress.stateNode;
            instance.props = newProps;
            instance.state = workInProgress.memoizedState;
            instance.refs = {};
            initializeUpdateQueue(workInProgress);
            var contextType = ctor.contextType;
            if (typeof contextType === 'object' && contextType !== null) {
                instance.context = readContext(contextType);
            }
            else {
                var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                instance.context = getMaskedContext(workInProgress, unmaskedContext);
            }
            {
                if (instance.state === newProps) {
                    var componentName = getComponentNameFromType(ctor) || 'Component';
                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                        error('%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
                    }
                }
                if (workInProgress.mode & StrictLegacyMode) {
                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
                }
                {
                    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
                }
            }
            instance.state = workInProgress.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === 'function') {
                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
                instance.state = workInProgress.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
                callComponentWillMount(workInProgress, instance);
                processUpdateQueue(workInProgress, newProps, instance, renderLanes);
                instance.state = workInProgress.memoizedState;
            }
            if (typeof instance.componentDidMount === 'function') {
                var fiberFlags = Update;
                {
                    fiberFlags |= LayoutStatic;
                }
                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                    fiberFlags |= MountLayoutDev;
                }
                workInProgress.flags |= fiberFlags;
            }
        }
        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
            var instance = workInProgress.stateNode;
            var oldProps = workInProgress.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === 'object' && contextType !== null) {
                nextContext = readContext(contextType);
            }
            else {
                var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
                if (oldProps !== newProps || oldContext !== nextContext) {
                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
                }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress, newProps, instance, renderLanes);
            newState = workInProgress.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
                if (typeof instance.componentDidMount === 'function') {
                    var fiberFlags = Update;
                    {
                        fiberFlags |= LayoutStatic;
                    }
                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                        fiberFlags |= MountLayoutDev;
                    }
                    workInProgress.flags |= fiberFlags;
                }
                return false;
            }
            if (typeof getDerivedStateFromProps === 'function') {
                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
                newState = workInProgress.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
                    if (typeof instance.componentWillMount === 'function') {
                        instance.componentWillMount();
                    }
                    if (typeof instance.UNSAFE_componentWillMount === 'function') {
                        instance.UNSAFE_componentWillMount();
                    }
                }
                if (typeof instance.componentDidMount === 'function') {
                    var _fiberFlags = Update;
                    {
                        _fiberFlags |= LayoutStatic;
                    }
                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                        _fiberFlags |= MountLayoutDev;
                    }
                    workInProgress.flags |= _fiberFlags;
                }
            }
            else {
                if (typeof instance.componentDidMount === 'function') {
                    var _fiberFlags2 = Update;
                    {
                        _fiberFlags2 |= LayoutStatic;
                    }
                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                        _fiberFlags2 |= MountLayoutDev;
                    }
                    workInProgress.flags |= _fiberFlags2;
                }
                workInProgress.memoizedProps = newProps;
                workInProgress.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
        }
        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {
            var instance = workInProgress.stateNode;
            cloneUpdateQueue(current, workInProgress);
            var unresolvedOldProps = workInProgress.memoizedProps;
            var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === 'object' && contextType !== null) {
                nextContext = readContext(contextType);
            }
            else {
                var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
                }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress, newProps, instance, renderLanes);
            newState = workInProgress.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(enableLazyContextPropagation)) {
                if (typeof instance.componentDidUpdate === 'function') {
                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                        workInProgress.flags |= Update;
                    }
                }
                if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                        workInProgress.flags |= Snapshot;
                    }
                }
                return false;
            }
            if (typeof getDerivedStateFromProps === 'function') {
                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
                newState = workInProgress.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) ||
                enableLazyContextPropagation;
            if (shouldUpdate) {
                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
                    if (typeof instance.componentWillUpdate === 'function') {
                        instance.componentWillUpdate(newProps, newState, nextContext);
                    }
                    if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                    }
                }
                if (typeof instance.componentDidUpdate === 'function') {
                    workInProgress.flags |= Update;
                }
                if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                    workInProgress.flags |= Snapshot;
                }
            }
            else {
                if (typeof instance.componentDidUpdate === 'function') {
                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                        workInProgress.flags |= Update;
                    }
                }
                if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                        workInProgress.flags |= Snapshot;
                    }
                }
                workInProgress.memoizedProps = newProps;
                workInProgress.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
        }
        function createCapturedValueAtFiber(value, source) {
            return {
                value: value,
                source: source,
                stack: getStackByFiberInDevAndProd(source),
                digest: null
            };
        }
        function createCapturedValue(value, digest, stack) {
            return {
                value: value,
                source: null,
                stack: stack != null ? stack : null,
                digest: digest != null ? digest : null
            };
        }
        function showErrorDialog(boundary, errorInfo) {
            return true;
        }
        function logCapturedError(boundary, errorInfo) {
            try {
                var logError = showErrorDialog(boundary, errorInfo);
                if (logError === false) {
                    return;
                }
                var error = errorInfo.value;
                if (true) {
                    var source = errorInfo.source;
                    var stack = errorInfo.stack;
                    var componentStack = stack !== null ? stack : '';
                    if (error != null && error._suppressLogging) {
                        if (boundary.tag === ClassComponent) {
                            return;
                        }
                        console['error'](error);
                    }
                    var componentName = source ? getComponentNameFromFiber(source) : null;
                    var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
                    var errorBoundaryMessage;
                    if (boundary.tag === HostRoot) {
                        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';
                    }
                    else {
                        var errorBoundaryName = getComponentNameFromFiber(boundary) || 'Anonymous';
                        errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                    }
                    var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                    console['error'](combinedMessage);
                }
                else // removed by dead control flow
{}
            }
            catch (e) {
                setTimeout(function () {
                    throw e;
                });
            }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
                element: null
            };
            var error = errorInfo.value;
            update.callback = function () {
                onUncaughtError(error);
                logCapturedError(fiber, errorInfo);
            };
            return update;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === 'function') {
                var error$1 = errorInfo.value;
                update.payload = function () {
                    return getDerivedStateFromError(error$1);
                };
                update.callback = function () {
                    {
                        markFailedErrorBoundaryForHotReloading(fiber);
                    }
                    logCapturedError(fiber, errorInfo);
                };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === 'function') {
                update.callback = function callback() {
                    {
                        markFailedErrorBoundaryForHotReloading(fiber);
                    }
                    logCapturedError(fiber, errorInfo);
                    if (typeof getDerivedStateFromError !== 'function') {
                        markLegacyErrorBoundaryAsFailed(this);
                    }
                    var error$1 = errorInfo.value;
                    var stack = errorInfo.stack;
                    this.componentDidCatch(error$1, {
                        componentStack: stack !== null ? stack : ''
                    });
                    {
                        if (typeof getDerivedStateFromError !== 'function') {
                            if (!includesSomeLane(fiber.lanes, SyncLane)) {
                                error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');
                            }
                        }
                    }
                };
            }
            return update;
        }
        function attachPingListener(root, wakeable, lanes) {
            var pingCache = root.pingCache;
            var threadIDs;
            if (pingCache === null) {
                pingCache = root.pingCache = new PossiblyWeakMap$1();
                threadIDs = new Set();
                pingCache.set(wakeable, threadIDs);
            }
            else {
                threadIDs = pingCache.get(wakeable);
                if (threadIDs === undefined) {
                    threadIDs = new Set();
                    pingCache.set(wakeable, threadIDs);
                }
            }
            if (!threadIDs.has(lanes)) {
                threadIDs.add(lanes);
                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
                {
                    if (isDevToolsPresent) {
                        restorePendingUpdaters(root, lanes);
                    }
                }
                wakeable.then(ping, ping);
            }
        }
        function attachRetryListener(suspenseBoundary, root, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
                var updateQueue = new Set();
                updateQueue.add(wakeable);
                suspenseBoundary.updateQueue = updateQueue;
            }
            else {
                wakeables.add(wakeable);
            }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
                var currentSource = sourceFiber.alternate;
                if (currentSource) {
                    sourceFiber.updateQueue = currentSource.updateQueue;
                    sourceFiber.memoizedState = currentSource.memoizedState;
                    sourceFiber.lanes = currentSource.lanes;
                }
                else {
                    sourceFiber.updateQueue = null;
                    sourceFiber.memoizedState = null;
                }
            }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
                if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                    return node;
                }
                node = node.return;
            } while (node !== null);
            return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
                if (suspenseBoundary === returnFiber) {
                    suspenseBoundary.flags |= ShouldCapture;
                }
                else {
                    suspenseBoundary.flags |= DidCapture;
                    sourceFiber.flags |= ForceUpdateForLegacySuspense;
                    sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                    if (sourceFiber.tag === ClassComponent) {
                        var currentSourceFiber = sourceFiber.alternate;
                        if (currentSourceFiber === null) {
                            sourceFiber.tag = IncompleteClassComponent;
                        }
                        else {
                            var update = createUpdate(NoTimestamp, SyncLane);
                            update.tag = ForceUpdate;
                            enqueueUpdate(sourceFiber, update, SyncLane);
                        }
                    }
                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                }
                return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
        }
        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
                if (isDevToolsPresent) {
                    restorePendingUpdaters(root, rootRenderLanes);
                }
            }
            if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
                var wakeable = value;
                resetSuspendedComponent(sourceFiber);
                {
                    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                        markDidThrowWhileHydratingDEV();
                    }
                }
                var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (suspenseBoundary !== null) {
                    suspenseBoundary.flags &= ~ForceClientRender;
                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes);
                    if (suspenseBoundary.mode & ConcurrentMode) {
                        attachPingListener(root, wakeable, rootRenderLanes);
                    }
                    attachRetryListener(suspenseBoundary, root, wakeable);
                    return;
                }
                else {
                    if (!includesSyncLane(rootRenderLanes)) {
                        attachPingListener(root, wakeable, rootRenderLanes);
                        renderDidSuspendDelayIfPossible();
                        return;
                    }
                    var uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.');
                    value = uncaughtSuspenseError;
                }
            }
            else {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                    markDidThrowWhileHydratingDEV();
                    var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                    if (_suspenseBoundary !== null) {
                        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                            _suspenseBoundary.flags |= ForceClientRender;
                        }
                        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes);
                        queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                        return;
                    }
                }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress = returnFiber;
            do {
                switch (workInProgress.tag) {
                    case HostRoot:
                        {
                            var _errorInfo = value;
                            workInProgress.flags |= ShouldCapture;
                            var lane = pickArbitraryLane(rootRenderLanes);
                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);
                            var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);
                            enqueueCapturedUpdate(workInProgress, update);
                            return;
                        }
                    case ClassComponent:
                        var errorInfo = value;
                        var ctor = workInProgress.type;
                        var instance = workInProgress.stateNode;
                        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                            workInProgress.flags |= ShouldCapture;
                            var _lane = pickArbitraryLane(rootRenderLanes);
                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane);
                            var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);
                            enqueueCapturedUpdate(workInProgress, _update);
                            return;
                        }
                        break;
                }
                workInProgress = workInProgress.return;
            } while (workInProgress !== null);
        }
        function getSuspendedCache() {
            {
                return null;
            }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        var didWarnAboutDefaultPropsOnFunctionComponent;
        {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
            didWarnAboutDefaultPropsOnFunctionComponent = {};
        }
        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
            if (current === null) {
                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
            }
            else {
                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
            }
        }
        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {
            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes);
            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
        }
        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
            {
                if (workInProgress.type !== workInProgress.elementType) {
                    var innerPropTypes = Component.propTypes;
                    if (innerPropTypes) {
                        checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(Component));
                    }
                }
            }
            var render = Component.render;
            var ref = workInProgress.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress, renderLanes);
            {
                markComponentRenderStarted(workInProgress);
            }
            {
                ReactCurrentOwner$1.current = workInProgress;
                setIsRendering(true);
                nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
                hasId = checkDidRenderIdHook();
                if (workInProgress.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
                        hasId = checkDidRenderIdHook();
                    }
                    finally {
                        setIsStrictModeForDevtools(false);
                    }
                }
                setIsRendering(false);
            }
            {
                markComponentRenderStopped();
            }
            if (current !== null && !didReceiveUpdate) {
                bailoutHooks(current, workInProgress, renderLanes);
                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            }
            if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress);
            }
            workInProgress.flags |= PerformedWork;
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
            if (current === null) {
                var type = Component.type;
                if (isSimpleFunctionComponent(type) && Component.compare === null &&
                    Component.defaultProps === undefined) {
                    var resolvedType = type;
                    {
                        resolvedType = resolveFunctionForHotReloading(type);
                    }
                    workInProgress.tag = SimpleMemoComponent;
                    workInProgress.type = resolvedType;
                    {
                        validateFunctionComponentInDev(workInProgress, type);
                    }
                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);
                }
                {
                    var innerPropTypes = type.propTypes;
                    if (innerPropTypes) {
                        checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(type));
                    }
                    if (Component.defaultProps !== undefined) {
                        var componentName = getComponentNameFromType(type) || 'Unknown';
                        if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                            error('%s: Support for defaultProps will be removed from memo components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);
                            didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                        }
                    }
                }
                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
                child.ref = workInProgress.ref;
                child.return = workInProgress;
                workInProgress.child = child;
                return child;
            }
            {
                var _type = Component.type;
                var _innerPropTypes = _type.propTypes;
                if (_innerPropTypes) {
                    checkPropTypes(_innerPropTypes, nextProps, 'prop', getComponentNameFromType(_type));
                }
            }
            var currentChild = current.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);
            if (!hasScheduledUpdateOrContext) {
                var prevProps = currentChild.memoizedProps;
                var compare = Component.compare;
                compare = compare !== null ? compare : shallowEqual;
                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                }
            }
            workInProgress.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress.ref;
            newChild.return = workInProgress;
            workInProgress.child = newChild;
            return newChild;
        }
        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
            {
                if (workInProgress.type !== workInProgress.elementType) {
                    var outerMemoType = workInProgress.elementType;
                    if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                        var lazyComponent = outerMemoType;
                        var payload = lazyComponent._payload;
                        var init = lazyComponent._init;
                        try {
                            outerMemoType = init(payload);
                        }
                        catch (x) {
                            outerMemoType = null;
                        }
                        var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                        if (outerPropTypes) {
                            checkPropTypes(outerPropTypes, nextProps, 'prop', getComponentNameFromType(outerMemoType));
                        }
                    }
                }
            }
            if (current !== null) {
                var prevProps = current.memoizedProps;
                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && (workInProgress.type === current.type)) {
                    didReceiveUpdate = false;
                    workInProgress.pendingProps = nextProps = prevProps;
                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {
                        workInProgress.lanes = current.lanes;
                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                    }
                    else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                        didReceiveUpdate = true;
                    }
                }
            }
            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
        }
        function updateOffscreenComponent(current, workInProgress, renderLanes) {
            var nextProps = workInProgress.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current !== null ? current.memoizedState : null;
            if (nextProps.mode === 'hidden' || enableLegacyHidden) {
                if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                    var nextState = {
                        baseLanes: NoLanes,
                        cachePool: null,
                        transitions: null
                    };
                    workInProgress.memoizedState = nextState;
                    pushRenderLanes(workInProgress, renderLanes);
                }
                else if (!includesSomeLane(renderLanes, OffscreenLane)) {
                    var spawnedCachePool = null;
                    var nextBaseLanes;
                    if (prevState !== null) {
                        var prevBaseLanes = prevState.baseLanes;
                        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
                    }
                    else {
                        nextBaseLanes = renderLanes;
                    }
                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
                    var _nextState = {
                        baseLanes: nextBaseLanes,
                        cachePool: spawnedCachePool,
                        transitions: null
                    };
                    workInProgress.memoizedState = _nextState;
                    workInProgress.updateQueue = null;
                    pushRenderLanes(workInProgress, nextBaseLanes);
                    return null;
                }
                else {
                    var _nextState2 = {
                        baseLanes: NoLanes,
                        cachePool: null,
                        transitions: null
                    };
                    workInProgress.memoizedState = _nextState2;
                    var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;
                    pushRenderLanes(workInProgress, subtreeRenderLanes);
                }
            }
            else {
                var _subtreeRenderLanes;
                if (prevState !== null) {
                    _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);
                    workInProgress.memoizedState = null;
                }
                else {
                    _subtreeRenderLanes = renderLanes;
                }
                pushRenderLanes(workInProgress, _subtreeRenderLanes);
            }
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function updateFragment(current, workInProgress, renderLanes) {
            var nextChildren = workInProgress.pendingProps;
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function updateMode(current, workInProgress, renderLanes) {
            var nextChildren = workInProgress.pendingProps.children;
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function updateProfiler(current, workInProgress, renderLanes) {
            {
                workInProgress.flags |= Update;
                {
                    var stateNode = workInProgress.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                }
            }
            var nextProps = workInProgress.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function markRef(current, workInProgress) {
            var ref = workInProgress.ref;
            if (current === null && ref !== null || current !== null && current.ref !== ref) {
                workInProgress.flags |= Ref;
                {
                    workInProgress.flags |= RefStatic;
                }
            }
        }
        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
            {
                if (workInProgress.type !== workInProgress.elementType) {
                    var innerPropTypes = Component.propTypes;
                    if (innerPropTypes) {
                        checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(Component));
                    }
                }
            }
            var context;
            {
                var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
                context = getMaskedContext(workInProgress, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress, renderLanes);
            {
                markComponentRenderStarted(workInProgress);
            }
            {
                ReactCurrentOwner$1.current = workInProgress;
                setIsRendering(true);
                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
                hasId = checkDidRenderIdHook();
                if (workInProgress.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
                        hasId = checkDidRenderIdHook();
                    }
                    finally {
                        setIsStrictModeForDevtools(false);
                    }
                }
                setIsRendering(false);
            }
            {
                markComponentRenderStopped();
            }
            if (current !== null && !didReceiveUpdate) {
                bailoutHooks(current, workInProgress, renderLanes);
                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            }
            if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress);
            }
            workInProgress.flags |= PerformedWork;
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
            {
                switch (shouldError(workInProgress)) {
                    case false:
                        {
                            var _instance = workInProgress.stateNode;
                            var ctor = workInProgress.type;
                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);
                            var state = tempInstance.state;
                            _instance.updater.enqueueSetState(_instance, state, null);
                            break;
                        }
                    case true:
                        {
                            workInProgress.flags |= DidCapture;
                            workInProgress.flags |= ShouldCapture;
                            var error$1 = new Error('Simulated error coming from DevTools');
                            var lane = pickArbitraryLane(renderLanes);
                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);
                            var update = createClassErrorUpdate(workInProgress, createCapturedValueAtFiber(error$1, workInProgress), lane);
                            enqueueCapturedUpdate(workInProgress, update);
                            break;
                        }
                }
                if (workInProgress.type !== workInProgress.elementType) {
                    var innerPropTypes = Component.propTypes;
                    if (innerPropTypes) {
                        checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(Component));
                    }
                }
            }
            var hasContext;
            if (isContextProvider(Component)) {
                hasContext = true;
                pushContextProvider(workInProgress);
            }
            else {
                hasContext = false;
            }
            prepareToReadContext(workInProgress, renderLanes);
            var instance = workInProgress.stateNode;
            var shouldUpdate;
            if (instance === null) {
                resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
                constructClassInstance(workInProgress, Component, nextProps);
                mountClassInstance(workInProgress, Component, nextProps, renderLanes);
                shouldUpdate = true;
            }
            else if (current === null) {
                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
            }
            else {
                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
            }
            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);
            {
                var inst = workInProgress.stateNode;
                if (shouldUpdate && inst.props !== nextProps) {
                    if (!didWarnAboutReassigningProps) {
                        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');
                    }
                    didWarnAboutReassigningProps = true;
                }
            }
            return nextUnitOfWork;
        }
        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
            markRef(current, workInProgress);
            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
                if (hasContext) {
                    invalidateContextProvider(workInProgress, Component, false);
                }
                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            }
            var instance = workInProgress.stateNode;
            ReactCurrentOwner$1.current = workInProgress;
            var nextChildren;
            if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
                nextChildren = null;
                {
                    stopProfilerTimerIfRunning();
                }
            }
            else {
                {
                    markComponentRenderStarted(workInProgress);
                }
                {
                    setIsRendering(true);
                    nextChildren = instance.render();
                    if (workInProgress.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                            instance.render();
                        }
                        finally {
                            setIsStrictModeForDevtools(false);
                        }
                    }
                    setIsRendering(false);
                }
                {
                    markComponentRenderStopped();
                }
            }
            workInProgress.flags |= PerformedWork;
            if (current !== null && didCaptureError) {
                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);
            }
            else {
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            }
            workInProgress.memoizedState = instance.state;
            if (hasContext) {
                invalidateContextProvider(workInProgress, Component, true);
            }
            return workInProgress.child;
        }
        function pushHostRootContext(workInProgress) {
            var root = workInProgress.stateNode;
            if (root.pendingContext) {
                pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
            }
            else if (root.context) {
                pushTopLevelContextObject(workInProgress, root.context, false);
            }
            pushHostContainer(workInProgress, root.containerInfo);
        }
        function updateHostRoot(current, workInProgress, renderLanes) {
            pushHostRootContext(workInProgress);
            if (current === null) {
                throw new Error('Should have a current fiber. This is a bug in React.');
            }
            var nextProps = workInProgress.pendingProps;
            var prevState = workInProgress.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current, workInProgress);
            processUpdateQueue(workInProgress, nextProps, null, renderLanes);
            var nextState = workInProgress.memoizedState;
            var root = workInProgress.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
                var overrideState = {
                    element: nextChildren,
                    isDehydrated: false,
                    cache: nextState.cache,
                    pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                    transitions: nextState.transitions
                };
                var updateQueue = workInProgress.updateQueue;
                updateQueue.baseState = overrideState;
                workInProgress.memoizedState = overrideState;
                if (workInProgress.flags & ForceClientRender) {
                    var recoverableError = createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.'), workInProgress);
                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);
                }
                else if (nextChildren !== prevChildren) {
                    var _recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);
                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);
                }
                else {
                    enterHydrationState(workInProgress);
                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
                    workInProgress.child = child;
                    var node = child;
                    while (node) {
                        node.flags = node.flags & ~Placement | Hydrating;
                        node = node.sibling;
                    }
                }
            }
            else {
                resetHydrationState();
                if (nextChildren === prevChildren) {
                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                }
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            }
            return workInProgress.child;
        }
        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress.flags |= ForceClientRender;
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function updateHostComponent(current, workInProgress, renderLanes) {
            pushHostContext(workInProgress);
            if (current === null) {
                tryToClaimNextHydratableInstance(workInProgress);
            }
            var type = workInProgress.type;
            var nextProps = workInProgress.pendingProps;
            var prevProps = current !== null ? current.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
                nextChildren = null;
            }
            else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
                workInProgress.flags |= ContentReset;
            }
            markRef(current, workInProgress);
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function updateHostText(current, workInProgress) {
            if (current === null) {
                tryToClaimNextHydratableInstance(workInProgress);
            }
            return null;
        }
        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);
            var props = workInProgress.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component = init(payload);
            workInProgress.type = Component;
            var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
            var resolvedProps = resolveDefaultProps(Component, props);
            var child;
            switch (resolvedTag) {
                case FunctionComponent:
                    {
                        {
                            validateFunctionComponentInDev(workInProgress, Component);
                            workInProgress.type = Component = resolveFunctionForHotReloading(Component);
                        }
                        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);
                        return child;
                    }
                case ClassComponent:
                    {
                        {
                            workInProgress.type = Component = resolveClassForHotReloading(Component);
                        }
                        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);
                        return child;
                    }
                case ForwardRef:
                    {
                        {
                            workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
                        }
                        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);
                        return child;
                    }
                case MemoComponent:
                    {
                        {
                            if (workInProgress.type !== workInProgress.elementType) {
                                var outerPropTypes = Component.propTypes;
                                if (outerPropTypes) {
                                    checkPropTypes(outerPropTypes, resolvedProps, 'prop', getComponentNameFromType(Component));
                                }
                            }
                        }
                        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes);
                        return child;
                    }
            }
            var hint = '';
            {
                if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {
                    hint = ' Did you wrap a component in React.lazy() more than once?';
                }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);
            workInProgress.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component)) {
                hasContext = true;
                pushContextProvider(workInProgress);
            }
            else {
                hasContext = false;
            }
            prepareToReadContext(workInProgress, renderLanes);
            constructClassInstance(workInProgress, Component, nextProps);
            mountClassInstance(workInProgress, Component, nextProps, renderLanes);
            return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
        }
        function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);
            var props = workInProgress.pendingProps;
            var context;
            {
                var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
                context = getMaskedContext(workInProgress, unmaskedContext);
            }
            prepareToReadContext(workInProgress, renderLanes);
            var value;
            var hasId;
            {
                markComponentRenderStarted(workInProgress);
            }
            {
                if (Component.prototype && typeof Component.prototype.render === 'function') {
                    var componentName = getComponentNameFromType(Component) || 'Unknown';
                    if (!didWarnAboutBadClass[componentName]) {
                        error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
                        didWarnAboutBadClass[componentName] = true;
                    }
                }
                if (workInProgress.mode & StrictLegacyMode) {
                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
                }
                setIsRendering(true);
                ReactCurrentOwner$1.current = workInProgress;
                value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
                hasId = checkDidRenderIdHook();
                setIsRendering(false);
            }
            {
                markComponentRenderStopped();
            }
            workInProgress.flags |= PerformedWork;
            {
                if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
                    var _componentName = getComponentNameFromType(Component) || 'Unknown';
                    if (!didWarnAboutModulePatternComponent[_componentName]) {
                        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);
                        didWarnAboutModulePatternComponent[_componentName] = true;
                    }
                }
            }
            if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
                {
                    var _componentName2 = getComponentNameFromType(Component) || 'Unknown';
                    if (!didWarnAboutModulePatternComponent[_componentName2]) {
                        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);
                        didWarnAboutModulePatternComponent[_componentName2] = true;
                    }
                }
                workInProgress.tag = ClassComponent;
                workInProgress.memoizedState = null;
                workInProgress.updateQueue = null;
                var hasContext = false;
                if (isContextProvider(Component)) {
                    hasContext = true;
                    pushContextProvider(workInProgress);
                }
                else {
                    hasContext = false;
                }
                workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
                initializeUpdateQueue(workInProgress);
                adoptClassInstance(workInProgress, value);
                mountClassInstance(workInProgress, Component, props, renderLanes);
                return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
            }
            else {
                workInProgress.tag = FunctionComponent;
                {
                    if (workInProgress.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                            value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
                            hasId = checkDidRenderIdHook();
                        }
                        finally {
                            setIsStrictModeForDevtools(false);
                        }
                    }
                }
                if (getIsHydrating() && hasId) {
                    pushMaterializedTreeId(workInProgress);
                }
                reconcileChildren(null, workInProgress, value, renderLanes);
                {
                    validateFunctionComponentInDev(workInProgress, Component);
                }
                return workInProgress.child;
            }
        }
        function validateFunctionComponentInDev(workInProgress, Component) {
            {
                if (Component) {
                    if (Component.childContextTypes) {
                        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
                    }
                }
                if (workInProgress.ref !== null) {
                    var info = '';
                    var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                    if (ownerName) {
                        info += '\n\nCheck the render method of `' + ownerName + '`.';
                    }
                    var warningKey = ownerName || '';
                    var debugSource = workInProgress._debugSource;
                    if (debugSource) {
                        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
                    }
                    if (!didWarnAboutFunctionRefs[warningKey]) {
                        didWarnAboutFunctionRefs[warningKey] = true;
                        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
                    }
                }
                if (Component.defaultProps !== undefined) {
                    var componentName = getComponentNameFromType(Component) || 'Unknown';
                    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                        error('%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);
                        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                    }
                }
                if (typeof Component.getDerivedStateFromProps === 'function') {
                    var _componentName3 = getComponentNameFromType(Component) || 'Unknown';
                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);
                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                    }
                }
                if (typeof Component.contextType === 'object' && Component.contextType !== null) {
                    var _componentName4 = getComponentNameFromType(Component) || 'Unknown';
                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                        error('%s: Function components do not support contextType.', _componentName4);
                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                    }
                }
            }
        }
        var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes) {
            return {
                baseLanes: renderLanes,
                cachePool: getSuspendedCache(),
                transitions: null
            };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
            var cachePool = null;
            return {
                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),
                cachePool: cachePool,
                transitions: prevOffscreenState.transitions
            };
        }
        function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {
            if (current !== null) {
                var suspenseState = current.memoizedState;
                if (suspenseState === null) {
                    return false;
                }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current, renderLanes) {
            return removeLanes(current.childLanes, renderLanes);
        }
        function updateSuspenseComponent(current, workInProgress, renderLanes) {
            var nextProps = workInProgress.pendingProps;
            {
                if (shouldSuspend(workInProgress)) {
                    workInProgress.flags |= DidCapture;
                }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
                showFallback = true;
                workInProgress.flags &= ~DidCapture;
            }
            else {
                if (current === null || current.memoizedState !== null) {
                    {
                        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                    }
                }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress, suspenseContext);
            if (current === null) {
                tryToClaimNextHydratableInstance(workInProgress);
                var suspenseState = workInProgress.memoizedState;
                if (suspenseState !== null) {
                    var dehydrated = suspenseState.dehydrated;
                    if (dehydrated !== null) {
                        return mountDehydratedSuspenseComponent(workInProgress, dehydrated);
                    }
                }
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                if (showFallback) {
                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
                    var primaryChildFragment = workInProgress.child;
                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
                    workInProgress.memoizedState = SUSPENDED_MARKER;
                    return fallbackFragment;
                }
                else {
                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);
                }
            }
            else {
                var prevState = current.memoizedState;
                if (prevState !== null) {
                    var _dehydrated = prevState.dehydrated;
                    if (_dehydrated !== null) {
                        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, _dehydrated, prevState, renderLanes);
                    }
                }
                if (showFallback) {
                    var _nextFallbackChildren = nextProps.fallback;
                    var _nextPrimaryChildren = nextProps.children;
                    var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);
                    var _primaryChildFragment2 = workInProgress.child;
                    var prevOffscreenState = current.child.memoizedState;
                    _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
                    _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);
                    workInProgress.memoizedState = SUSPENDED_MARKER;
                    return fallbackChildFragment;
                }
                else {
                    var _nextPrimaryChildren2 = nextProps.children;
                    var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2, renderLanes);
                    workInProgress.memoizedState = null;
                    return _primaryChildFragment3;
                }
            }
        }
        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {
            var mode = workInProgress.mode;
            var primaryChildProps = {
                mode: 'visible',
                children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress;
            workInProgress.child = primaryChildFragment;
            return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
            var mode = workInProgress.mode;
            var progressedPrimaryFragment = workInProgress.child;
            var primaryChildProps = {
                mode: 'hidden',
                children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
                primaryChildFragment = progressedPrimaryFragment;
                primaryChildFragment.childLanes = NoLanes;
                primaryChildFragment.pendingProps = primaryChildProps;
                if (workInProgress.mode & ProfileMode) {
                    primaryChildFragment.actualDuration = 0;
                    primaryChildFragment.actualStartTime = -1;
                    primaryChildFragment.selfBaseDuration = 0;
                    primaryChildFragment.treeBaseDuration = 0;
                }
                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
            }
            else {
                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
            }
            primaryChildFragment.return = workInProgress;
            fallbackChildFragment.return = workInProgress;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress.child = primaryChildFragment;
            return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {
            return createWorkInProgress(current, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
            var currentPrimaryChildFragment = current.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
                mode: 'visible',
                children: primaryChildren
            });
            if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                primaryChildFragment.lanes = renderLanes;
            }
            primaryChildFragment.return = workInProgress;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
                var deletions = workInProgress.deletions;
                if (deletions === null) {
                    workInProgress.deletions = [currentFallbackChildFragment];
                    workInProgress.flags |= ChildDeletion;
                }
                else {
                    deletions.push(currentFallbackChildFragment);
                }
            }
            workInProgress.child = primaryChildFragment;
            return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
            var mode = workInProgress.mode;
            var currentPrimaryChildFragment = current.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
                mode: 'hidden',
                children: primaryChildren
            };
            var primaryChildFragment;
            if ((mode & ConcurrentMode) === NoMode &&
                workInProgress.child !== currentPrimaryChildFragment) {
                var progressedPrimaryFragment = workInProgress.child;
                primaryChildFragment = progressedPrimaryFragment;
                primaryChildFragment.childLanes = NoLanes;
                primaryChildFragment.pendingProps = primaryChildProps;
                if (workInProgress.mode & ProfileMode) {
                    primaryChildFragment.actualDuration = 0;
                    primaryChildFragment.actualStartTime = -1;
                    primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                    primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
                }
                workInProgress.deletions = null;
            }
            else {
                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            }
            else {
                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
                fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress;
            primaryChildFragment.return = workInProgress;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress.child = primaryChildFragment;
            return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {
            if (recoverableError !== null) {
                queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress, current.child, null, renderLanes);
            var nextProps = workInProgress.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress.memoizedState = null;
            return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
            var fiberMode = workInProgress.mode;
            var primaryChildProps = {
                mode: 'visible',
                children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress;
            fallbackChildFragment.return = workInProgress;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress.child = primaryChildFragment;
            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {
                reconcileChildFibers(workInProgress, current.child, null, renderLanes);
            }
            return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {
            if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                {
                    error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');
                }
                workInProgress.lanes = laneToLanes(SyncLane);
            }
            else if (isSuspenseInstanceFallback(suspenseInstance)) {
                workInProgress.lanes = laneToLanes(DefaultHydrationLane);
            }
            else {
                workInProgress.lanes = laneToLanes(OffscreenLane);
            }
            return null;
        }
        function updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes) {
            if (!didSuspend) {
                warnIfHydrating();
                if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, null);
                }
                if (isSuspenseInstanceFallback(suspenseInstance)) {
                    var digest, message, stack;
                    {
                        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                        digest = _getSuspenseInstanceF.digest;
                        message = _getSuspenseInstanceF.message;
                        stack = _getSuspenseInstanceF.stack;
                    }
                    var error;
                    if (message) {
                        error = new Error(message);
                    }
                    else {
                        error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.');
                    }
                    var capturedValue = createCapturedValue(error, digest, stack);
                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);
                }
                var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);
                if (didReceiveUpdate || hasContextChanged) {
                    var root = getWorkInProgressRoot();
                    if (root !== null) {
                        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);
                        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                            suspenseState.retryLane = attemptHydrationAtLane;
                            var eventTime = NoTimestamp;
                            enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);
                            scheduleUpdateOnFiber(root, current, attemptHydrationAtLane, eventTime);
                        }
                    }
                    renderDidSuspendDelayIfPossible();
                    var _capturedValue = createCapturedValue(new Error('This Suspense boundary received an update before it finished ' + 'hydrating. This caused the boundary to switch to client rendering. ' + 'The usual way to fix this is to wrap the original update ' + 'in startTransition.'));
                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue);
                }
                else if (isSuspenseInstancePending(suspenseInstance)) {
                    workInProgress.flags |= DidCapture;
                    workInProgress.child = current.child;
                    var retry = retryDehydratedSuspenseBoundary.bind(null, current);
                    registerSuspenseInstanceRetry(suspenseInstance, retry);
                    return null;
                }
                else {
                    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);
                    var primaryChildren = nextProps.children;
                    var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren);
                    primaryChildFragment.flags |= Hydrating;
                    return primaryChildFragment;
                }
            }
            else {
                if (workInProgress.flags & ForceClientRender) {
                    workInProgress.flags &= ~ForceClientRender;
                    var _capturedValue2 = createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));
                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue2);
                }
                else if (workInProgress.memoizedState !== null) {
                    workInProgress.child = current.child;
                    workInProgress.flags |= DidCapture;
                    return null;
                }
                else {
                    var nextPrimaryChildren = nextProps.children;
                    var nextFallbackChildren = nextProps.fallback;
                    var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
                    var _primaryChildFragment4 = workInProgress.child;
                    _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);
                    workInProgress.memoizedState = SUSPENDED_MARKER;
                    return fallbackChildFragment;
                }
            }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
            var alternate = fiber.alternate;
            if (alternate !== null) {
                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {
            var node = firstChild;
            while (node !== null) {
                if (node.tag === SuspenseComponent) {
                    var state = node.memoizedState;
                    if (state !== null) {
                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);
                    }
                }
                else if (node.tag === SuspenseListComponent) {
                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);
                }
                else if (node.child !== null) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
                if (node === workInProgress) {
                    return;
                }
                while (node.sibling === null) {
                    if (node.return === null || node.return === workInProgress) {
                        return;
                    }
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
        }
        function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
                var currentRow = row.alternate;
                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    lastContentRow = row;
                }
                row = row.sibling;
            }
            return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
            {
                if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
                    didWarnAboutRevealOrder[revealOrder] = true;
                    if (typeof revealOrder === 'string') {
                        switch (revealOrder.toLowerCase()) {
                            case 'together':
                            case 'forwards':
                            case 'backwards':
                                {
                                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                                    break;
                                }
                            case 'forward':
                            case 'backward':
                                {
                                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                                    break;
                                }
                            default:
                                error('"%s" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
                                break;
                        }
                    }
                    else {
                        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    }
                }
            }
        }
        function validateTailOptions(tailMode, revealOrder) {
            {
                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
                    if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
                        didWarnAboutTailOptions[tailMode] = true;
                        error('"%s" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean "collapsed" or "hidden"?', tailMode);
                    }
                    else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
                        didWarnAboutTailOptions[tailMode] = true;
                        error('<SuspenseList tail="%s" /> is only valid if revealOrder is ' + '"forwards" or "backwards". ' + 'Did you mean to specify revealOrder="forwards"?', tailMode);
                    }
                }
            }
        }
        function validateSuspenseListNestedChild(childSlot, index) {
            {
                var isAnArray = isArray(childSlot);
                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';
                if (isAnArray || isIterable) {
                    var type = isAnArray ? 'array' : 'iterable';
                    error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);
                    return false;
                }
            }
            return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
            {
                if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
                    if (isArray(children)) {
                        for (var i = 0; i < children.length; i++) {
                            if (!validateSuspenseListNestedChild(children[i], i)) {
                                return;
                            }
                        }
                    }
                    else {
                        var iteratorFn = getIteratorFn(children);
                        if (typeof iteratorFn === 'function') {
                            var childrenIterator = iteratorFn.call(children);
                            if (childrenIterator) {
                                var step = childrenIterator.next();
                                var _i = 0;
                                for (; !step.done; step = childrenIterator.next()) {
                                    if (!validateSuspenseListNestedChild(step.value, _i)) {
                                        return;
                                    }
                                    _i++;
                                }
                            }
                        }
                        else {
                            error('A single row was passed to a <SuspenseList revealOrder="%s" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);
                        }
                    }
                }
            }
        }
        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress.memoizedState;
            if (renderState === null) {
                workInProgress.memoizedState = {
                    isBackwards: isBackwards,
                    rendering: null,
                    renderingStartTime: 0,
                    last: lastContentRow,
                    tail: tail,
                    tailMode: tailMode
                };
            }
            else {
                renderState.isBackwards = isBackwards;
                renderState.rendering = null;
                renderState.renderingStartTime = 0;
                renderState.last = lastContentRow;
                renderState.tail = tail;
                renderState.tailMode = tailMode;
            }
        }
        function updateSuspenseListComponent(current, workInProgress, renderLanes) {
            var nextProps = workInProgress.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current, workInProgress, newChildren, renderLanes);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                workInProgress.flags |= DidCapture;
            }
            else {
                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;
                if (didSuspendBefore) {
                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);
                }
                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress, suspenseContext);
            if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                workInProgress.memoizedState = null;
            }
            else {
                switch (revealOrder) {
                    case 'forwards':
                        {
                            var lastContentRow = findLastContentRow(workInProgress.child);
                            var tail;
                            if (lastContentRow === null) {
                                tail = workInProgress.child;
                                workInProgress.child = null;
                            }
                            else {
                                tail = lastContentRow.sibling;
                                lastContentRow.sibling = null;
                            }
                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);
                            break;
                        }
                    case 'backwards':
                        {
                            var _tail = null;
                            var row = workInProgress.child;
                            workInProgress.child = null;
                            while (row !== null) {
                                var currentRow = row.alternate;
                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                                    workInProgress.child = row;
                                    break;
                                }
                                var nextRow = row.sibling;
                                row.sibling = _tail;
                                _tail = row;
                                row = nextRow;
                            }
                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);
                            break;
                        }
                    case 'together':
                        {
                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);
                            break;
                        }
                    default:
                        {
                            workInProgress.memoizedState = null;
                        }
                }
            }
            return workInProgress.child;
        }
        function updatePortalComponent(current, workInProgress, renderLanes) {
            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
            var nextChildren = workInProgress.pendingProps;
            if (current === null) {
                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
            }
            else {
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            }
            return workInProgress.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current, workInProgress, renderLanes) {
            var providerType = workInProgress.type;
            var context = providerType._context;
            var newProps = workInProgress.pendingProps;
            var oldProps = workInProgress.memoizedProps;
            var newValue = newProps.value;
            {
                if (!('value' in newProps)) {
                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
                    }
                }
                var providerPropTypes = workInProgress.type.propTypes;
                if (providerPropTypes) {
                    checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
                }
            }
            pushProvider(workInProgress, context, newValue);
            {
                if (oldProps !== null) {
                    var oldValue = oldProps.value;
                    if (objectIs(oldValue, newValue)) {
                        if (oldProps.children === newProps.children && !hasContextChanged()) {
                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                        }
                    }
                    else {
                        propagateContextChange(workInProgress, context, renderLanes);
                    }
                }
            }
            var newChildren = newProps.children;
            reconcileChildren(current, workInProgress, newChildren, renderLanes);
            return workInProgress.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current, workInProgress, renderLanes) {
            var context = workInProgress.type;
            {
                if (context._context === undefined) {
                    if (context !== context.Consumer) {
                        if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                        }
                    }
                }
                else {
                    context = context._context;
                }
            }
            var newProps = workInProgress.pendingProps;
            var render = newProps.children;
            {
                if (typeof render !== 'function') {
                    error('A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');
                }
            }
            prepareToReadContext(workInProgress, renderLanes);
            var newValue = readContext(context);
            {
                markComponentRenderStarted(workInProgress);
            }
            var newChildren;
            {
                ReactCurrentOwner$1.current = workInProgress;
                setIsRendering(true);
                newChildren = render(newValue);
                setIsRendering(false);
            }
            {
                markComponentRenderStopped();
            }
            workInProgress.flags |= PerformedWork;
            reconcileChildren(current, workInProgress, newChildren, renderLanes);
            return workInProgress.child;
        }
        function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {
            if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                if (current !== null) {
                    current.alternate = null;
                    workInProgress.alternate = null;
                    workInProgress.flags |= Placement;
                }
            }
        }
        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
            if (current !== null) {
                workInProgress.dependencies = current.dependencies;
            }
            {
                stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress.lanes);
            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
                {
                    return null;
                }
            }
            cloneChildFibers(current, workInProgress);
            return workInProgress.child;
        }
        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
            {
                var returnFiber = oldWorkInProgress.return;
                if (returnFiber === null) {
                    throw new Error('Cannot swap the root fiber.');
                }
                current.alternate = null;
                oldWorkInProgress.alternate = null;
                newWorkInProgress.index = oldWorkInProgress.index;
                newWorkInProgress.sibling = oldWorkInProgress.sibling;
                newWorkInProgress.return = oldWorkInProgress.return;
                newWorkInProgress.ref = oldWorkInProgress.ref;
                if (oldWorkInProgress === returnFiber.child) {
                    returnFiber.child = newWorkInProgress;
                }
                else {
                    var prevSibling = returnFiber.child;
                    if (prevSibling === null) {
                        throw new Error('Expected parent to have a child.');
                    }
                    while (prevSibling.sibling !== oldWorkInProgress) {
                        prevSibling = prevSibling.sibling;
                        if (prevSibling === null) {
                            throw new Error('Expected to find the previous sibling.');
                        }
                    }
                    prevSibling.sibling = newWorkInProgress;
                }
                var deletions = returnFiber.deletions;
                if (deletions === null) {
                    returnFiber.deletions = [current];
                    returnFiber.flags |= ChildDeletion;
                }
                else {
                    deletions.push(current);
                }
                newWorkInProgress.flags |= Placement;
                return newWorkInProgress;
            }
        }
        function checkScheduledUpdateOrContext(current, renderLanes) {
            var updateLanes = current.lanes;
            if (includesSomeLane(updateLanes, renderLanes)) {
                return true;
            }
            return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
            switch (workInProgress.tag) {
                case HostRoot:
                    pushHostRootContext(workInProgress);
                    var root = workInProgress.stateNode;
                    resetHydrationState();
                    break;
                case HostComponent:
                    pushHostContext(workInProgress);
                    break;
                case ClassComponent:
                    {
                        var Component = workInProgress.type;
                        if (isContextProvider(Component)) {
                            pushContextProvider(workInProgress);
                        }
                        break;
                    }
                case HostPortal:
                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                    break;
                case ContextProvider:
                    {
                        var newValue = workInProgress.memoizedProps.value;
                        var context = workInProgress.type._context;
                        pushProvider(workInProgress, context, newValue);
                        break;
                    }
                case Profiler:
                    {
                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);
                        if (hasChildWork) {
                            workInProgress.flags |= Update;
                        }
                        {
                            var stateNode = workInProgress.stateNode;
                            stateNode.effectDuration = 0;
                            stateNode.passiveEffectDuration = 0;
                        }
                    }
                    break;
                case SuspenseComponent:
                    {
                        var state = workInProgress.memoizedState;
                        if (state !== null) {
                            if (state.dehydrated !== null) {
                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                                workInProgress.flags |= DidCapture;
                                return null;
                            }
                            var primaryChildFragment = workInProgress.child;
                            var primaryChildLanes = primaryChildFragment.childLanes;
                            if (includesSomeLane(renderLanes, primaryChildLanes)) {
                                return updateSuspenseComponent(current, workInProgress, renderLanes);
                            }
                            else {
                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                                if (child !== null) {
                                    return child.sibling;
                                }
                                else {
                                    return null;
                                }
                            }
                        }
                        else {
                            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                        }
                        break;
                    }
                case SuspenseListComponent:
                    {
                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;
                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);
                        if (didSuspendBefore) {
                            if (_hasChildWork) {
                                return updateSuspenseListComponent(current, workInProgress, renderLanes);
                            }
                            workInProgress.flags |= DidCapture;
                        }
                        var renderState = workInProgress.memoizedState;
                        if (renderState !== null) {
                            renderState.rendering = null;
                            renderState.tail = null;
                            renderState.lastEffect = null;
                        }
                        pushSuspenseContext(workInProgress, suspenseStackCursor.current);
                        if (_hasChildWork) {
                            break;
                        }
                        else {
                            return null;
                        }
                    }
                case OffscreenComponent:
                case LegacyHiddenComponent:
                    {
                        workInProgress.lanes = NoLanes;
                        return updateOffscreenComponent(current, workInProgress, renderLanes);
                    }
            }
            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }
        function beginWork(current, workInProgress, renderLanes) {
            {
                if (workInProgress._debugNeedsRemount && current !== null) {
                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
                }
            }
            if (current !== null) {
                var oldProps = current.memoizedProps;
                var newProps = workInProgress.pendingProps;
                if (oldProps !== newProps || hasContextChanged() || (workInProgress.type !== current.type)) {
                    didReceiveUpdate = true;
                }
                else {
                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);
                    if (!hasScheduledUpdateOrContext &&
                        (workInProgress.flags & DidCapture) === NoFlags) {
                        didReceiveUpdate = false;
                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
                    }
                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                        didReceiveUpdate = true;
                    }
                    else {
                        didReceiveUpdate = false;
                    }
                }
            }
            else {
                didReceiveUpdate = false;
                if (getIsHydrating() && isForkedChild(workInProgress)) {
                    var slotIndex = workInProgress.index;
                    var numberOfForks = getForksAtLevel();
                    pushTreeId(workInProgress, numberOfForks, slotIndex);
                }
            }
            workInProgress.lanes = NoLanes;
            switch (workInProgress.tag) {
                case IndeterminateComponent:
                    {
                        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
                    }
                case LazyComponent:
                    {
                        var elementType = workInProgress.elementType;
                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);
                    }
                case FunctionComponent:
                    {
                        var Component = workInProgress.type;
                        var unresolvedProps = workInProgress.pendingProps;
                        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);
                    }
                case ClassComponent:
                    {
                        var _Component = workInProgress.type;
                        var _unresolvedProps = workInProgress.pendingProps;
                        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);
                    }
                case HostRoot:
                    return updateHostRoot(current, workInProgress, renderLanes);
                case HostComponent:
                    return updateHostComponent(current, workInProgress, renderLanes);
                case HostText:
                    return updateHostText(current, workInProgress);
                case SuspenseComponent:
                    return updateSuspenseComponent(current, workInProgress, renderLanes);
                case HostPortal:
                    return updatePortalComponent(current, workInProgress, renderLanes);
                case ForwardRef:
                    {
                        var type = workInProgress.type;
                        var _unresolvedProps2 = workInProgress.pendingProps;
                        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);
                    }
                case Fragment:
                    return updateFragment(current, workInProgress, renderLanes);
                case Mode:
                    return updateMode(current, workInProgress, renderLanes);
                case Profiler:
                    return updateProfiler(current, workInProgress, renderLanes);
                case ContextProvider:
                    return updateContextProvider(current, workInProgress, renderLanes);
                case ContextConsumer:
                    return updateContextConsumer(current, workInProgress, renderLanes);
                case MemoComponent:
                    {
                        var _type2 = workInProgress.type;
                        var _unresolvedProps3 = workInProgress.pendingProps;
                        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                        {
                            if (workInProgress.type !== workInProgress.elementType) {
                                var outerPropTypes = _type2.propTypes;
                                if (outerPropTypes) {
                                    checkPropTypes(outerPropTypes, _resolvedProps3, 'prop', getComponentNameFromType(_type2));
                                }
                            }
                        }
                        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);
                    }
                case SimpleMemoComponent:
                    {
                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
                    }
                case IncompleteClassComponent:
                    {
                        var _Component2 = workInProgress.type;
                        var _unresolvedProps4 = workInProgress.pendingProps;
                        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);
                    }
                case SuspenseListComponent:
                    {
                        return updateSuspenseListComponent(current, workInProgress, renderLanes);
                    }
                case ScopeComponent:
                    {
                        break;
                    }
                case OffscreenComponent:
                    {
                        return updateOffscreenComponent(current, workInProgress, renderLanes);
                    }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in " + 'React. Please file an issue.');
        }
        function markUpdate(workInProgress) {
            workInProgress.flags |= Update;
        }
        function markRef$1(workInProgress) {
            workInProgress.flags |= Ref;
            {
                workInProgress.flags |= RefStatic;
            }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
            appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {
                var node = workInProgress.child;
                while (node !== null) {
                    if (node.tag === HostComponent || node.tag === HostText) {
                        appendInitialChild(parent, node.stateNode);
                    }
                    else if (node.tag === HostPortal)
                        ;
                    else if (node.child !== null) {
                        node.child.return = node;
                        node = node.child;
                        continue;
                    }
                    if (node === workInProgress) {
                        return;
                    }
                    while (node.sibling === null) {
                        if (node.return === null || node.return === workInProgress) {
                            return;
                        }
                        node = node.return;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                }
            };
            updateHostContainer = function (current, workInProgress) {
            };
            updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {
                var oldProps = current.memoizedProps;
                if (oldProps === newProps) {
                    return;
                }
                var instance = workInProgress.stateNode;
                var currentHostContext = getHostContext();
                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
                workInProgress.updateQueue = updatePayload;
                if (updatePayload) {
                    markUpdate(workInProgress);
                }
            };
            updateHostText$1 = function (current, workInProgress, oldText, newText) {
                if (oldText !== newText) {
                    markUpdate(workInProgress);
                }
            };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
                return;
            }
            switch (renderState.tailMode) {
                case 'hidden':
                    {
                        var tailNode = renderState.tail;
                        var lastTailNode = null;
                        while (tailNode !== null) {
                            if (tailNode.alternate !== null) {
                                lastTailNode = tailNode;
                            }
                            tailNode = tailNode.sibling;
                        }
                        if (lastTailNode === null) {
                            renderState.tail = null;
                        }
                        else {
                            lastTailNode.sibling = null;
                        }
                        break;
                    }
                case 'collapsed':
                    {
                        var _tailNode = renderState.tail;
                        var _lastTailNode = null;
                        while (_tailNode !== null) {
                            if (_tailNode.alternate !== null) {
                                _lastTailNode = _tailNode;
                            }
                            _tailNode = _tailNode.sibling;
                        }
                        if (_lastTailNode === null) {
                            if (!hasRenderedATailFallback && renderState.tail !== null) {
                                renderState.tail.sibling = null;
                            }
                            else {
                                renderState.tail = null;
                            }
                        }
                        else {
                            _lastTailNode.sibling = null;
                        }
                        break;
                    }
            }
        }
        function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                    var actualDuration = completedWork.actualDuration;
                    var treeBaseDuration = completedWork.selfBaseDuration;
                    var child = completedWork.child;
                    while (child !== null) {
                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                        subtreeFlags |= child.subtreeFlags;
                        subtreeFlags |= child.flags;
                        actualDuration += child.actualDuration;
                        treeBaseDuration += child.treeBaseDuration;
                        child = child.sibling;
                    }
                    completedWork.actualDuration = actualDuration;
                    completedWork.treeBaseDuration = treeBaseDuration;
                }
                else {
                    var _child = completedWork.child;
                    while (_child !== null) {
                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                        subtreeFlags |= _child.subtreeFlags;
                        subtreeFlags |= _child.flags;
                        _child.return = completedWork;
                        _child = _child.sibling;
                    }
                }
                completedWork.subtreeFlags |= subtreeFlags;
            }
            else {
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                    var _treeBaseDuration = completedWork.selfBaseDuration;
                    var _child2 = completedWork.child;
                    while (_child2 !== null) {
                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                        subtreeFlags |= _child2.subtreeFlags & StaticMask;
                        subtreeFlags |= _child2.flags & StaticMask;
                        _treeBaseDuration += _child2.treeBaseDuration;
                        _child2 = _child2.sibling;
                    }
                    completedWork.treeBaseDuration = _treeBaseDuration;
                }
                else {
                    var _child3 = completedWork.child;
                    while (_child3 !== null) {
                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                        subtreeFlags |= _child3.subtreeFlags & StaticMask;
                        subtreeFlags |= _child3.flags & StaticMask;
                        _child3.return = completedWork;
                        _child3 = _child3.sibling;
                    }
                }
                completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {
                warnIfUnhydratedTailNodes(workInProgress);
                resetHydrationState();
                workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;
                return false;
            }
            var wasHydrated = popHydrationState(workInProgress);
            if (nextState !== null && nextState.dehydrated !== null) {
                if (current === null) {
                    if (!wasHydrated) {
                        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');
                    }
                    prepareToHydrateHostSuspenseInstance(workInProgress);
                    bubbleProperties(workInProgress);
                    {
                        if ((workInProgress.mode & ProfileMode) !== NoMode) {
                            var isTimedOutSuspense = nextState !== null;
                            if (isTimedOutSuspense) {
                                var primaryChildFragment = workInProgress.child;
                                if (primaryChildFragment !== null) {
                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                                }
                            }
                        }
                    }
                    return false;
                }
                else {
                    resetHydrationState();
                    if ((workInProgress.flags & DidCapture) === NoFlags) {
                        workInProgress.memoizedState = null;
                    }
                    workInProgress.flags |= Update;
                    bubbleProperties(workInProgress);
                    {
                        if ((workInProgress.mode & ProfileMode) !== NoMode) {
                            var _isTimedOutSuspense = nextState !== null;
                            if (_isTimedOutSuspense) {
                                var _primaryChildFragment = workInProgress.child;
                                if (_primaryChildFragment !== null) {
                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                                }
                            }
                        }
                    }
                    return false;
                }
            }
            else {
                upgradeHydrationErrorsToRecoverable();
                return true;
            }
        }
        function completeWork(current, workInProgress, renderLanes) {
            var newProps = workInProgress.pendingProps;
            popTreeContext(workInProgress);
            switch (workInProgress.tag) {
                case IndeterminateComponent:
                case LazyComponent:
                case SimpleMemoComponent:
                case FunctionComponent:
                case ForwardRef:
                case Fragment:
                case Mode:
                case Profiler:
                case ContextConsumer:
                case MemoComponent:
                    bubbleProperties(workInProgress);
                    return null;
                case ClassComponent:
                    {
                        var Component = workInProgress.type;
                        if (isContextProvider(Component)) {
                            popContext(workInProgress);
                        }
                        bubbleProperties(workInProgress);
                        return null;
                    }
                case HostRoot:
                    {
                        var fiberRoot = workInProgress.stateNode;
                        popHostContainer(workInProgress);
                        popTopLevelContextObject(workInProgress);
                        resetWorkInProgressVersions();
                        if (fiberRoot.pendingContext) {
                            fiberRoot.context = fiberRoot.pendingContext;
                            fiberRoot.pendingContext = null;
                        }
                        if (current === null || current.child === null) {
                            var wasHydrated = popHydrationState(workInProgress);
                            if (wasHydrated) {
                                markUpdate(workInProgress);
                            }
                            else {
                                if (current !== null) {
                                    var prevState = current.memoizedState;
                                    if (!prevState.isDehydrated ||
                                        (workInProgress.flags & ForceClientRender) !== NoFlags) {
                                        workInProgress.flags |= Snapshot;
                                        upgradeHydrationErrorsToRecoverable();
                                    }
                                }
                            }
                        }
                        updateHostContainer(current, workInProgress);
                        bubbleProperties(workInProgress);
                        return null;
                    }
                case HostComponent:
                    {
                        popHostContext(workInProgress);
                        var rootContainerInstance = getRootHostContainer();
                        var type = workInProgress.type;
                        if (current !== null && workInProgress.stateNode != null) {
                            updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);
                            if (current.ref !== workInProgress.ref) {
                                markRef$1(workInProgress);
                            }
                        }
                        else {
                            if (!newProps) {
                                if (workInProgress.stateNode === null) {
                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');
                                }
                                bubbleProperties(workInProgress);
                                return null;
                            }
                            var currentHostContext = getHostContext();
                            var _wasHydrated = popHydrationState(workInProgress);
                            if (_wasHydrated) {
                                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
                                    markUpdate(workInProgress);
                                }
                            }
                            else {
                                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
                                appendAllChildren(instance, workInProgress, false, false);
                                workInProgress.stateNode = instance;
                                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                                    markUpdate(workInProgress);
                                }
                            }
                            if (workInProgress.ref !== null) {
                                markRef$1(workInProgress);
                            }
                        }
                        bubbleProperties(workInProgress);
                        return null;
                    }
                case HostText:
                    {
                        var newText = newProps;
                        if (current && workInProgress.stateNode != null) {
                            var oldText = current.memoizedProps;
                            updateHostText$1(current, workInProgress, oldText, newText);
                        }
                        else {
                            if (typeof newText !== 'string') {
                                if (workInProgress.stateNode === null) {
                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');
                                }
                            }
                            var _rootContainerInstance = getRootHostContainer();
                            var _currentHostContext = getHostContext();
                            var _wasHydrated2 = popHydrationState(workInProgress);
                            if (_wasHydrated2) {
                                if (prepareToHydrateHostTextInstance(workInProgress)) {
                                    markUpdate(workInProgress);
                                }
                            }
                            else {
                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                            }
                        }
                        bubbleProperties(workInProgress);
                        return null;
                    }
                case SuspenseComponent:
                    {
                        popSuspenseContext(workInProgress);
                        var nextState = workInProgress.memoizedState;
                        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {
                            var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);
                            if (!fallthroughToNormalSuspensePath) {
                                if (workInProgress.flags & ShouldCapture) {
                                    return workInProgress;
                                }
                                else {
                                    return null;
                                }
                            }
                        }
                        if ((workInProgress.flags & DidCapture) !== NoFlags) {
                            workInProgress.lanes = renderLanes;
                            if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                transferActualDuration(workInProgress);
                            }
                            return workInProgress;
                        }
                        var nextDidTimeout = nextState !== null;
                        var prevDidTimeout = current !== null && current.memoizedState !== null;
                        if (nextDidTimeout !== prevDidTimeout) {
                            if (nextDidTimeout) {
                                var _offscreenFiber2 = workInProgress.child;
                                _offscreenFiber2.flags |= Visibility;
                                if ((workInProgress.mode & ConcurrentMode) !== NoMode) {
                                    var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                                        renderDidSuspend();
                                    }
                                    else {
                                        renderDidSuspendDelayIfPossible();
                                    }
                                }
                            }
                        }
                        var wakeables = workInProgress.updateQueue;
                        if (wakeables !== null) {
                            workInProgress.flags |= Update;
                        }
                        bubbleProperties(workInProgress);
                        {
                            if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                if (nextDidTimeout) {
                                    var primaryChildFragment = workInProgress.child;
                                    if (primaryChildFragment !== null) {
                                        workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                                    }
                                }
                            }
                        }
                        return null;
                    }
                case HostPortal:
                    popHostContainer(workInProgress);
                    updateHostContainer(current, workInProgress);
                    if (current === null) {
                        preparePortalMount(workInProgress.stateNode.containerInfo);
                    }
                    bubbleProperties(workInProgress);
                    return null;
                case ContextProvider:
                    var context = workInProgress.type._context;
                    popProvider(context, workInProgress);
                    bubbleProperties(workInProgress);
                    return null;
                case IncompleteClassComponent:
                    {
                        var _Component = workInProgress.type;
                        if (isContextProvider(_Component)) {
                            popContext(workInProgress);
                        }
                        bubbleProperties(workInProgress);
                        return null;
                    }
                case SuspenseListComponent:
                    {
                        popSuspenseContext(workInProgress);
                        var renderState = workInProgress.memoizedState;
                        if (renderState === null) {
                            bubbleProperties(workInProgress);
                            return null;
                        }
                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
                        var renderedTail = renderState.rendering;
                        if (renderedTail === null) {
                            if (!didSuspendAlready) {
                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);
                                if (!cannotBeSuspended) {
                                    var row = workInProgress.child;
                                    while (row !== null) {
                                        var suspended = findFirstSuspended(row);
                                        if (suspended !== null) {
                                            didSuspendAlready = true;
                                            workInProgress.flags |= DidCapture;
                                            cutOffTailIfNeeded(renderState, false);
                                            var newThenables = suspended.updateQueue;
                                            if (newThenables !== null) {
                                                workInProgress.updateQueue = newThenables;
                                                workInProgress.flags |= Update;
                                            }
                                            workInProgress.subtreeFlags = NoFlags;
                                            resetChildFibers(workInProgress, renderLanes);
                                            pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                                            return workInProgress.child;
                                        }
                                        row = row.sibling;
                                    }
                                }
                                if (renderState.tail !== null && now() > getRenderTargetTime()) {
                                    workInProgress.flags |= DidCapture;
                                    didSuspendAlready = true;
                                    cutOffTailIfNeeded(renderState, false);
                                    workInProgress.lanes = SomeRetryLane;
                                }
                            }
                            else {
                                cutOffTailIfNeeded(renderState, false);
                            }
                        }
                        else {
                            if (!didSuspendAlready) {
                                var _suspended = findFirstSuspended(renderedTail);
                                if (_suspended !== null) {
                                    workInProgress.flags |= DidCapture;
                                    didSuspendAlready = true;
                                    var _newThenables = _suspended.updateQueue;
                                    if (_newThenables !== null) {
                                        workInProgress.updateQueue = _newThenables;
                                        workInProgress.flags |= Update;
                                    }
                                    cutOffTailIfNeeded(renderState, true);
                                    if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating()) {
                                        bubbleProperties(workInProgress);
                                        return null;
                                    }
                                }
                                else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {
                                    workInProgress.flags |= DidCapture;
                                    didSuspendAlready = true;
                                    cutOffTailIfNeeded(renderState, false);
                                    workInProgress.lanes = SomeRetryLane;
                                }
                            }
                            if (renderState.isBackwards) {
                                renderedTail.sibling = workInProgress.child;
                                workInProgress.child = renderedTail;
                            }
                            else {
                                var previousSibling = renderState.last;
                                if (previousSibling !== null) {
                                    previousSibling.sibling = renderedTail;
                                }
                                else {
                                    workInProgress.child = renderedTail;
                                }
                                renderState.last = renderedTail;
                            }
                        }
                        if (renderState.tail !== null) {
                            var next = renderState.tail;
                            renderState.rendering = next;
                            renderState.tail = next.sibling;
                            renderState.renderingStartTime = now();
                            next.sibling = null;
                            var suspenseContext = suspenseStackCursor.current;
                            if (didSuspendAlready) {
                                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                            }
                            else {
                                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                            }
                            pushSuspenseContext(workInProgress, suspenseContext);
                            return next;
                        }
                        bubbleProperties(workInProgress);
                        return null;
                    }
                case ScopeComponent:
                    {
                        break;
                    }
                case OffscreenComponent:
                case LegacyHiddenComponent:
                    {
                        popRenderLanes(workInProgress);
                        var _nextState = workInProgress.memoizedState;
                        var nextIsHidden = _nextState !== null;
                        if (current !== null) {
                            var _prevState = current.memoizedState;
                            var prevIsHidden = _prevState !== null;
                            if (prevIsHidden !== nextIsHidden && (!enableLegacyHidden)) {
                                workInProgress.flags |= Visibility;
                            }
                        }
                        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {
                            bubbleProperties(workInProgress);
                        }
                        else {
                            if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                                bubbleProperties(workInProgress);
                                {
                                    if (workInProgress.subtreeFlags & (Placement | Update)) {
                                        workInProgress.flags |= Visibility;
                                    }
                                }
                            }
                        }
                        return null;
                    }
                case CacheComponent:
                    {
                        return null;
                    }
                case TracingMarkerComponent:
                    {
                        return null;
                    }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in " + 'React. Please file an issue.');
        }
        function unwindWork(current, workInProgress, renderLanes) {
            popTreeContext(workInProgress);
            switch (workInProgress.tag) {
                case ClassComponent:
                    {
                        var Component = workInProgress.type;
                        if (isContextProvider(Component)) {
                            popContext(workInProgress);
                        }
                        var flags = workInProgress.flags;
                        if (flags & ShouldCapture) {
                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;
                            if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                transferActualDuration(workInProgress);
                            }
                            return workInProgress;
                        }
                        return null;
                    }
                case HostRoot:
                    {
                        var root = workInProgress.stateNode;
                        popHostContainer(workInProgress);
                        popTopLevelContextObject(workInProgress);
                        resetWorkInProgressVersions();
                        var _flags = workInProgress.flags;
                        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;
                            return workInProgress;
                        }
                        return null;
                    }
                case HostComponent:
                    {
                        popHostContext(workInProgress);
                        return null;
                    }
                case SuspenseComponent:
                    {
                        popSuspenseContext(workInProgress);
                        var suspenseState = workInProgress.memoizedState;
                        if (suspenseState !== null && suspenseState.dehydrated !== null) {
                            if (workInProgress.alternate === null) {
                                throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');
                            }
                            resetHydrationState();
                        }
                        var _flags2 = workInProgress.flags;
                        if (_flags2 & ShouldCapture) {
                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture;
                            if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                transferActualDuration(workInProgress);
                            }
                            return workInProgress;
                        }
                        return null;
                    }
                case SuspenseListComponent:
                    {
                        popSuspenseContext(workInProgress);
                        return null;
                    }
                case HostPortal:
                    popHostContainer(workInProgress);
                    return null;
                case ContextProvider:
                    var context = workInProgress.type._context;
                    popProvider(context, workInProgress);
                    return null;
                case OffscreenComponent:
                case LegacyHiddenComponent:
                    popRenderLanes(workInProgress);
                    return null;
                case CacheComponent:
                    return null;
                default:
                    return null;
            }
        }
        function unwindInterruptedWork(current, interruptedWork, renderLanes) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
                case ClassComponent:
                    {
                        var childContextTypes = interruptedWork.type.childContextTypes;
                        if (childContextTypes !== null && childContextTypes !== undefined) {
                            popContext(interruptedWork);
                        }
                        break;
                    }
                case HostRoot:
                    {
                        var root = interruptedWork.stateNode;
                        popHostContainer(interruptedWork);
                        popTopLevelContextObject(interruptedWork);
                        resetWorkInProgressVersions();
                        break;
                    }
                case HostComponent:
                    {
                        popHostContext(interruptedWork);
                        break;
                    }
                case HostPortal:
                    popHostContainer(interruptedWork);
                    break;
                case SuspenseComponent:
                    popSuspenseContext(interruptedWork);
                    break;
                case SuspenseListComponent:
                    popSuspenseContext(interruptedWork);
                    break;
                case ContextProvider:
                    var context = interruptedWork.type._context;
                    popProvider(context, interruptedWork);
                    break;
                case OffscreenComponent:
                case LegacyHiddenComponent:
                    popRenderLanes(interruptedWork);
                    break;
            }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error) {
            {
                invokeGuardedCallback(null, function () {
                    throw error;
                });
                clearCaughtError();
            }
        }
        var callComponentWillUnmountWithTimer = function (current, instance) {
            instance.props = current.memoizedProps;
            instance.state = current.memoizedState;
            if (current.mode & ProfileMode) {
                try {
                    startLayoutEffectTimer();
                    instance.componentWillUnmount();
                }
                finally {
                    recordLayoutEffectDuration(current);
                }
            }
            else {
                instance.componentWillUnmount();
            }
        };
        function safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {
            try {
                commitHookEffectListMount(Layout, current);
            }
            catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
            try {
                callComponentWillUnmountWithTimer(current, instance);
            }
            catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
        function safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {
            try {
                instance.componentDidMount();
            }
            catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
        function safelyAttachRef(current, nearestMountedAncestor) {
            try {
                commitAttachRef(current);
            }
            catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
        function safelyDetachRef(current, nearestMountedAncestor) {
            var ref = current.ref;
            if (ref !== null) {
                if (typeof ref === 'function') {
                    var retVal;
                    try {
                        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {
                            try {
                                startLayoutEffectTimer();
                                retVal = ref(null);
                            }
                            finally {
                                recordLayoutEffectDuration(current);
                            }
                        }
                        else {
                            retVal = ref(null);
                        }
                    }
                    catch (error) {
                        captureCommitPhaseError(current, nearestMountedAncestor, error);
                    }
                    {
                        if (typeof retVal === 'function') {
                            error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));
                        }
                    }
                }
                else {
                    ref.current = null;
                }
            }
        }
        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
            try {
                destroy();
            }
            catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root, firstChild) {
            focusedInstanceHandle = prepareForCommit(root.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                var child = fiber.child;
                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                    child.return = fiber;
                    nextEffect = child;
                }
                else {
                    commitBeforeMutationEffects_complete();
                }
            }
        }
        function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                setCurrentFiber(fiber);
                try {
                    commitBeforeMutationEffectsOnFiber(fiber);
                }
                catch (error) {
                    captureCommitPhaseError(fiber, fiber.return, error);
                }
                resetCurrentFiber();
                var sibling = fiber.sibling;
                if (sibling !== null) {
                    sibling.return = fiber.return;
                    nextEffect = sibling;
                    return;
                }
                nextEffect = fiber.return;
            }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
                setCurrentFiber(finishedWork);
                switch (finishedWork.tag) {
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            break;
                        }
                    case ClassComponent:
                        {
                            if (current !== null) {
                                var prevProps = current.memoizedProps;
                                var prevState = current.memoizedState;
                                var instance = finishedWork.stateNode;
                                {
                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                        if (instance.props !== finishedWork.memoizedProps) {
                                            error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                        }
                                        if (instance.state !== finishedWork.memoizedState) {
                                            error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                        }
                                    }
                                }
                                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                                {
                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                                        didWarnSet.add(finishedWork.type);
                                        error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));
                                    }
                                }
                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                            }
                            break;
                        }
                    case HostRoot:
                        {
                            {
                                var root = finishedWork.stateNode;
                                clearContainer(root.containerInfo);
                            }
                            break;
                        }
                    case HostComponent:
                    case HostText:
                    case HostPortal:
                    case IncompleteClassComponent:
                        break;
                    default:
                        {
                            throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
                        }
                }
                resetCurrentFiber();
            }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
                var firstEffect = lastEffect.next;
                var effect = firstEffect;
                do {
                    if ((effect.tag & flags) === flags) {
                        var destroy = effect.destroy;
                        effect.destroy = undefined;
                        if (destroy !== undefined) {
                            {
                                if ((flags & Passive$1) !== NoFlags$1) {
                                    markComponentPassiveEffectUnmountStarted(finishedWork);
                                }
                                else if ((flags & Layout) !== NoFlags$1) {
                                    markComponentLayoutEffectUnmountStarted(finishedWork);
                                }
                            }
                            {
                                if ((flags & Insertion) !== NoFlags$1) {
                                    setIsRunningInsertionEffect(true);
                                }
                            }
                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                            {
                                if ((flags & Insertion) !== NoFlags$1) {
                                    setIsRunningInsertionEffect(false);
                                }
                            }
                            {
                                if ((flags & Passive$1) !== NoFlags$1) {
                                    markComponentPassiveEffectUnmountStopped();
                                }
                                else if ((flags & Layout) !== NoFlags$1) {
                                    markComponentLayoutEffectUnmountStopped();
                                }
                            }
                        }
                    }
                    effect = effect.next;
                } while (effect !== firstEffect);
            }
        }
        function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
                var firstEffect = lastEffect.next;
                var effect = firstEffect;
                do {
                    if ((effect.tag & flags) === flags) {
                        {
                            if ((flags & Passive$1) !== NoFlags$1) {
                                markComponentPassiveEffectMountStarted(finishedWork);
                            }
                            else if ((flags & Layout) !== NoFlags$1) {
                                markComponentLayoutEffectMountStarted(finishedWork);
                            }
                        }
                        var create = effect.create;
                        {
                            if ((flags & Insertion) !== NoFlags$1) {
                                setIsRunningInsertionEffect(true);
                            }
                        }
                        effect.destroy = create();
                        {
                            if ((flags & Insertion) !== NoFlags$1) {
                                setIsRunningInsertionEffect(false);
                            }
                        }
                        {
                            if ((flags & Passive$1) !== NoFlags$1) {
                                markComponentPassiveEffectMountStopped();
                            }
                            else if ((flags & Layout) !== NoFlags$1) {
                                markComponentLayoutEffectMountStopped();
                            }
                        }
                        {
                            var destroy = effect.destroy;
                            if (destroy !== undefined && typeof destroy !== 'function') {
                                var hookName = void 0;
                                if ((effect.tag & Layout) !== NoFlags) {
                                    hookName = 'useLayoutEffect';
                                }
                                else if ((effect.tag & Insertion) !== NoFlags) {
                                    hookName = 'useInsertionEffect';
                                }
                                else {
                                    hookName = 'useEffect';
                                }
                                var addendum = void 0;
                                if (destroy === null) {
                                    addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
                                }
                                else if (typeof destroy.then === 'function') {
                                    addendum = '\n\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + hookName + '(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + "}, [someId]); // Or [] if effect doesn't need props or state\n\n" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';
                                }
                                else {
                                    addendum = ' You returned: ' + destroy;
                                }
                                error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);
                            }
                        }
                    }
                    effect = effect.next;
                } while (effect !== firstEffect);
            }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
                if ((finishedWork.flags & Update) !== NoFlags) {
                    switch (finishedWork.tag) {
                        case Profiler:
                            {
                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                                var commitTime = getCommitTime();
                                var phase = finishedWork.alternate === null ? 'mount' : 'update';
                                {
                                    if (isCurrentUpdateNested()) {
                                        phase = 'nested-update';
                                    }
                                }
                                if (typeof onPostCommit === 'function') {
                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);
                                }
                                var parentFiber = finishedWork.return;
                                outer: while (parentFiber !== null) {
                                    switch (parentFiber.tag) {
                                        case HostRoot:
                                            var root = parentFiber.stateNode;
                                            root.passiveEffectDuration += passiveEffectDuration;
                                            break outer;
                                        case Profiler:
                                            var parentStateNode = parentFiber.stateNode;
                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;
                                            break outer;
                                    }
                                    parentFiber = parentFiber.return;
                                }
                                break;
                            }
                    }
                }
            }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
                switch (finishedWork.tag) {
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            if (!offscreenSubtreeWasHidden) {
                                if (finishedWork.mode & ProfileMode) {
                                    try {
                                        startLayoutEffectTimer();
                                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                                    }
                                    finally {
                                        recordLayoutEffectDuration(finishedWork);
                                    }
                                }
                                else {
                                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                                }
                            }
                            break;
                        }
                    case ClassComponent:
                        {
                            var instance = finishedWork.stateNode;
                            if (finishedWork.flags & Update) {
                                if (!offscreenSubtreeWasHidden) {
                                    if (current === null) {
                                        {
                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                if (instance.props !== finishedWork.memoizedProps) {
                                                    error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                }
                                                if (instance.state !== finishedWork.memoizedState) {
                                                    error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                }
                                            }
                                        }
                                        if (finishedWork.mode & ProfileMode) {
                                            try {
                                                startLayoutEffectTimer();
                                                instance.componentDidMount();
                                            }
                                            finally {
                                                recordLayoutEffectDuration(finishedWork);
                                            }
                                        }
                                        else {
                                            instance.componentDidMount();
                                        }
                                    }
                                    else {
                                        var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
                                        var prevState = current.memoizedState;
                                        {
                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                if (instance.props !== finishedWork.memoizedProps) {
                                                    error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                }
                                                if (instance.state !== finishedWork.memoizedState) {
                                                    error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                }
                                            }
                                        }
                                        if (finishedWork.mode & ProfileMode) {
                                            try {
                                                startLayoutEffectTimer();
                                                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                                            }
                                            finally {
                                                recordLayoutEffectDuration(finishedWork);
                                            }
                                        }
                                        else {
                                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                                        }
                                    }
                                }
                            }
                            var updateQueue = finishedWork.updateQueue;
                            if (updateQueue !== null) {
                                {
                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                        if (instance.props !== finishedWork.memoizedProps) {
                                            error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                        }
                                        if (instance.state !== finishedWork.memoizedState) {
                                            error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                        }
                                    }
                                }
                                commitUpdateQueue(finishedWork, updateQueue, instance);
                            }
                            break;
                        }
                    case HostRoot:
                        {
                            var _updateQueue = finishedWork.updateQueue;
                            if (_updateQueue !== null) {
                                var _instance = null;
                                if (finishedWork.child !== null) {
                                    switch (finishedWork.child.tag) {
                                        case HostComponent:
                                            _instance = getPublicInstance(finishedWork.child.stateNode);
                                            break;
                                        case ClassComponent:
                                            _instance = finishedWork.child.stateNode;
                                            break;
                                    }
                                }
                                commitUpdateQueue(finishedWork, _updateQueue, _instance);
                            }
                            break;
                        }
                    case HostComponent:
                        {
                            var _instance2 = finishedWork.stateNode;
                            if (current === null && finishedWork.flags & Update) {
                                var type = finishedWork.type;
                                var props = finishedWork.memoizedProps;
                                commitMount(_instance2, type, props);
                            }
                            break;
                        }
                    case HostText:
                        {
                            break;
                        }
                    case HostPortal:
                        {
                            break;
                        }
                    case Profiler:
                        {
                            {
                                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                                var effectDuration = finishedWork.stateNode.effectDuration;
                                var commitTime = getCommitTime();
                                var phase = current === null ? 'mount' : 'update';
                                {
                                    if (isCurrentUpdateNested()) {
                                        phase = 'nested-update';
                                    }
                                }
                                if (typeof onRender === 'function') {
                                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);
                                }
                                {
                                    if (typeof onCommit === 'function') {
                                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);
                                    }
                                    enqueuePendingPassiveProfilerEffect(finishedWork);
                                    var parentFiber = finishedWork.return;
                                    outer: while (parentFiber !== null) {
                                        switch (parentFiber.tag) {
                                            case HostRoot:
                                                var root = parentFiber.stateNode;
                                                root.effectDuration += effectDuration;
                                                break outer;
                                            case Profiler:
                                                var parentStateNode = parentFiber.stateNode;
                                                parentStateNode.effectDuration += effectDuration;
                                                break outer;
                                        }
                                        parentFiber = parentFiber.return;
                                    }
                                }
                            }
                            break;
                        }
                    case SuspenseComponent:
                        {
                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                            break;
                        }
                    case SuspenseListComponent:
                    case IncompleteClassComponent:
                    case ScopeComponent:
                    case OffscreenComponent:
                    case LegacyHiddenComponent:
                    case TracingMarkerComponent:
                        {
                            break;
                        }
                    default:
                        throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
                }
            }
            if (!offscreenSubtreeWasHidden) {
                {
                    if (finishedWork.flags & Ref) {
                        commitAttachRef(finishedWork);
                    }
                }
            }
        }
        function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent:
                    {
                        if (node.mode & ProfileMode) {
                            try {
                                startLayoutEffectTimer();
                                safelyCallCommitHookLayoutEffectListMount(node, node.return);
                            }
                            finally {
                                recordLayoutEffectDuration(node);
                            }
                        }
                        else {
                            safelyCallCommitHookLayoutEffectListMount(node, node.return);
                        }
                        break;
                    }
                case ClassComponent:
                    {
                        var instance = node.stateNode;
                        if (typeof instance.componentDidMount === 'function') {
                            safelyCallComponentDidMount(node, node.return, instance);
                        }
                        safelyAttachRef(node, node.return);
                        break;
                    }
                case HostComponent:
                    {
                        safelyAttachRef(node, node.return);
                        break;
                    }
            }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
                var node = finishedWork;
                while (true) {
                    if (node.tag === HostComponent) {
                        if (hostSubtreeRoot === null) {
                            hostSubtreeRoot = node;
                            try {
                                var instance = node.stateNode;
                                if (isHidden) {
                                    hideInstance(instance);
                                }
                                else {
                                    unhideInstance(node.stateNode, node.memoizedProps);
                                }
                            }
                            catch (error) {
                                captureCommitPhaseError(finishedWork, finishedWork.return, error);
                            }
                        }
                    }
                    else if (node.tag === HostText) {
                        if (hostSubtreeRoot === null) {
                            try {
                                var _instance3 = node.stateNode;
                                if (isHidden) {
                                    hideTextInstance(_instance3);
                                }
                                else {
                                    unhideTextInstance(_instance3, node.memoizedProps);
                                }
                            }
                            catch (error) {
                                captureCommitPhaseError(finishedWork, finishedWork.return, error);
                            }
                        }
                    }
                    else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                        ;
                    else if (node.child !== null) {
                        node.child.return = node;
                        node = node.child;
                        continue;
                    }
                    if (node === finishedWork) {
                        return;
                    }
                    while (node.sibling === null) {
                        if (node.return === null || node.return === finishedWork) {
                            return;
                        }
                        if (hostSubtreeRoot === node) {
                            hostSubtreeRoot = null;
                        }
                        node = node.return;
                    }
                    if (hostSubtreeRoot === node) {
                        hostSubtreeRoot = null;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                }
            }
        }
        function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
                var instance = finishedWork.stateNode;
                var instanceToUse;
                switch (finishedWork.tag) {
                    case HostComponent:
                        instanceToUse = getPublicInstance(instance);
                        break;
                    default:
                        instanceToUse = instance;
                }
                if (typeof ref === 'function') {
                    var retVal;
                    if (finishedWork.mode & ProfileMode) {
                        try {
                            startLayoutEffectTimer();
                            retVal = ref(instanceToUse);
                        }
                        finally {
                            recordLayoutEffectDuration(finishedWork);
                        }
                    }
                    else {
                        retVal = ref(instanceToUse);
                    }
                    {
                        if (typeof retVal === 'function') {
                            error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));
                        }
                    }
                }
                else {
                    {
                        if (!ref.hasOwnProperty('current')) {
                            error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));
                        }
                    }
                    ref.current = instanceToUse;
                }
            }
        }
        function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
                alternate.return = null;
            }
            fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
                fiber.alternate = null;
                detachFiberAfterEffects(alternate);
            }
            {
                fiber.child = null;
                fiber.deletions = null;
                fiber.sibling = null;
                if (fiber.tag === HostComponent) {
                    var hostInstance = fiber.stateNode;
                    if (hostInstance !== null) {
                        detachDeletedInstance(hostInstance);
                    }
                }
                fiber.stateNode = null;
                {
                    fiber._debugOwner = null;
                }
                {
                    fiber.return = null;
                    fiber.dependencies = null;
                    fiber.memoizedProps = null;
                    fiber.memoizedState = null;
                    fiber.pendingProps = null;
                    fiber.stateNode = null;
                    fiber.updateQueue = null;
                }
            }
        }
        function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
                if (isHostParent(parent)) {
                    return parent;
                }
                parent = parent.return;
            }
            throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');
        }
        function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
            var node = fiber;
            siblings: while (true) {
                while (node.sibling === null) {
                    if (node.return === null || isHostParent(node.return)) {
                        return null;
                    }
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                    if (node.flags & Placement) {
                        continue siblings;
                    }
                    if (node.child === null || node.tag === HostPortal) {
                        continue siblings;
                    }
                    else {
                        node.child.return = node;
                        node = node.child;
                    }
                }
                if (!(node.flags & Placement)) {
                    return node.stateNode;
                }
            }
        }
        function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
                case HostComponent:
                    {
                        var parent = parentFiber.stateNode;
                        if (parentFiber.flags & ContentReset) {
                            resetTextContent(parent);
                            parentFiber.flags &= ~ContentReset;
                        }
                        var before = getHostSibling(finishedWork);
                        insertOrAppendPlacementNode(finishedWork, before, parent);
                        break;
                    }
                case HostRoot:
                case HostPortal:
                    {
                        var _parent = parentFiber.stateNode.containerInfo;
                        var _before = getHostSibling(finishedWork);
                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                        break;
                    }
                default:
                    throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');
            }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
                var stateNode = node.stateNode;
                if (before) {
                    insertInContainerBefore(parent, stateNode, before);
                }
                else {
                    appendChildToContainer(parent, stateNode);
                }
            }
            else if (tag === HostPortal)
                ;
            else {
                var child = node.child;
                if (child !== null) {
                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                    var sibling = child.sibling;
                    while (sibling !== null) {
                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                        sibling = sibling.sibling;
                    }
                }
            }
        }
        function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
                var stateNode = node.stateNode;
                if (before) {
                    insertBefore(parent, stateNode, before);
                }
                else {
                    appendChild(parent, stateNode);
                }
            }
            else if (tag === HostPortal)
                ;
            else {
                var child = node.child;
                if (child !== null) {
                    insertOrAppendPlacementNode(child, before, parent);
                    var sibling = child.sibling;
                    while (sibling !== null) {
                        insertOrAppendPlacementNode(sibling, before, parent);
                        sibling = sibling.sibling;
                    }
                }
            }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root, returnFiber, deletedFiber) {
            {
                var parent = returnFiber;
                findParent: while (parent !== null) {
                    switch (parent.tag) {
                        case HostComponent:
                            {
                                hostParent = parent.stateNode;
                                hostParentIsContainer = false;
                                break findParent;
                            }
                        case HostRoot:
                            {
                                hostParent = parent.stateNode.containerInfo;
                                hostParentIsContainer = true;
                                break findParent;
                            }
                        case HostPortal:
                            {
                                hostParent = parent.stateNode.containerInfo;
                                hostParentIsContainer = true;
                                break findParent;
                            }
                    }
                    parent = parent.return;
                }
                if (hostParent === null) {
                    throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');
                }
                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
                hostParent = null;
                hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
                commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
                child = child.sibling;
            }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
                case HostComponent:
                    {
                        if (!offscreenSubtreeWasHidden) {
                            safelyDetachRef(deletedFiber, nearestMountedAncestor);
                        }
                    }
                case HostText:
                    {
                        {
                            var prevHostParent = hostParent;
                            var prevHostParentIsContainer = hostParentIsContainer;
                            hostParent = null;
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            hostParent = prevHostParent;
                            hostParentIsContainer = prevHostParentIsContainer;
                            if (hostParent !== null) {
                                if (hostParentIsContainer) {
                                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                                }
                                else {
                                    removeChild(hostParent, deletedFiber.stateNode);
                                }
                            }
                        }
                        return;
                    }
                case DehydratedFragment:
                    {
                        {
                            if (hostParent !== null) {
                                if (hostParentIsContainer) {
                                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                                }
                                else {
                                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                                }
                            }
                        }
                        return;
                    }
                case HostPortal:
                    {
                        {
                            var _prevHostParent = hostParent;
                            var _prevHostParentIsContainer = hostParentIsContainer;
                            hostParent = deletedFiber.stateNode.containerInfo;
                            hostParentIsContainer = true;
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            hostParent = _prevHostParent;
                            hostParentIsContainer = _prevHostParentIsContainer;
                        }
                        return;
                    }
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent:
                    {
                        if (!offscreenSubtreeWasHidden) {
                            var updateQueue = deletedFiber.updateQueue;
                            if (updateQueue !== null) {
                                var lastEffect = updateQueue.lastEffect;
                                if (lastEffect !== null) {
                                    var firstEffect = lastEffect.next;
                                    var effect = firstEffect;
                                    do {
                                        var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                                        if (destroy !== undefined) {
                                            if ((tag & Insertion) !== NoFlags$1) {
                                                safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                                            }
                                            else if ((tag & Layout) !== NoFlags$1) {
                                                {
                                                    markComponentLayoutEffectUnmountStarted(deletedFiber);
                                                }
                                                if (deletedFiber.mode & ProfileMode) {
                                                    startLayoutEffectTimer();
                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                                                    recordLayoutEffectDuration(deletedFiber);
                                                }
                                                else {
                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                                                }
                                                {
                                                    markComponentLayoutEffectUnmountStopped();
                                                }
                                            }
                                        }
                                        effect = effect.next;
                                    } while (effect !== firstEffect);
                                }
                            }
                        }
                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                        return;
                    }
                case ClassComponent:
                    {
                        if (!offscreenSubtreeWasHidden) {
                            safelyDetachRef(deletedFiber, nearestMountedAncestor);
                            var instance = deletedFiber.stateNode;
                            if (typeof instance.componentWillUnmount === 'function') {
                                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                            }
                        }
                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                        return;
                    }
                case ScopeComponent:
                    {
                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                        return;
                    }
                case OffscreenComponent:
                    {
                        if (deletedFiber.mode & ConcurrentMode) {
                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                        }
                        else {
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                        }
                        break;
                    }
                default:
                    {
                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                        return;
                    }
            }
        }
        function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
                var current = finishedWork.alternate;
                if (current !== null) {
                    var prevState = current.memoizedState;
                    if (prevState !== null) {
                        var suspenseInstance = prevState.dehydrated;
                        if (suspenseInstance !== null) {
                            commitHydratedSuspenseInstance(suspenseInstance);
                        }
                    }
                }
            }
        }
        function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
                finishedWork.updateQueue = null;
                var retryCache = finishedWork.stateNode;
                if (retryCache === null) {
                    retryCache = finishedWork.stateNode = new PossiblyWeakSet();
                }
                wakeables.forEach(function (wakeable) {
                    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                    if (!retryCache.has(wakeable)) {
                        retryCache.add(wakeable);
                        {
                            if (isDevToolsPresent) {
                                if (inProgressLanes !== null && inProgressRoot !== null) {
                                    restorePendingUpdaters(inProgressRoot, inProgressLanes);
                                }
                                else {
                                    throw Error('Expected finished root and lanes to be set. This is a bug in React.');
                                }
                            }
                        }
                        wakeable.then(retry, retry);
                    }
                });
            }
        }
        function commitMutationEffects(root, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
                for (var i = 0; i < deletions.length; i++) {
                    var childToDelete = deletions[i];
                    try {
                        commitDeletionEffects(root, parentFiber, childToDelete);
                    }
                    catch (error) {
                        captureCommitPhaseError(childToDelete, parentFiber, error);
                    }
                }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
                var child = parentFiber.child;
                while (child !== null) {
                    setCurrentFiber(child);
                    commitMutationEffectsOnFiber(child, root);
                    child = child.sibling;
                }
            }
            setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
            var current = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        if (flags & Update) {
                            try {
                                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                                commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                            }
                            catch (error) {
                                captureCommitPhaseError(finishedWork, finishedWork.return, error);
                            }
                            if (finishedWork.mode & ProfileMode) {
                                try {
                                    startLayoutEffectTimer();
                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                }
                                catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                }
                                recordLayoutEffectDuration(finishedWork);
                            }
                            else {
                                try {
                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                }
                                catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                }
                            }
                        }
                        return;
                    }
                case ClassComponent:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        if (flags & Ref) {
                            if (current !== null) {
                                safelyDetachRef(current, current.return);
                            }
                        }
                        return;
                    }
                case HostComponent:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        if (flags & Ref) {
                            if (current !== null) {
                                safelyDetachRef(current, current.return);
                            }
                        }
                        {
                            if (finishedWork.flags & ContentReset) {
                                var instance = finishedWork.stateNode;
                                try {
                                    resetTextContent(instance);
                                }
                                catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                }
                            }
                            if (flags & Update) {
                                var _instance4 = finishedWork.stateNode;
                                if (_instance4 != null) {
                                    var newProps = finishedWork.memoizedProps;
                                    var oldProps = current !== null ? current.memoizedProps : newProps;
                                    var type = finishedWork.type;
                                    var updatePayload = finishedWork.updateQueue;
                                    finishedWork.updateQueue = null;
                                    if (updatePayload !== null) {
                                        try {
                                            commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                                        }
                                        catch (error) {
                                            captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                        }
                                    }
                                }
                            }
                        }
                        return;
                    }
                case HostText:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        if (flags & Update) {
                            {
                                if (finishedWork.stateNode === null) {
                                    throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');
                                }
                                var textInstance = finishedWork.stateNode;
                                var newText = finishedWork.memoizedProps;
                                var oldText = current !== null ? current.memoizedProps : newText;
                                try {
                                    commitTextUpdate(textInstance, oldText, newText);
                                }
                                catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                }
                            }
                        }
                        return;
                    }
                case HostRoot:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        if (flags & Update) {
                            {
                                if (current !== null) {
                                    var prevRootState = current.memoizedState;
                                    if (prevRootState.isDehydrated) {
                                        try {
                                            commitHydratedContainer(root.containerInfo);
                                        }
                                        catch (error) {
                                            captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                        }
                                    }
                                }
                            }
                        }
                        return;
                    }
                case HostPortal:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        return;
                    }
                case SuspenseComponent:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        var offscreenFiber = finishedWork.child;
                        if (offscreenFiber.flags & Visibility) {
                            var offscreenInstance = offscreenFiber.stateNode;
                            var newState = offscreenFiber.memoizedState;
                            var isHidden = newState !== null;
                            offscreenInstance.isHidden = isHidden;
                            if (isHidden) {
                                var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                                if (!wasHidden) {
                                    markCommitTimeOfFallback();
                                }
                            }
                        }
                        if (flags & Update) {
                            try {
                                commitSuspenseCallback(finishedWork);
                            }
                            catch (error) {
                                captureCommitPhaseError(finishedWork, finishedWork.return, error);
                            }
                            attachSuspenseRetryListeners(finishedWork);
                        }
                        return;
                    }
                case OffscreenComponent:
                    {
                        var _wasHidden = current !== null && current.memoizedState !== null;
                        if (finishedWork.mode & ConcurrentMode) {
                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                        }
                        else {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                        }
                        commitReconciliationEffects(finishedWork);
                        if (flags & Visibility) {
                            var _offscreenInstance = finishedWork.stateNode;
                            var _newState = finishedWork.memoizedState;
                            var _isHidden = _newState !== null;
                            var offscreenBoundary = finishedWork;
                            _offscreenInstance.isHidden = _isHidden;
                            {
                                if (_isHidden) {
                                    if (!_wasHidden) {
                                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                                            nextEffect = offscreenBoundary;
                                            var offscreenChild = offscreenBoundary.child;
                                            while (offscreenChild !== null) {
                                                nextEffect = offscreenChild;
                                                disappearLayoutEffects_begin(offscreenChild);
                                                offscreenChild = offscreenChild.sibling;
                                            }
                                        }
                                    }
                                }
                            }
                            {
                                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                            }
                        }
                        return;
                    }
                case SuspenseListComponent:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        if (flags & Update) {
                            attachSuspenseRetryListeners(finishedWork);
                        }
                        return;
                    }
                case ScopeComponent:
                    {
                        return;
                    }
                default:
                    {
                        recursivelyTraverseMutationEffects(root, finishedWork);
                        commitReconciliationEffects(finishedWork);
                        return;
                    }
            }
        }
        function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
                try {
                    commitPlacement(finishedWork);
                }
                catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
                finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
                finishedWork.flags &= ~Hydrating;
            }
        }
        function commitLayoutEffects(finishedWork, root, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
                var fiber = nextEffect;
                var firstChild = fiber.child;
                if (fiber.tag === OffscreenComponent && isModernRoot) {
                    var isHidden = fiber.memoizedState !== null;
                    var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                    if (newOffscreenSubtreeIsHidden) {
                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                        continue;
                    }
                    else {
                        var current = fiber.alternate;
                        var wasHidden = current !== null && current.memoizedState !== null;
                        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                            nextEffect = fiber;
                            reappearLayoutEffects_begin(fiber);
                        }
                        var child = firstChild;
                        while (child !== null) {
                            nextEffect = child;
                            commitLayoutEffects_begin(child, root, committedLanes);
                            child = child.sibling;
                        }
                        nextEffect = fiber;
                        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                        continue;
                    }
                }
                if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                    firstChild.return = fiber;
                    nextEffect = firstChild;
                }
                else {
                    commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                }
            }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                if ((fiber.flags & LayoutMask) !== NoFlags) {
                    var current = fiber.alternate;
                    setCurrentFiber(fiber);
                    try {
                        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);
                    }
                    catch (error) {
                        captureCommitPhaseError(fiber, fiber.return, error);
                    }
                    resetCurrentFiber();
                }
                if (fiber === subtreeRoot) {
                    nextEffect = null;
                    return;
                }
                var sibling = fiber.sibling;
                if (sibling !== null) {
                    sibling.return = fiber.return;
                    nextEffect = sibling;
                    return;
                }
                nextEffect = fiber.return;
            }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                var firstChild = fiber.child;
                switch (fiber.tag) {
                    case FunctionComponent:
                    case ForwardRef:
                    case MemoComponent:
                    case SimpleMemoComponent:
                        {
                            if (fiber.mode & ProfileMode) {
                                try {
                                    startLayoutEffectTimer();
                                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                                }
                                finally {
                                    recordLayoutEffectDuration(fiber);
                                }
                            }
                            else {
                                commitHookEffectListUnmount(Layout, fiber, fiber.return);
                            }
                            break;
                        }
                    case ClassComponent:
                        {
                            safelyDetachRef(fiber, fiber.return);
                            var instance = fiber.stateNode;
                            if (typeof instance.componentWillUnmount === 'function') {
                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                            }
                            break;
                        }
                    case HostComponent:
                        {
                            safelyDetachRef(fiber, fiber.return);
                            break;
                        }
                    case OffscreenComponent:
                        {
                            var isHidden = fiber.memoizedState !== null;
                            if (isHidden) {
                                disappearLayoutEffects_complete(subtreeRoot);
                                continue;
                            }
                            break;
                        }
                }
                if (firstChild !== null) {
                    firstChild.return = fiber;
                    nextEffect = firstChild;
                }
                else {
                    disappearLayoutEffects_complete(subtreeRoot);
                }
            }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                if (fiber === subtreeRoot) {
                    nextEffect = null;
                    return;
                }
                var sibling = fiber.sibling;
                if (sibling !== null) {
                    sibling.return = fiber.return;
                    nextEffect = sibling;
                    return;
                }
                nextEffect = fiber.return;
            }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                var firstChild = fiber.child;
                if (fiber.tag === OffscreenComponent) {
                    var isHidden = fiber.memoizedState !== null;
                    if (isHidden) {
                        reappearLayoutEffects_complete(subtreeRoot);
                        continue;
                    }
                }
                if (firstChild !== null) {
                    firstChild.return = fiber;
                    nextEffect = firstChild;
                }
                else {
                    reappearLayoutEffects_complete(subtreeRoot);
                }
            }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                setCurrentFiber(fiber);
                try {
                    reappearLayoutEffectsOnFiber(fiber);
                }
                catch (error) {
                    captureCommitPhaseError(fiber, fiber.return, error);
                }
                resetCurrentFiber();
                if (fiber === subtreeRoot) {
                    nextEffect = null;
                    return;
                }
                var sibling = fiber.sibling;
                if (sibling !== null) {
                    sibling.return = fiber.return;
                    nextEffect = sibling;
                    return;
                }
                nextEffect = fiber.return;
            }
        }
        function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                var firstChild = fiber.child;
                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                    firstChild.return = fiber;
                    nextEffect = firstChild;
                }
                else {
                    commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);
                }
            }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                if ((fiber.flags & Passive) !== NoFlags) {
                    setCurrentFiber(fiber);
                    try {
                        commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);
                    }
                    catch (error) {
                        captureCommitPhaseError(fiber, fiber.return, error);
                    }
                    resetCurrentFiber();
                }
                if (fiber === subtreeRoot) {
                    nextEffect = null;
                    return;
                }
                var sibling = fiber.sibling;
                if (sibling !== null) {
                    sibling.return = fiber.return;
                    nextEffect = sibling;
                    return;
                }
                nextEffect = fiber.return;
            }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent:
                    {
                        if (finishedWork.mode & ProfileMode) {
                            startPassiveEffectTimer();
                            try {
                                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                            }
                            finally {
                                recordPassiveEffectDuration(finishedWork);
                            }
                        }
                        else {
                            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                        }
                        break;
                    }
            }
        }
        function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                var child = fiber.child;
                if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                    var deletions = fiber.deletions;
                    if (deletions !== null) {
                        for (var i = 0; i < deletions.length; i++) {
                            var fiberToDelete = deletions[i];
                            nextEffect = fiberToDelete;
                            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                        }
                        {
                            var previousFiber = fiber.alternate;
                            if (previousFiber !== null) {
                                var detachedChild = previousFiber.child;
                                if (detachedChild !== null) {
                                    previousFiber.child = null;
                                    do {
                                        var detachedSibling = detachedChild.sibling;
                                        detachedChild.sibling = null;
                                        detachedChild = detachedSibling;
                                    } while (detachedChild !== null);
                                }
                            }
                        }
                        nextEffect = fiber;
                    }
                }
                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                    child.return = fiber;
                    nextEffect = child;
                }
                else {
                    commitPassiveUnmountEffects_complete();
                }
            }
        }
        function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                if ((fiber.flags & Passive) !== NoFlags) {
                    setCurrentFiber(fiber);
                    commitPassiveUnmountOnFiber(fiber);
                    resetCurrentFiber();
                }
                var sibling = fiber.sibling;
                if (sibling !== null) {
                    sibling.return = fiber.return;
                    nextEffect = sibling;
                    return;
                }
                nextEffect = fiber.return;
            }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent:
                    {
                        if (finishedWork.mode & ProfileMode) {
                            startPassiveEffectTimer();
                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                            recordPassiveEffectDuration(finishedWork);
                        }
                        else {
                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                        }
                        break;
                    }
            }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                setCurrentFiber(fiber);
                commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
                resetCurrentFiber();
                var child = fiber.child;
                if (child !== null) {
                    child.return = fiber;
                    nextEffect = child;
                }
                else {
                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
                }
            }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
                var fiber = nextEffect;
                var sibling = fiber.sibling;
                var returnFiber = fiber.return;
                {
                    detachFiberAfterEffects(fiber);
                    if (fiber === deletedSubtreeRoot) {
                        nextEffect = null;
                        return;
                    }
                }
                if (sibling !== null) {
                    sibling.return = returnFiber;
                    nextEffect = sibling;
                    return;
                }
                nextEffect = returnFiber;
            }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {
            switch (current.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent:
                    {
                        if (current.mode & ProfileMode) {
                            startPassiveEffectTimer();
                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);
                            recordPassiveEffectDuration(current);
                        }
                        else {
                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);
                        }
                        break;
                    }
            }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
            {
                switch (fiber.tag) {
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            try {
                                commitHookEffectListMount(Layout | HasEffect, fiber);
                            }
                            catch (error) {
                                captureCommitPhaseError(fiber, fiber.return, error);
                            }
                            break;
                        }
                    case ClassComponent:
                        {
                            var instance = fiber.stateNode;
                            try {
                                instance.componentDidMount();
                            }
                            catch (error) {
                                captureCommitPhaseError(fiber, fiber.return, error);
                            }
                            break;
                        }
                }
            }
        }
        function invokePassiveEffectMountInDEV(fiber) {
            {
                switch (fiber.tag) {
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            try {
                                commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                            }
                            catch (error) {
                                captureCommitPhaseError(fiber, fiber.return, error);
                            }
                            break;
                        }
                }
            }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
            {
                switch (fiber.tag) {
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            try {
                                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                            }
                            catch (error) {
                                captureCommitPhaseError(fiber, fiber.return, error);
                            }
                            break;
                        }
                    case ClassComponent:
                        {
                            var instance = fiber.stateNode;
                            if (typeof instance.componentWillUnmount === 'function') {
                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                            }
                            break;
                        }
                }
            }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
            {
                switch (fiber.tag) {
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            try {
                                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                            }
                            catch (error) {
                                captureCommitPhaseError(fiber, fiber.return, error);
                            }
                        }
                }
            }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === 'function' && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor('selector.component');
            HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');
            ROLE_TYPE = symbolFor('selector.role');
            TEST_NAME_TYPE = symbolFor('selector.test_id');
            TEXT_TYPE = symbolFor('selector.text');
        }
        var commitHooks = [];
        function onCommitRoot$1() {
            {
                commitHooks.forEach(function (commitHook) {
                    return commitHook();
                });
            }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
            {
                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;
                var jestIsDefined = typeof jest !== 'undefined';
                return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
        }
        function isConcurrentActEnvironment() {
            {
                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;
                if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                    error('The current testing environment is not configured to support ' + 'act(...)');
                }
                return isReactActEnvironmentGlobal;
            }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = 0;
        var BatchedContext = 1;
        var RenderContext = 2;
        var CommitContext = 4;
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
            return workInProgressRoot;
        }
        function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                return now();
            }
            if (currentEventTime !== NoTimestamp) {
                return currentEventTime;
            }
            currentEventTime = now();
            return currentEventTime;
        }
        function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
                return SyncLane;
            }
            else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
                return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
                if (ReactCurrentBatchConfig$3.transition !== null) {
                    var transition = ReactCurrentBatchConfig$3.transition;
                    if (!transition._updatedFibers) {
                        transition._updatedFibers = new Set();
                    }
                    transition._updatedFibers.add(fiber);
                }
                if (currentEventTransitionLane === NoLane) {
                    currentEventTransitionLane = claimNextTransitionLane();
                }
                return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
                return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
        }
        function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
                return SyncLane;
            }
            return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
                if (isRunningInsertionEffect) {
                    error('useInsertionEffect must not schedule updates.');
                }
            }
            {
                if (isFlushingPassiveEffects) {
                    didScheduleUpdateDuringPassiveEffects = true;
                }
            }
            markRootUpdated(root, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {
                warnAboutRenderPhaseUpdatesInDEV(fiber);
            }
            else {
                {
                    if (isDevToolsPresent) {
                        addFiberToLanesMap(root, fiber, lane);
                    }
                }
                warnIfUpdatesNotWrappedWithActDEV(fiber);
                if (root === workInProgressRoot) {
                    if ((executionContext & RenderContext) === NoContext) {
                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                    }
                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                        markRootSuspended$1(root, workInProgressRootRenderLanes);
                    }
                }
                ensureRootIsScheduled(root, eventTime);
                if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode &&
                    !(ReactCurrentActQueue$1.isBatchingLegacy)) {
                    resetRenderTimer();
                    flushSyncCallbacksOnlyInLegacyMode();
                }
            }
        }
        function scheduleInitialHydrationOnRoot(root, lane, eventTime) {
            var current = root.current;
            current.lanes = lane;
            markRootUpdated(root, lane, eventTime);
            ensureRootIsScheduled(root, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
            return ((executionContext & RenderContext) !== NoContext);
        }
        function ensureRootIsScheduled(root, currentTime) {
            var existingCallbackNode = root.callbackNode;
            markStarvedLanesAsExpired(root, currentTime);
            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
                if (existingCallbackNode !== null) {
                    cancelCallback$1(existingCallbackNode);
                }
                root.callbackNode = null;
                root.callbackPriority = NoLane;
                return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority &&
                !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
                {
                    if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                        error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');
                    }
                }
                return;
            }
            if (existingCallbackNode != null) {
                cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
                if (root.tag === LegacyRoot) {
                    if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                    }
                    scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
                }
                else {
                    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
                }
                {
                    if (ReactCurrentActQueue$1.current !== null) {
                        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                    }
                    else {
                        scheduleMicrotask(function () {
                            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                                flushSyncCallbacks();
                            }
                        });
                    }
                }
                newCallbackNode = null;
            }
            else {
                var schedulerPriorityLevel;
                switch (lanesToEventPriority(nextLanes)) {
                    case DiscreteEventPriority:
                        schedulerPriorityLevel = ImmediatePriority;
                        break;
                    case ContinuousEventPriority:
                        schedulerPriorityLevel = UserBlockingPriority;
                        break;
                    case DefaultEventPriority:
                        schedulerPriorityLevel = NormalPriority;
                        break;
                    case IdleEventPriority:
                        schedulerPriorityLevel = IdlePriority;
                        break;
                    default:
                        schedulerPriorityLevel = NormalPriority;
                        break;
                }
                newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
            }
            root.callbackPriority = newCallbackPriority;
            root.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root, didTimeout) {
            {
                resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                throw new Error('Should not already be working.');
            }
            var originalCallbackNode = root.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
                if (root.callbackNode !== originalCallbackNode) {
                    return null;
                }
            }
            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
                return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && (!didTimeout);
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
            if (exitStatus !== RootInProgress) {
                if (exitStatus === RootErrored) {
                    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                    if (errorRetryLanes !== NoLanes) {
                        lanes = errorRetryLanes;
                        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
                    }
                }
                if (exitStatus === RootFatalErrored) {
                    var fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root, NoLanes);
                    markRootSuspended$1(root, lanes);
                    ensureRootIsScheduled(root, now());
                    throw fatalError;
                }
                if (exitStatus === RootDidNotComplete) {
                    markRootSuspended$1(root, lanes);
                }
                else {
                    var renderWasConcurrent = !includesBlockingLane(root, lanes);
                    var finishedWork = root.current.alternate;
                    if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                        exitStatus = renderRootSync(root, lanes);
                        if (exitStatus === RootErrored) {
                            var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                            if (_errorRetryLanes !== NoLanes) {
                                lanes = _errorRetryLanes;
                                exitStatus = recoverFromConcurrentError(root, _errorRetryLanes);
                            }
                        }
                        if (exitStatus === RootFatalErrored) {
                            var _fatalError = workInProgressRootFatalError;
                            prepareFreshStack(root, NoLanes);
                            markRootSuspended$1(root, lanes);
                            ensureRootIsScheduled(root, now());
                            throw _fatalError;
                        }
                    }
                    root.finishedWork = finishedWork;
                    root.finishedLanes = lanes;
                    finishConcurrentRender(root, exitStatus, lanes);
                }
            }
            ensureRootIsScheduled(root, now());
            if (root.callbackNode === originalCallbackNode) {
                return performConcurrentWorkOnRoot.bind(null, root);
            }
            return null;
        }
        function recoverFromConcurrentError(root, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root)) {
                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);
                rootWorkInProgress.flags |= ForceClientRender;
                {
                    errorHydratingContainer(root.containerInfo);
                }
            }
            var exitStatus = renderRootSync(root, errorRetryLanes);
            if (exitStatus !== RootErrored) {
                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
                workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
                if (errorsFromSecondAttempt !== null) {
                    queueRecoverableErrors(errorsFromSecondAttempt);
                }
            }
            return exitStatus;
        }
        function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
                workInProgressRootRecoverableErrors = errors;
            }
            else {
                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
        }
        function finishConcurrentRender(root, exitStatus, lanes) {
            switch (exitStatus) {
                case RootInProgress:
                case RootFatalErrored:
                    {
                        throw new Error('Root did not complete. This is a bug in React.');
                    }
                case RootErrored:
                    {
                        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                        break;
                    }
                case RootSuspended:
                    {
                        markRootSuspended$1(root, lanes);
                        if (includesOnlyRetries(lanes) &&
                            !shouldForceFlushFallbacksInDEV()) {
                            var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                            if (msUntilTimeout > 10) {
                                var nextLanes = getNextLanes(root, NoLanes);
                                if (nextLanes !== NoLanes) {
                                    break;
                                }
                                var suspendedLanes = root.suspendedLanes;
                                if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                                    var eventTime = requestEventTime();
                                    markRootPinged(root, suspendedLanes);
                                    break;
                                }
                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                                break;
                            }
                        }
                        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                        break;
                    }
                case RootSuspendedWithDelay:
                    {
                        markRootSuspended$1(root, lanes);
                        if (includesOnlyTransitions(lanes)) {
                            break;
                        }
                        if (!shouldForceFlushFallbacksInDEV()) {
                            var mostRecentEventTime = getMostRecentEventTime(root, lanes);
                            var eventTimeMs = mostRecentEventTime;
                            var timeElapsedMs = now() - eventTimeMs;
                            var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                            if (_msUntilTimeout > 10) {
                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                                break;
                            }
                        }
                        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                        break;
                    }
                case RootCompleted:
                    {
                        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                        break;
                    }
                default:
                    {
                        throw new Error('Unknown root exit status.');
                    }
            }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
                if (node.flags & StoreConsistency) {
                    var updateQueue = node.updateQueue;
                    if (updateQueue !== null) {
                        var checks = updateQueue.stores;
                        if (checks !== null) {
                            for (var i = 0; i < checks.length; i++) {
                                var check = checks[i];
                                var getSnapshot = check.getSnapshot;
                                var renderedValue = check.value;
                                try {
                                    if (!objectIs(getSnapshot(), renderedValue)) {
                                        return false;
                                    }
                                }
                                catch (error) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                var child = node.child;
                if (node.subtreeFlags & StoreConsistency && child !== null) {
                    child.return = node;
                    node = child;
                    continue;
                }
                if (node === finishedWork) {
                    return true;
                }
                while (node.sibling === null) {
                    if (node.return === null || node.return === finishedWork) {
                        return true;
                    }
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
            return true;
        }
        function markRootSuspended$1(root, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root, suspendedLanes);
        }
        function performSyncWorkOnRoot(root) {
            {
                syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                throw new Error('Should not already be working.');
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
                ensureRootIsScheduled(root, now());
                return null;
            }
            var exitStatus = renderRootSync(root, lanes);
            if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                if (errorRetryLanes !== NoLanes) {
                    lanes = errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
                }
            }
            if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root, NoLanes);
                markRootSuspended$1(root, lanes);
                ensureRootIsScheduled(root, now());
                throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
                throw new Error('Root did not complete. This is a bug in React.');
            }
            var finishedWork = root.current.alternate;
            root.finishedWork = finishedWork;
            root.finishedLanes = lanes;
            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root, now());
            return null;
        }
        function flushRoot(root, lanes) {
            if (lanes !== NoLanes) {
                markRootEntangled(root, mergeLanes(lanes, SyncLane));
                ensureRootIsScheduled(root, now());
                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    resetRenderTimer();
                    flushSyncCallbacks();
                }
            }
        }
        function batchedUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
                return fn(a);
            }
            finally {
                executionContext = prevExecutionContext;
                if (executionContext === NoContext &&
                    !(ReactCurrentActQueue$1.isBatchingLegacy)) {
                    resetRenderTimer();
                    flushSyncCallbacksOnlyInLegacyMode();
                }
            }
        }
        function discreteUpdates(fn, a, b, c, d) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(DiscreteEventPriority);
                return fn(a, b, c, d);
            }
            finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
                if (executionContext === NoContext) {
                    resetRenderTimer();
                }
            }
        }
        function flushSync(fn) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(DiscreteEventPriority);
                if (fn) {
                    return fn();
                }
                else {
                    return undefined;
                }
            }
            finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
                executionContext = prevExecutionContext;
                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                }
            }
        }
        function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root, lanes) {
            root.finishedWork = null;
            root.finishedLanes = NoLanes;
            var timeoutHandle = root.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
                root.timeoutHandle = noTimeout;
                cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
                var interruptedWork = workInProgress.return;
                while (interruptedWork !== null) {
                    var current = interruptedWork.alternate;
                    unwindInterruptedWork(current, interruptedWork);
                    interruptedWork = interruptedWork.return;
                }
            }
            workInProgressRoot = root;
            var rootWorkInProgress = createWorkInProgress(root.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
                ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
        }
        function handleError(root, thrownValue) {
            do {
                var erroredWork = workInProgress;
                try {
                    resetContextDependencies();
                    resetHooksAfterThrow();
                    resetCurrentFiber();
                    ReactCurrentOwner$2.current = null;
                    if (erroredWork === null || erroredWork.return === null) {
                        workInProgressRootExitStatus = RootFatalErrored;
                        workInProgressRootFatalError = thrownValue;
                        workInProgress = null;
                        return;
                    }
                    if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                    }
                    if (enableSchedulingProfiler) {
                        markComponentRenderStopped();
                        if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {
                            var wakeable = thrownValue;
                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                        }
                        else {
                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                        }
                    }
                    throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                    completeUnitOfWork(erroredWork);
                }
                catch (yetAnotherThrownValue) {
                    thrownValue = yetAnotherThrownValue;
                    if (workInProgress === erroredWork && erroredWork !== null) {
                        erroredWork = erroredWork.return;
                        workInProgress = erroredWork;
                    }
                    else {
                        erroredWork = workInProgress;
                    }
                    continue;
                }
                return;
            } while (true);
        }
        function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
                return ContextOnlyDispatcher;
            }
            else {
                return prevDispatcher;
            }
        }
        function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now();
        }
        function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
                workInProgressRootExitStatus = RootSuspended;
            }
        }
        function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
                workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
                markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
        }
        function renderDidError(error) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
                workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
                workInProgressRootConcurrentErrors = [error];
            }
            else {
                workInProgressRootConcurrentErrors.push(error);
            }
        }
        function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
                {
                    if (isDevToolsPresent) {
                        var memoizedUpdaters = root.memoizedUpdaters;
                        if (memoizedUpdaters.size > 0) {
                            restorePendingUpdaters(root, workInProgressRootRenderLanes);
                            memoizedUpdaters.clear();
                        }
                        movePendingFibersToMemoized(root, lanes);
                    }
                }
                workInProgressTransitions = getTransitionsForLanes();
                prepareFreshStack(root, lanes);
            }
            {
                markRenderStarted(lanes);
            }
            do {
                try {
                    workLoopSync();
                    break;
                }
                catch (thrownValue) {
                    handleError(root, thrownValue);
                }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
                throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');
            }
            {
                markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
        }
        function workLoopSync() {
            while (workInProgress !== null) {
                performUnitOfWork(workInProgress);
            }
        }
        function renderRootConcurrent(root, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
                {
                    if (isDevToolsPresent) {
                        var memoizedUpdaters = root.memoizedUpdaters;
                        if (memoizedUpdaters.size > 0) {
                            restorePendingUpdaters(root, workInProgressRootRenderLanes);
                            memoizedUpdaters.clear();
                        }
                        movePendingFibersToMemoized(root, lanes);
                    }
                }
                workInProgressTransitions = getTransitionsForLanes();
                resetRenderTimer();
                prepareFreshStack(root, lanes);
            }
            {
                markRenderStarted(lanes);
            }
            do {
                try {
                    workLoopConcurrent();
                    break;
                }
                catch (thrownValue) {
                    handleError(root, thrownValue);
                }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
                {
                    markRenderYielded();
                }
                return RootInProgress;
            }
            else {
                {
                    markRenderStopped();
                }
                workInProgressRoot = null;
                workInProgressRootRenderLanes = NoLanes;
                return workInProgressRootExitStatus;
            }
        }
        function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
                performUnitOfWork(workInProgress);
            }
        }
        function performUnitOfWork(unitOfWork) {
            var current = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
                startProfilerTimer(unitOfWork);
                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            }
            else {
                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
                completeUnitOfWork(unitOfWork);
            }
            else {
                workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
                var current = completedWork.alternate;
                var returnFiber = completedWork.return;
                if ((completedWork.flags & Incomplete) === NoFlags) {
                    setCurrentFiber(completedWork);
                    var next = void 0;
                    if ((completedWork.mode & ProfileMode) === NoMode) {
                        next = completeWork(current, completedWork, subtreeRenderLanes);
                    }
                    else {
                        startProfilerTimer(completedWork);
                        next = completeWork(current, completedWork, subtreeRenderLanes);
                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                    }
                    resetCurrentFiber();
                    if (next !== null) {
                        workInProgress = next;
                        return;
                    }
                }
                else {
                    var _next = unwindWork(current, completedWork);
                    if (_next !== null) {
                        _next.flags &= HostEffectMask;
                        workInProgress = _next;
                        return;
                    }
                    if ((completedWork.mode & ProfileMode) !== NoMode) {
                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                        var actualDuration = completedWork.actualDuration;
                        var child = completedWork.child;
                        while (child !== null) {
                            actualDuration += child.actualDuration;
                            child = child.sibling;
                        }
                        completedWork.actualDuration = actualDuration;
                    }
                    if (returnFiber !== null) {
                        returnFiber.flags |= Incomplete;
                        returnFiber.subtreeFlags = NoFlags;
                        returnFiber.deletions = null;
                    }
                    else {
                        workInProgressRootExitStatus = RootDidNotComplete;
                        workInProgress = null;
                        return;
                    }
                }
                var siblingFiber = completedWork.sibling;
                if (siblingFiber !== null) {
                    workInProgress = siblingFiber;
                    return;
                }
                completedWork = returnFiber;
                workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
                workInProgressRootExitStatus = RootCompleted;
            }
        }
        function commitRoot(root, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(DiscreteEventPriority);
                commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);
            }
            finally {
                ReactCurrentBatchConfig$3.transition = prevTransition;
                setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
        }
        function commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {
            do {
                flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                throw new Error('Should not already be working.');
            }
            var finishedWork = root.finishedWork;
            var lanes = root.finishedLanes;
            {
                markCommitStarted(lanes);
            }
            if (finishedWork === null) {
                {
                    markCommitStopped();
                }
                return null;
            }
            else {
                {
                    if (lanes === NoLanes) {
                        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');
                    }
                }
            }
            root.finishedWork = null;
            root.finishedLanes = NoLanes;
            if (finishedWork === root.current) {
                throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');
            }
            root.callbackNode = null;
            root.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root, remainingLanes);
            if (root === workInProgressRoot) {
                workInProgressRoot = null;
                workInProgress = null;
                workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
                if (!rootDoesHavePassiveEffects) {
                    rootDoesHavePassiveEffects = true;
                    pendingPassiveTransitions = transitions;
                    scheduleCallback$1(NormalPriority, function () {
                        flushPassiveEffects();
                        return null;
                    });
                }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
                var prevTransition = ReactCurrentBatchConfig$3.transition;
                ReactCurrentBatchConfig$3.transition = null;
                var previousPriority = getCurrentUpdatePriority();
                setCurrentUpdatePriority(DiscreteEventPriority);
                var prevExecutionContext = executionContext;
                executionContext |= CommitContext;
                ReactCurrentOwner$2.current = null;
                var shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);
                {
                    recordCommitTime();
                }
                commitMutationEffects(root, finishedWork, lanes);
                resetAfterCommit(root.containerInfo);
                root.current = finishedWork;
                {
                    markLayoutEffectsStarted(lanes);
                }
                commitLayoutEffects(finishedWork, root, lanes);
                {
                    markLayoutEffectsStopped();
                }
                requestPaint();
                executionContext = prevExecutionContext;
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
            }
            else {
                root.current = finishedWork;
                {
                    recordCommitTime();
                }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = false;
                rootWithPendingPassiveEffects = root;
                pendingPassiveEffectsLanes = lanes;
            }
            else {
                {
                    nestedPassiveUpdateCount = 0;
                    rootWithPassiveNestedUpdates = null;
                }
            }
            remainingLanes = root.pendingLanes;
            if (remainingLanes === NoLanes) {
                legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
                if (!rootDidHavePassiveEffects) {
                    commitDoubleInvokeEffectsInDEV(root.current, false);
                }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
                if (isDevToolsPresent) {
                    root.memoizedUpdaters.clear();
                }
            }
            {
                onCommitRoot$1();
            }
            ensureRootIsScheduled(root, now());
            if (recoverableErrors !== null) {
                var onRecoverableError = root.onRecoverableError;
                for (var i = 0; i < recoverableErrors.length; i++) {
                    var recoverableError = recoverableErrors[i];
                    var componentStack = recoverableError.stack;
                    var digest = recoverableError.digest;
                    onRecoverableError(recoverableError.value, {
                        componentStack: componentStack,
                        digest: digest
                    });
                }
            }
            if (hasUncaughtError) {
                hasUncaughtError = false;
                var error$1 = firstUncaughtError;
                firstUncaughtError = null;
                throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {
                flushPassiveEffects();
            }
            remainingLanes = root.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
                {
                    markNestedUpdateScheduled();
                }
                if (root === rootWithNestedUpdates) {
                    nestedUpdateCount++;
                }
                else {
                    nestedUpdateCount = 0;
                    rootWithNestedUpdates = root;
                }
            }
            else {
                nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
                markCommitStopped();
            }
            return null;
        }
        function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
                var prevTransition = ReactCurrentBatchConfig$3.transition;
                var previousPriority = getCurrentUpdatePriority();
                try {
                    ReactCurrentBatchConfig$3.transition = null;
                    setCurrentUpdatePriority(priority);
                    return flushPassiveEffectsImpl();
                }
                finally {
                    setCurrentUpdatePriority(previousPriority);
                    ReactCurrentBatchConfig$3.transition = prevTransition;
                }
            }
            return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
            {
                pendingPassiveProfilerEffects.push(fiber);
                if (!rootDoesHavePassiveEffects) {
                    rootDoesHavePassiveEffects = true;
                    scheduleCallback$1(NormalPriority, function () {
                        flushPassiveEffects();
                        return null;
                    });
                }
            }
        }
        function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
                return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                throw new Error('Cannot flush passive effects while already rendering.');
            }
            {
                isFlushingPassiveEffects = true;
                didScheduleUpdateDuringPassiveEffects = false;
            }
            {
                markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root.current);
            commitPassiveMountEffects(root, root.current, lanes, transitions);
            {
                var profilerEffects = pendingPassiveProfilerEffects;
                pendingPassiveProfilerEffects = [];
                for (var i = 0; i < profilerEffects.length; i++) {
                    var _fiber = profilerEffects[i];
                    commitPassiveEffectDurations(root, _fiber);
                }
            }
            {
                markPassiveEffectsStopped();
            }
            {
                commitDoubleInvokeEffectsInDEV(root.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
                if (didScheduleUpdateDuringPassiveEffects) {
                    if (root === rootWithPassiveNestedUpdates) {
                        nestedPassiveUpdateCount++;
                    }
                    else {
                        nestedPassiveUpdateCount = 0;
                        rootWithPassiveNestedUpdates = root;
                    }
                }
                else {
                    nestedPassiveUpdateCount = 0;
                }
                isFlushingPassiveEffects = false;
                didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root);
            {
                var stateNode = root.current.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
            }
            return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
        }
        function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
                legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
            }
            else {
                legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
        }
        function prepareToThrowUncaughtError(error) {
            if (!hasUncaughtError) {
                hasUncaughtError = true;
                firstUncaughtError = error;
            }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
            var errorInfo = createCapturedValueAtFiber(error, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root !== null) {
                markRootUpdated(root, SyncLane, eventTime);
                ensureRootIsScheduled(root, eventTime);
            }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
                reportUncaughtErrorInDEV(error$1);
                setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
                return;
            }
            var fiber = null;
            {
                fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
                if (fiber.tag === HostRoot) {
                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                    return;
                }
                else if (fiber.tag === ClassComponent) {
                    var ctor = fiber.type;
                    var instance = fiber.stateNode;
                    if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                        var root = enqueueUpdate(fiber, update, SyncLane);
                        var eventTime = requestEventTime();
                        if (root !== null) {
                            markRootUpdated(root, SyncLane, eventTime);
                            ensureRootIsScheduled(root, eventTime);
                        }
                        return;
                    }
                }
                fiber = fiber.return;
            }
            {
                error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\n\n' + 'Error message:\n\n%s', error$1);
            }
        }
        function pingSuspendedRoot(root, wakeable, pingedLanes) {
            var pingCache = root.pingCache;
            if (pingCache !== null) {
                pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root);
            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                    prepareFreshStack(root, NoLanes);
                }
                else {
                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
                }
            }
            ensureRootIsScheduled(root, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
                retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root !== null) {
                markRootUpdated(root, retryLane, eventTime);
                ensureRootIsScheduled(root, eventTime);
            }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
                case SuspenseComponent:
                    retryCache = boundaryFiber.stateNode;
                    var suspenseState = boundaryFiber.memoizedState;
                    if (suspenseState !== null) {
                        retryLane = suspenseState.retryLane;
                    }
                    break;
                case SuspenseListComponent:
                    retryCache = boundaryFiber.stateNode;
                    break;
                default:
                    throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');
            }
            if (retryCache !== null) {
                retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = null;
                throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');
            }
            {
                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                    nestedPassiveUpdateCount = 0;
                    rootWithPassiveNestedUpdates = null;
                    error('Maximum update depth exceeded. This can happen when a component ' + "calls setState inside useEffect, but useEffect either doesn't " + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');
                }
            }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
            {
                ReactStrictModeWarnings.flushLegacyContextWarning();
                {
                    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
                }
            }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
                setCurrentFiber(fiber);
                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
                if (hasPassiveEffects) {
                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
                }
                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
                if (hasPassiveEffects) {
                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
                }
                resetCurrentFiber();
            }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
                var current = firstChild;
                var subtreeRoot = null;
                while (current !== null) {
                    var primarySubtreeFlag = current.subtreeFlags & fiberFlags;
                    if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {
                        current = current.child;
                    }
                    else {
                        if ((current.flags & fiberFlags) !== NoFlags) {
                            invokeEffectFn(current);
                        }
                        if (current.sibling !== null) {
                            current = current.sibling;
                        }
                        else {
                            current = subtreeRoot = current.return;
                        }
                    }
                }
            }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
                if ((executionContext & RenderContext) !== NoContext) {
                    return;
                }
                if (!(fiber.mode & ConcurrentMode)) {
                    return;
                }
                var tag = fiber.tag;
                if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                    return;
                }
                var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';
                if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                        return;
                    }
                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);
                }
                else {
                    didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
                }
                var previousFiber = current;
                try {
                    setCurrentFiber(fiber);
                    error("Can't perform a React state update on a component that hasn't mounted yet. " + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');
                }
                finally {
                    if (previousFiber) {
                        setCurrentFiber(fiber);
                    }
                    else {
                        resetCurrentFiber();
                    }
                }
            }
        }
        var beginWork$1;
        {
            var dummyFiber = null;
            beginWork$1 = function (current, unitOfWork, lanes) {
                var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
                try {
                    return beginWork(current, unitOfWork, lanes);
                }
                catch (originalError) {
                    if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {
                        throw originalError;
                    }
                    resetContextDependencies();
                    resetHooksAfterThrow();
                    unwindInterruptedWork(current, unitOfWork);
                    assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                    if (unitOfWork.mode & ProfileMode) {
                        startProfilerTimer(unitOfWork);
                    }
                    invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);
                    if (hasCaughtError()) {
                        var replayError = clearCaughtError();
                        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {
                            originalError._suppressLogging = true;
                        }
                    }
                    throw originalError;
                }
            };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
            didWarnAboutUpdateInRenderForAnotherComponent = new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
                if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                    switch (fiber.tag) {
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown';
                                var dedupeKey = renderingComponentName;
                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                                    var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';
                                    error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);
                                }
                                break;
                            }
                        case ClassComponent:
                            {
                                if (!didWarnAboutUpdateInRender) {
                                    error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');
                                    didWarnAboutUpdateInRender = true;
                                }
                                break;
                            }
                    }
                }
            }
        }
        function restorePendingUpdaters(root, lanes) {
            {
                if (isDevToolsPresent) {
                    var memoizedUpdaters = root.memoizedUpdaters;
                    memoizedUpdaters.forEach(function (schedulingFiber) {
                        addFiberToLanesMap(root, schedulingFiber, lanes);
                    });
                }
            }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
            {
                var actQueue = ReactCurrentActQueue$1.current;
                if (actQueue !== null) {
                    actQueue.push(callback);
                    return fakeActCallbackNode;
                }
                else {
                    return scheduleCallback(priorityLevel, callback);
                }
            }
        }
        function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
                return;
            }
            return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
                if (fiber.mode & ConcurrentMode) {
                    if (!isConcurrentActEnvironment()) {
                        return;
                    }
                }
                else {
                    if (!isLegacyActEnvironment()) {
                        return;
                    }
                    if (executionContext !== NoContext) {
                        return;
                    }
                    if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                        return;
                    }
                }
                if (ReactCurrentActQueue$1.current === null) {
                    var previousFiber = current;
                    try {
                        setCurrentFiber(fiber);
                        error('An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));
                    }
                    finally {
                        if (previousFiber) {
                            setCurrentFiber(fiber);
                        }
                        else {
                            resetCurrentFiber();
                        }
                    }
                }
            }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {
            {
                if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                    error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\n\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\n\n' + 'act(() => {\n' + '  /* finish loading suspended data */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');
                }
            }
        }
        function setIsRunningInsertionEffect(isRunning) {
            {
                isRunningInsertionEffect = isRunning;
            }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function (handler) {
            {
                resolveFamily = handler;
            }
        };
        function resolveFunctionForHotReloading(type) {
            {
                if (resolveFamily === null) {
                    return type;
                }
                var family = resolveFamily(type);
                if (family === undefined) {
                    return type;
                }
                return family.current;
            }
        }
        function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
        }
        function resolveForwardRefForHotReloading(type) {
            {
                if (resolveFamily === null) {
                    return type;
                }
                var family = resolveFamily(type);
                if (family === undefined) {
                    if (type !== null && type !== undefined && typeof type.render === 'function') {
                        var currentRender = resolveFunctionForHotReloading(type.render);
                        if (type.render !== currentRender) {
                            var syntheticType = {
                                $$typeof: REACT_FORWARD_REF_TYPE,
                                render: currentRender
                            };
                            if (type.displayName !== undefined) {
                                syntheticType.displayName = type.displayName;
                            }
                            return syntheticType;
                        }
                    }
                    return type;
                }
                return family.current;
            }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
            {
                if (resolveFamily === null) {
                    return false;
                }
                var prevType = fiber.elementType;
                var nextType = element.type;
                var needsCompareFamilies = false;
                var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;
                switch (fiber.tag) {
                    case ClassComponent:
                        {
                            if (typeof nextType === 'function') {
                                needsCompareFamilies = true;
                            }
                            break;
                        }
                    case FunctionComponent:
                        {
                            if (typeof nextType === 'function') {
                                needsCompareFamilies = true;
                            }
                            else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                needsCompareFamilies = true;
                            }
                            break;
                        }
                    case ForwardRef:
                        {
                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                                needsCompareFamilies = true;
                            }
                            else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                needsCompareFamilies = true;
                            }
                            break;
                        }
                    case MemoComponent:
                    case SimpleMemoComponent:
                        {
                            if ($$typeofNextType === REACT_MEMO_TYPE) {
                                needsCompareFamilies = true;
                            }
                            else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                needsCompareFamilies = true;
                            }
                            break;
                        }
                    default:
                        return false;
                }
                if (needsCompareFamilies) {
                    var prevFamily = resolveFamily(prevType);
                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
                        return true;
                    }
                }
                return false;
            }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
            {
                if (resolveFamily === null) {
                    return;
                }
                if (typeof WeakSet !== 'function') {
                    return;
                }
                if (failedBoundaries === null) {
                    failedBoundaries = new WeakSet();
                }
                failedBoundaries.add(fiber);
            }
        }
        var scheduleRefresh = function (root, update) {
            {
                if (resolveFamily === null) {
                    return;
                }
                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
                flushPassiveEffects();
                flushSync(function () {
                    scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
                });
            }
        };
        var scheduleRoot = function (root, element) {
            {
                if (root.context !== emptyContextObject) {
                    return;
                }
                flushPassiveEffects();
                flushSync(function () {
                    updateContainer(element, root, null, null);
                });
            }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
                var candidateType = null;
                switch (tag) {
                    case FunctionComponent:
                    case SimpleMemoComponent:
                    case ClassComponent:
                        candidateType = type;
                        break;
                    case ForwardRef:
                        candidateType = type.render;
                        break;
                }
                if (resolveFamily === null) {
                    throw new Error('Expected resolveFamily to be set during hot reload.');
                }
                var needsRender = false;
                var needsRemount = false;
                if (candidateType !== null) {
                    var family = resolveFamily(candidateType);
                    if (family !== undefined) {
                        if (staleFamilies.has(family)) {
                            needsRemount = true;
                        }
                        else if (updatedFamilies.has(family)) {
                            if (tag === ClassComponent) {
                                needsRemount = true;
                            }
                            else {
                                needsRender = true;
                            }
                        }
                    }
                }
                if (failedBoundaries !== null) {
                    if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                        needsRemount = true;
                    }
                }
                if (needsRemount) {
                    fiber._debugNeedsRemount = true;
                }
                if (needsRemount || needsRender) {
                    var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (_root !== null) {
                        scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                    }
                }
                if (child !== null && !needsRemount) {
                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
                }
                if (sibling !== null) {
                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
                }
            }
        }
        var findHostInstancesForRefresh = function (root, families) {
            {
                var hostInstances = new Set();
                var types = new Set(families.map(function (family) {
                    return family.current;
                }));
                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
                return hostInstances;
            }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
            {
                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
                var candidateType = null;
                switch (tag) {
                    case FunctionComponent:
                    case SimpleMemoComponent:
                    case ClassComponent:
                        candidateType = type;
                        break;
                    case ForwardRef:
                        candidateType = type.render;
                        break;
                }
                var didMatch = false;
                if (candidateType !== null) {
                    if (types.has(candidateType)) {
                        didMatch = true;
                    }
                }
                if (didMatch) {
                    findHostInstancesForFiberShallowly(fiber, hostInstances);
                }
                else {
                    if (child !== null) {
                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                    }
                }
                if (sibling !== null) {
                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
                }
            }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
                if (foundHostInstances) {
                    return;
                }
                var node = fiber;
                while (true) {
                    switch (node.tag) {
                        case HostComponent:
                            hostInstances.add(node.stateNode);
                            return;
                        case HostPortal:
                            hostInstances.add(node.stateNode.containerInfo);
                            return;
                        case HostRoot:
                            hostInstances.add(node.stateNode.containerInfo);
                            return;
                    }
                    if (node.return === null) {
                        throw new Error('Expected to reach root first.');
                    }
                    node = node.return;
                }
            }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
                var node = fiber;
                var foundHostInstances = false;
                while (true) {
                    if (node.tag === HostComponent) {
                        foundHostInstances = true;
                        hostInstances.add(node.stateNode);
                    }
                    else if (node.child !== null) {
                        node.child.return = node;
                        node = node.child;
                        continue;
                    }
                    if (node === fiber) {
                        return foundHostInstances;
                    }
                    while (node.sibling === null) {
                        if (node.return === null || node.return === fiber) {
                            return foundHostInstances;
                        }
                        node = node.return;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                }
            }
            return false;
        }
        var hasBadMapPolyfill;
        {
            hasBadMapPolyfill = false;
            try {
                var nonExtensibleObject = Object.preventExtensions({});
                new Map([[nonExtensibleObject, null]]);
                new Set([nonExtensibleObject]);
            }
            catch (e) {
                hasBadMapPolyfill = true;
            }
        }
        function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
                this.actualDuration = Number.NaN;
                this.actualStartTime = Number.NaN;
                this.selfBaseDuration = Number.NaN;
                this.treeBaseDuration = Number.NaN;
                this.actualDuration = 0;
                this.actualStartTime = -1;
                this.selfBaseDuration = 0;
                this.treeBaseDuration = 0;
            }
            {
                this._debugSource = null;
                this._debugOwner = null;
                this._debugNeedsRemount = false;
                this._debugHookTypes = null;
                if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
                    Object.preventExtensions(this);
                }
            }
        }
        var createFiber = function (tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
        };
        function shouldConstruct$1(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type) {
            return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
        }
        function resolveLazyComponentTag(Component) {
            if (typeof Component === 'function') {
                return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
            }
            else if (Component !== undefined && Component !== null) {
                var $$typeof = Component.$$typeof;
                if ($$typeof === REACT_FORWARD_REF_TYPE) {
                    return ForwardRef;
                }
                if ($$typeof === REACT_MEMO_TYPE) {
                    return MemoComponent;
                }
            }
            return IndeterminateComponent;
        }
        function createWorkInProgress(current, pendingProps) {
            var workInProgress = current.alternate;
            if (workInProgress === null) {
                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
                workInProgress.elementType = current.elementType;
                workInProgress.type = current.type;
                workInProgress.stateNode = current.stateNode;
                {
                    workInProgress._debugSource = current._debugSource;
                    workInProgress._debugOwner = current._debugOwner;
                    workInProgress._debugHookTypes = current._debugHookTypes;
                }
                workInProgress.alternate = current;
                current.alternate = workInProgress;
            }
            else {
                workInProgress.pendingProps = pendingProps;
                workInProgress.type = current.type;
                workInProgress.flags = NoFlags;
                workInProgress.subtreeFlags = NoFlags;
                workInProgress.deletions = null;
                {
                    workInProgress.actualDuration = 0;
                    workInProgress.actualStartTime = -1;
                }
            }
            workInProgress.flags = current.flags & StaticMask;
            workInProgress.childLanes = current.childLanes;
            workInProgress.lanes = current.lanes;
            workInProgress.child = current.child;
            workInProgress.memoizedProps = current.memoizedProps;
            workInProgress.memoizedState = current.memoizedState;
            workInProgress.updateQueue = current.updateQueue;
            var currentDependencies = current.dependencies;
            workInProgress.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
            };
            workInProgress.sibling = current.sibling;
            workInProgress.index = current.index;
            workInProgress.ref = current.ref;
            {
                workInProgress.selfBaseDuration = current.selfBaseDuration;
                workInProgress.treeBaseDuration = current.treeBaseDuration;
            }
            {
                workInProgress._debugNeedsRemount = current._debugNeedsRemount;
                switch (workInProgress.tag) {
                    case IndeterminateComponent:
                    case FunctionComponent:
                    case SimpleMemoComponent:
                        workInProgress.type = resolveFunctionForHotReloading(current.type);
                        break;
                    case ClassComponent:
                        workInProgress.type = resolveClassForHotReloading(current.type);
                        break;
                    case ForwardRef:
                        workInProgress.type = resolveForwardRefForHotReloading(current.type);
                        break;
                }
            }
            return workInProgress;
        }
        function resetWorkInProgress(workInProgress, renderLanes) {
            workInProgress.flags &= StaticMask | Placement;
            var current = workInProgress.alternate;
            if (current === null) {
                workInProgress.childLanes = NoLanes;
                workInProgress.lanes = renderLanes;
                workInProgress.child = null;
                workInProgress.subtreeFlags = NoFlags;
                workInProgress.memoizedProps = null;
                workInProgress.memoizedState = null;
                workInProgress.updateQueue = null;
                workInProgress.dependencies = null;
                workInProgress.stateNode = null;
                {
                    workInProgress.selfBaseDuration = 0;
                    workInProgress.treeBaseDuration = 0;
                }
            }
            else {
                workInProgress.childLanes = current.childLanes;
                workInProgress.lanes = current.lanes;
                workInProgress.child = current.child;
                workInProgress.subtreeFlags = NoFlags;
                workInProgress.deletions = null;
                workInProgress.memoizedProps = current.memoizedProps;
                workInProgress.memoizedState = current.memoizedState;
                workInProgress.updateQueue = current.updateQueue;
                workInProgress.type = current.type;
                var currentDependencies = current.dependencies;
                workInProgress.dependencies = currentDependencies === null ? null : {
                    lanes: currentDependencies.lanes,
                    firstContext: currentDependencies.firstContext
                };
                {
                    workInProgress.selfBaseDuration = current.selfBaseDuration;
                    workInProgress.treeBaseDuration = current.treeBaseDuration;
                }
            }
            return workInProgress;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag === ConcurrentRoot) {
                mode = ConcurrentMode;
                if (isStrictMode === true) {
                    mode |= StrictLegacyMode;
                    {
                        mode |= StrictEffectsMode;
                    }
                }
            }
            else {
                mode = NoMode;
            }
            if (isDevToolsPresent) {
                mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === 'function') {
                if (shouldConstruct$1(type)) {
                    fiberTag = ClassComponent;
                    {
                        resolvedType = resolveClassForHotReloading(resolvedType);
                    }
                }
                else {
                    {
                        resolvedType = resolveFunctionForHotReloading(resolvedType);
                    }
                }
            }
            else if (typeof type === 'string') {
                fiberTag = HostComponent;
            }
            else {
                getTag: switch (type) {
                    case REACT_FRAGMENT_TYPE:
                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                    case REACT_STRICT_MODE_TYPE:
                        fiberTag = Mode;
                        mode |= StrictLegacyMode;
                        if ((mode & ConcurrentMode) !== NoMode) {
                            mode |= StrictEffectsMode;
                        }
                        break;
                    case REACT_PROFILER_TYPE:
                        return createFiberFromProfiler(pendingProps, mode, lanes, key);
                    case REACT_SUSPENSE_TYPE:
                        return createFiberFromSuspense(pendingProps, mode, lanes, key);
                    case REACT_SUSPENSE_LIST_TYPE:
                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                    case REACT_OFFSCREEN_TYPE:
                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                    case REACT_LEGACY_HIDDEN_TYPE:
                    case REACT_SCOPE_TYPE:
                    case REACT_CACHE_TYPE:
                    case REACT_TRACING_MARKER_TYPE:
                    case REACT_DEBUG_TRACING_MODE_TYPE:
                    default:
                        {
                            if (typeof type === 'object' && type !== null) {
                                switch (type.$$typeof) {
                                    case REACT_PROVIDER_TYPE:
                                        fiberTag = ContextProvider;
                                        break getTag;
                                    case REACT_CONTEXT_TYPE:
                                        fiberTag = ContextConsumer;
                                        break getTag;
                                    case REACT_FORWARD_REF_TYPE:
                                        fiberTag = ForwardRef;
                                        {
                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                                        }
                                        break getTag;
                                    case REACT_MEMO_TYPE:
                                        fiberTag = MemoComponent;
                                        break getTag;
                                    case REACT_LAZY_TYPE:
                                        fiberTag = LazyComponent;
                                        resolvedType = null;
                                        break getTag;
                                }
                            }
                            var info = '';
                            {
                                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                                    info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
                                }
                                var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                                if (ownerName) {
                                    info += '\n\nCheck the render method of `' + ownerName + '`.';
                                }
                            }
                            throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + ("but got: " + (type == null ? type : typeof type) + "." + info));
                        }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
                fiber._debugOwner = owner;
            }
            return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
                owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
                fiber._debugSource = element._source;
                fiber._debugOwner = element._owner;
            }
            return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
                if (typeof pendingProps.id !== 'string') {
                    error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
                }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
                fiber.stateNode = {
                    effectDuration: 0,
                    passiveEffectDuration: 0
                };
            }
            return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
                isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
        }
        function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = 'DELETED';
            return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
                containerInfo: portal.containerInfo,
                pendingChildren: null,
                implementation: portal.implementation
            };
            return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
                target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
                target.actualDuration = source.actualDuration;
                target.actualStartTime = source.actualStartTime;
                target.selfBaseDuration = source.selfBaseDuration;
                target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
                this.mutableSourceEagerHydrationData = null;
            }
            {
                this.effectDuration = 0;
                this.passiveEffectDuration = 0;
            }
            {
                this.memoizedUpdaters = new Set();
                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
                for (var _i = 0; _i < TotalLanes; _i++) {
                    pendingUpdatersLaneMap.push(new Set());
                }
            }
            {
                switch (tag) {
                    case ConcurrentRoot:
                        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';
                        break;
                    case LegacyRoot:
                        this._debugRootType = hydrate ? 'hydrate()' : 'render()';
                        break;
                }
            }
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root.current = uninitializedFiber;
            uninitializedFiber.stateNode = root;
            {
                var _initialState = {
                    element: initialChildren,
                    isDehydrated: hydrate,
                    cache: null,
                    transitions: null,
                    pendingSuspenseBoundaries: null
                };
                uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root;
        }
        var ReactVersion = '18.3.1';
        function createPortal(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            {
                checkKeyStringCoercion(key);
            }
            return {
                $$typeof: REACT_PORTAL_TYPE,
                key: key == null ? null : '' + key,
                children: children,
                containerInfo: containerInfo,
                implementation: implementation
            };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
                return emptyContextObject;
            }
            var fiber = get(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
                var Component = fiber.type;
                if (isContextProvider(Component)) {
                    return processChildContext(fiber, Component, parentContext);
                }
            }
            return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
            {
                var fiber = get(component);
                if (fiber === undefined) {
                    if (typeof component.render === 'function') {
                        throw new Error('Unable to find node on an unmounted component.');
                    }
                    else {
                        var keys = Object.keys(component).join(',');
                        throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                    }
                }
                var hostFiber = findCurrentHostFiber(fiber);
                if (hostFiber === null) {
                    return null;
                }
                if (hostFiber.mode & StrictLegacyMode) {
                    var componentName = getComponentNameFromFiber(fiber) || 'Component';
                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                        didWarnAboutFindNodeInStrictMode[componentName] = true;
                        var previousFiber = current;
                        try {
                            setCurrentFiber(hostFiber);
                            if (fiber.mode & StrictLegacyMode) {
                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
                            }
                            else {
                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
                            }
                        }
                        finally {
                            if (previousFiber) {
                                setCurrentFiber(previousFiber);
                            }
                            else {
                                resetCurrentFiber();
                            }
                        }
                    }
                }
                return hostFiber.stateNode;
            }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate = true;
            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root.context = getContextForSubtree(null);
            var current = root.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current);
            var update = createUpdate(eventTime, lane);
            update.callback = callback !== undefined && callback !== null ? callback : null;
            enqueueUpdate(current, update, lane);
            scheduleInitialHydrationOnRoot(root, lane, eventTime);
            return root;
        }
        function updateContainer(element, container, parentComponent, callback) {
            {
                onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
                markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container.context === null) {
                container.context = context;
            }
            else {
                container.pendingContext = context;
            }
            {
                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                    didWarnAboutNestedUpdates = true;
                    error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');
                }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
                element: element
            };
            callback = callback === undefined ? null : callback;
            if (callback !== null) {
                {
                    if (typeof callback !== 'function') {
                        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
                    }
                }
                update.callback = callback;
            }
            var root = enqueueUpdate(current$1, update, lane);
            if (root !== null) {
                scheduleUpdateOnFiber(root, current$1, lane, eventTime);
                entangleTransitions(root, current$1, lane);
            }
            return lane;
        }
        function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
                return null;
            }
            switch (containerFiber.child.tag) {
                case HostComponent:
                    return getPublicInstance(containerFiber.child.stateNode);
                default:
                    return containerFiber.child.stateNode;
            }
        }
        function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
                case HostRoot:
                    {
                        var root = fiber.stateNode;
                        if (isRootDehydrated(root)) {
                            var lanes = getHighestPriorityPendingLanes(root);
                            flushRoot(root, lanes);
                        }
                        break;
                    }
                case SuspenseComponent:
                    {
                        flushSync(function () {
                            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                            if (root !== null) {
                                var eventTime = requestEventTime();
                                scheduleUpdateOnFiber(root, fiber, SyncLane, eventTime);
                            }
                        });
                        var retryLane = SyncLane;
                        markRetryLaneIfNotHydrated(fiber, retryLane);
                        break;
                    }
            }
        }
        function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
                markRetryLaneImpl(alternate, retryLane);
            }
        }
        function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
                return;
            }
            var lane = SelectiveHydrationLane;
            var root = enqueueConcurrentRenderForLane(fiber, lane);
            if (root !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
                return;
            }
            var lane = requestUpdateLane(fiber);
            var root = enqueueConcurrentRenderForLane(fiber, lane);
            if (root !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
                return null;
            }
            return hostFiber.stateNode;
        }
        var shouldErrorImpl = function (fiber) {
            return null;
        };
        function shouldError(fiber) {
            return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function (fiber) {
            return false;
        };
        function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
            var copyWithDeleteImpl = function (obj, path, index) {
                var key = path[index];
                var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                if (index + 1 === path.length) {
                    if (isArray(updated)) {
                        updated.splice(key, 1);
                    }
                    else {
                        delete updated[key];
                    }
                    return updated;
                }
                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
                return updated;
            };
            var copyWithDelete = function (obj, path) {
                return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function (obj, oldPath, newPath, index) {
                var oldKey = oldPath[index];
                var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                if (index + 1 === oldPath.length) {
                    var newKey = newPath[index];
                    updated[newKey] = updated[oldKey];
                    if (isArray(updated)) {
                        updated.splice(oldKey, 1);
                    }
                    else {
                        delete updated[oldKey];
                    }
                }
                else {
                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
                }
                return updated;
            };
            var copyWithRename = function (obj, oldPath, newPath) {
                if (oldPath.length !== newPath.length) {
                    warn('copyWithRename() expects paths of the same length');
                    return;
                }
                else {
                    for (var i = 0; i < newPath.length - 1; i++) {
                        if (oldPath[i] !== newPath[i]) {
                            warn('copyWithRename() expects paths to be the same except for the deepest key');
                            return;
                        }
                    }
                }
                return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function (obj, path, index, value) {
                if (index >= path.length) {
                    return value;
                }
                var key = path[index];
                var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
                return updated;
            };
            var copyWithSet = function (obj, path, value) {
                return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function (fiber, id) {
                var currentHook = fiber.memoizedState;
                while (currentHook !== null && id > 0) {
                    currentHook = currentHook.next;
                    id--;
                }
                return currentHook;
            };
            overrideHookState = function (fiber, id, path, value) {
                var hook = findHook(fiber, id);
                if (hook !== null) {
                    var newState = copyWithSet(hook.memoizedState, path, value);
                    hook.memoizedState = newState;
                    hook.baseState = newState;
                    fiber.memoizedProps = assign({}, fiber.memoizedProps);
                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                    }
                }
            };
            overrideHookStateDeletePath = function (fiber, id, path) {
                var hook = findHook(fiber, id);
                if (hook !== null) {
                    var newState = copyWithDelete(hook.memoizedState, path);
                    hook.memoizedState = newState;
                    hook.baseState = newState;
                    fiber.memoizedProps = assign({}, fiber.memoizedProps);
                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                    }
                }
            };
            overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
                var hook = findHook(fiber, id);
                if (hook !== null) {
                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                    hook.memoizedState = newState;
                    hook.baseState = newState;
                    fiber.memoizedProps = assign({}, fiber.memoizedProps);
                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                    }
                }
            };
            overrideProps = function (fiber, path, value) {
                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
                if (fiber.alternate) {
                    fiber.alternate.pendingProps = fiber.pendingProps;
                }
                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                }
            };
            overridePropsDeletePath = function (fiber, path) {
                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
                if (fiber.alternate) {
                    fiber.alternate.pendingProps = fiber.pendingProps;
                }
                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                }
            };
            overridePropsRenamePath = function (fiber, oldPath, newPath) {
                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
                if (fiber.alternate) {
                    fiber.alternate.pendingProps = fiber.pendingProps;
                }
                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                }
            };
            scheduleUpdate = function (fiber) {
                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                }
            };
            setErrorHandler = function (newShouldErrorImpl) {
                shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function (newShouldSuspendImpl) {
                shouldSuspendImpl = newShouldSuspendImpl;
            };
        }
        function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
                return null;
            }
            return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance) {
            return null;
        }
        function getCurrentFiberForDevTools() {
            return current;
        }
        function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
                bundleType: devToolsConfig.bundleType,
                version: devToolsConfig.version,
                rendererPackageName: devToolsConfig.rendererPackageName,
                rendererConfig: devToolsConfig.rendererConfig,
                overrideHookState: overrideHookState,
                overrideHookStateDeletePath: overrideHookStateDeletePath,
                overrideHookStateRenamePath: overrideHookStateRenamePath,
                overrideProps: overrideProps,
                overridePropsDeletePath: overridePropsDeletePath,
                overridePropsRenamePath: overridePropsRenamePath,
                setErrorHandler: setErrorHandler,
                setSuspenseHandler: setSuspenseHandler,
                scheduleUpdate: scheduleUpdate,
                currentDispatcherRef: ReactCurrentDispatcher,
                findHostInstanceByFiber: findHostInstanceByFiber,
                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
                findHostInstancesForRefresh: findHostInstancesForRefresh,
                scheduleRefresh: scheduleRefresh,
                scheduleRoot: scheduleRoot,
                setRefreshHandler: setRefreshHandler,
                getCurrentFiber: getCurrentFiberForDevTools,
                reconcilerVersion: ReactVersion
            });
        }
        var defaultOnRecoverableError = typeof reportError === 'function' ?
            reportError : function (error) {
            console['error'](error);
        };
        function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (children) {
            var root = this._internalRoot;
            if (root === null) {
                throw new Error('Cannot update an unmounted root.');
            }
            {
                if (typeof arguments[1] === 'function') {
                    error('render(...): does not support the second callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
                }
                else if (isValidContainer(arguments[1])) {
                    error('You passed a container to the second argument of root.render(...). ' + "You don't need to pass it again since you already passed it to create the root.");
                }
                else if (typeof arguments[1] !== 'undefined') {
                    error('You passed a second argument to root.render(...) but it only accepts ' + 'one argument.');
                }
                var container = root.containerInfo;
                if (container.nodeType !== COMMENT_NODE) {
                    var hostInstance = findHostInstanceWithNoPortals(root.current);
                    if (hostInstance) {
                        if (hostInstance.parentNode !== container) {
                            error('render(...): It looks like the React-rendered content of the ' + 'root container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + "root.unmount() to empty a root's container.");
                        }
                    }
                }
            }
            updateContainer(children, root, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function () {
            {
                if (typeof arguments[0] === 'function') {
                    error('unmount(...): does not support a callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
                }
            }
            var root = this._internalRoot;
            if (root !== null) {
                this._internalRoot = null;
                var container = root.containerInfo;
                {
                    if (isAlreadyRendering()) {
                        error('Attempted to synchronously unmount a root while React was already ' + 'rendering. React cannot finish unmounting the root until the ' + 'current render has completed, which may lead to a race condition.');
                    }
                }
                flushSync(function () {
                    updateContainer(null, root, null, null);
                });
                unmarkContainerAsRoot(container);
            }
        };
        function createRoot(container, options) {
            if (!isValidContainer(container)) {
                throw new Error('createRoot(...): Target container is not a DOM element.');
            }
            warnIfReactDOMContainerInDEV(container);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = '';
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options !== null && options !== undefined) {
                {
                    if (options.hydrate) {
                        warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');
                    }
                    else {
                        if (typeof options === 'object' && options !== null && options.$$typeof === REACT_ELEMENT_TYPE) {
                            error('You passed a JSX element to createRoot. You probably meant to ' + 'call root.render instead. ' + 'Example usage:\n\n' + '  let root = createRoot(domContainer);\n' + '  root.render(<App />);');
                        }
                    }
                }
                if (options.unstable_strictMode === true) {
                    isStrictMode = true;
                }
                if (options.identifierPrefix !== undefined) {
                    identifierPrefix = options.identifierPrefix;
                }
                if (options.onRecoverableError !== undefined) {
                    onRecoverableError = options.onRecoverableError;
                }
                if (options.transitionCallbacks !== undefined) {
                    transitionCallbacks = options.transitionCallbacks;
                }
            }
            var root = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root);
        }
        function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
            if (target) {
                queueExplicitHydrationTarget(target);
            }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container, initialChildren, options) {
            if (!isValidContainer(container)) {
                throw new Error('hydrateRoot(...): Target container is not a DOM element.');
            }
            warnIfReactDOMContainerInDEV(container);
            {
                if (initialChildren === undefined) {
                    error('Must provide initial children as second argument to hydrateRoot. ' + 'Example usage: hydrateRoot(domContainer, <App />)');
                }
            }
            var hydrationCallbacks = options != null ? options : null;
            var mutableSources = options != null && options.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = '';
            var onRecoverableError = defaultOnRecoverableError;
            if (options !== null && options !== undefined) {
                if (options.unstable_strictMode === true) {
                    isStrictMode = true;
                }
                if (options.identifierPrefix !== undefined) {
                    identifierPrefix = options.identifierPrefix;
                }
                if (options.onRecoverableError !== undefined) {
                    onRecoverableError = options.onRecoverableError;
                }
            }
            var root = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root.current, container);
            listenToAllSupportedEvents(container);
            if (mutableSources) {
                for (var i = 0; i < mutableSources.length; i++) {
                    var mutableSource = mutableSources[i];
                    registerMutableSourceForHydration(root, mutableSource);
                }
            }
            return new ReactDOMHydrationRoot(root);
        }
        function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
        }
        function warnIfReactDOMContainerInDEV(container) {
            {
                if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {
                    error('createRoot(): Creating roots directly with document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try using a container element created ' + 'for your app.');
                }
                if (isContainerMarkedAsRoot(container)) {
                    if (container._reactRootContainer) {
                        error('You are calling ReactDOMClient.createRoot() on a container that was previously ' + 'passed to ReactDOM.render(). This is not supported.');
                    }
                    else {
                        error('You are calling ReactDOMClient.createRoot() on a container that ' + 'has already been passed to createRoot() before. Instead, call ' + 'root.render() on the existing root instead if you want to update it.');
                    }
                }
            }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
            topLevelUpdateWarnings = function (container) {
                if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                    var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
                    if (hostInstance) {
                        if (hostInstance.parentNode !== container) {
                            error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
                        }
                    }
                }
                var isRootRenderedBySomeReact = !!container._reactRootContainer;
                var rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
                if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                    error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');
                }
                if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {
                    error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
                }
            };
        }
        function getReactRootElementInContainer(container) {
            if (!container) {
                return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
                return container.documentElement;
            }
            else {
                return container.firstChild;
            }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
                if (typeof callback === 'function') {
                    var originalCallback = callback;
                    callback = function () {
                        var instance = getPublicRootInstance(root);
                        originalCallback.call(instance);
                    };
                }
                var root = createHydrationContainer(initialChildren, callback, container, LegacyRoot, null, false, false, '', noopOnRecoverableError);
                container._reactRootContainer = root;
                markContainerAsRoot(root.current, container);
                var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
                listenToAllSupportedEvents(rootContainerElement);
                flushSync();
                return root;
            }
            else {
                var rootSibling;
                while (rootSibling = container.lastChild) {
                    container.removeChild(rootSibling);
                }
                if (typeof callback === 'function') {
                    var _originalCallback = callback;
                    callback = function () {
                        var instance = getPublicRootInstance(_root);
                        _originalCallback.call(instance);
                    };
                }
                var _root = createContainer(container, LegacyRoot, null, false, false, '', noopOnRecoverableError);
                container._reactRootContainer = _root;
                markContainerAsRoot(_root.current, container);
                var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
                listenToAllSupportedEvents(_rootContainerElement);
                flushSync(function () {
                    updateContainer(initialChildren, _root, parentComponent, callback);
                });
                return _root;
            }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
            {
                if (callback !== null && typeof callback !== 'function') {
                    error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
                }
            }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
            {
                topLevelUpdateWarnings(container);
                warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');
            }
            var maybeRoot = container._reactRootContainer;
            var root;
            if (!maybeRoot) {
                root = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
            }
            else {
                root = maybeRoot;
                if (typeof callback === 'function') {
                    var originalCallback = callback;
                    callback = function () {
                        var instance = getPublicRootInstance(root);
                        originalCallback.call(instance);
                    };
                }
                updateContainer(children, root, parentComponent, callback);
            }
            return getPublicRootInstance(root);
        }
        var didWarnAboutFindDOMNode = false;
        function findDOMNode(componentOrElement) {
            {
                if (!didWarnAboutFindDOMNode) {
                    didWarnAboutFindDOMNode = true;
                    error('findDOMNode is deprecated and will be removed in the next major ' + 'release. Instead, add a ref directly to the element you want ' + 'to reference. Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node');
                }
                var owner = ReactCurrentOwner$3.current;
                if (owner !== null && owner.stateNode !== null) {
                    var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                    if (!warnedAboutRefsInRender) {
                        error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromType(owner.type) || 'A component');
                    }
                    owner.stateNode._warnedAboutRefsInRender = true;
                }
            }
            if (componentOrElement == null) {
                return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
                return componentOrElement;
            }
            {
                return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
            }
        }
        function hydrate(element, container, callback) {
            {
                error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot ' + 'instead. Until you switch to the new API, your app will behave as ' + "if it's running React 17. Learn " + 'more: https://reactjs.org/link/switch-to-createroot');
            }
            if (!isValidContainerLegacy(container)) {
                throw new Error('Target container is not a DOM element.');
            }
            {
                var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
                if (isModernRoot) {
                    error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOMClient.createRoot(). This is not supported. ' + 'Did you mean to call hydrateRoot(container, element)?');
                }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
        }
        function render(element, container, callback) {
            {
                error('ReactDOM.render is no longer supported in React 18. Use createRoot ' + 'instead. Until you switch to the new API, your app will behave as ' + "if it's running React 17. Learn " + 'more: https://reactjs.org/link/switch-to-createroot');
            }
            if (!isValidContainerLegacy(container)) {
                throw new Error('Target container is not a DOM element.');
            }
            {
                var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
                if (isModernRoot) {
                    error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOMClient.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');
                }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
                error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported ' + 'in React 18. Consider using a portal instead. Until you switch to ' + "the createRoot API, your app will behave as if it's running React " + '17. Learn more: https://reactjs.org/link/switch-to-createroot');
            }
            if (!isValidContainerLegacy(containerNode)) {
                throw new Error('Target container is not a DOM element.');
            }
            if (parentComponent == null || !has(parentComponent)) {
                throw new Error('parentComponent must be a valid React Component');
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        var didWarnAboutUnmountComponentAtNode = false;
        function unmountComponentAtNode(container) {
            {
                if (!didWarnAboutUnmountComponentAtNode) {
                    didWarnAboutUnmountComponentAtNode = true;
                    error('unmountComponentAtNode is deprecated and will be removed in the ' + 'next major release. Switch to the createRoot API. Learn ' + 'more: https://reactjs.org/link/switch-to-createroot');
                }
            }
            if (!isValidContainerLegacy(container)) {
                throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');
            }
            {
                var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
                if (isModernRoot) {
                    error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');
                }
            }
            if (container._reactRootContainer) {
                {
                    var rootEl = getReactRootElementInContainer(container);
                    var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                    if (renderedByDifferentReact) {
                        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
                    }
                }
                flushSync(function () {
                    legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
                        container._reactRootContainer = null;
                        unmarkContainerAsRoot(container);
                    });
                });
                return true;
            }
            else {
                {
                    var _rootEl = getReactRootElementInContainer(container);
                    var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                    var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
                    if (hasNonRootReactChild) {
                        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
                    }
                }
                return false;
            }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
            if (typeof Map !== 'function' ||
                Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' ||
                Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
                error('React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
            }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
        function createPortal$1(children, container) {
            var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            if (!isValidContainer(container)) {
                throw new Error('Target container is not a DOM element.');
            }
            return createPortal(children, container, null, key);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        var Internals = {
            usingClientEntryPoint: false,
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container, options) {
            {
                if (!Internals.usingClientEntryPoint && !false) {
                    error('You are importing createRoot from "react-dom" which is not supported. ' + 'You should instead import it from "react-dom/client".');
                }
            }
            return createRoot(container, options);
        }
        function hydrateRoot$1(container, initialChildren, options) {
            {
                if (!Internals.usingClientEntryPoint && !false) {
                    error('You are importing hydrateRoot from "react-dom" which is not supported. ' + 'You should instead import it from "react-dom/client".');
                }
            }
            return hydrateRoot(container, initialChildren, options);
        }
        function flushSync$1(fn) {
            {
                if (isAlreadyRendering()) {
                    error('flushSync was called from inside a lifecycle method. React cannot ' + 'flush when React is already rendering. Consider moving this call to ' + 'a scheduler task or micro task.');
                }
            }
            return flushSync(fn);
        }
        var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: 'react-dom'
        });
        {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
                if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
                    var protocol = window.location.protocol;
                    if (/^(https?|file):$/.test(protocol)) {
                        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://reactjs.org/link/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://reactjs.org/link/react-devtools-faq' : ''), 'font-weight:bold');
                    }
                }
            }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.createRoot = createRoot$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync$1;
        exports.hydrate = hydrate;
        exports.hydrateRoot = hydrateRoot$1;
        exports.render = render;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
                'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
    })();
}


/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var m = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
if (false) // removed by dead control flow
{}
else {
    var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    exports.createRoot = function (c, o) {
        i.usingClientEntryPoint = true;
        try {
            return m.createRoot(c, o);
        }
        finally {
            i.usingClientEntryPoint = false;
        }
    };
    exports.hydrateRoot = function (c, h, o) {
        i.usingClientEntryPoint = true;
        try {
            return m.hydrateRoot(c, h, o);
        }
        finally {
            i.usingClientEntryPoint = false;
        }
    };
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
        return;
    }
    if (true) {
        throw new Error('^_^');
    }
    // removed by dead control flow
{}
}
if (false) // removed by dead control flow
{}
else {
    module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


if (true) {
    (function () {
        'use strict';
        var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
            {
                {
                    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([stack]);
                }
                var argsWithFormat = args.map(function (item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
            REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        }
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
                    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch (type) {
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
            }
            if (typeof type === 'object') {
                switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            }
                            catch (x) {
                                return null;
                            }
                        }
                }
            }
            return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() { }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    }
                    catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function () {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function () {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        }
                        catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    }
                    else {
                        try {
                            Fake.call();
                        }
                        catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                }
                else {
                    try {
                        throw Error();
                    }
                    catch (x) {
                        control = x;
                    }
                    fn();
                }
            }
            catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                        c--;
                    }
                    for (; s >= 1 && c >= 0; s--, c--) {
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                } while (s >= 1 && c >= 0);
                            }
                            break;
                        }
                    }
                }
            }
            finally {
                reentry = false;
                {
                    ReactCurrentDispatcher.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch (type) {
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch (type.$$typeof) {
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            }
                            catch (x) { }
                        }
                }
            }
            return '';
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame.setExtraStackFrame(stack);
                }
                else {
                    ReactDebugCurrentFrame.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for (var typeSpecName in typeSpecs) {
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        }
                        catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement(null);
                        }
                    }
                }
            }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                }
                catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        function defineKeyPropWarningGetter(props, displayName) {
            {
                var warnAboutAccessingKey = function () {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                };
                warnAboutAccessingKey.isReactWarning = true;
                Object.defineProperty(props, 'key', {
                    get: warnAboutAccessingKey,
                    configurable: true
                });
            }
        }
        function defineRefPropWarningGetter(props, displayName) {
            {
                var warnAboutAccessingRef = function () {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                };
                warnAboutAccessingRef.isReactWarning = true;
                Object.defineProperty(props, 'ref', {
                    get: warnAboutAccessingRef,
                    configurable: true
                });
            }
        }
        var ReactElement = function (type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        };
        function jsxDEV(type, config, maybeKey, source, self) {
            {
                var propName;
                var props = {};
                var key = null;
                var ref = null;
                if (maybeKey !== undefined) {
                    {
                        checkKeyStringCoercion(maybeKey);
                    }
                    key = '' + maybeKey;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                if (hasValidRef(config)) {
                    ref = config.ref;
                    warnIfStringRefCannotBeAutoConverted(config, self);
                }
                for (propName in config) {
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
                if (type && type.defaultProps) {
                    var defaultProps = type.defaultProps;
                    for (propName in defaultProps) {
                        if (props[propName] === undefined) {
                            props[propName] = defaultProps[propName];
                        }
                    }
                }
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
                return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
            }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                }
                else {
                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
            {
                return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
        }
        function getDeclarationErrorAddendum() {
            {
                if (ReactCurrentOwner$1.current) {
                    var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                    if (name) {
                        return '\n\nCheck the render method of `' + name + '`.';
                    }
                }
                return '';
            }
        }
        function getSourceInfoErrorAddendum(source) {
            {
                if (source !== undefined) {
                    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                    var lineNumber = source.lineNumber;
                    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
                }
                return '';
            }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            {
                var info = getDeclarationErrorAddendum();
                if (!info) {
                    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                    if (parentName) {
                        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                    }
                }
                return info;
            }
        }
        function validateExplicitKey(element, parentType) {
            {
                if (!element._store || element._store.validated || element.key != null) {
                    return;
                }
                element._store.validated = true;
                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                    return;
                }
                ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                var childOwner = '';
                if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                    childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
                }
                setCurrentlyValidatingElement$1(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement$1(null);
            }
        }
        function validateChildKeys(node, parentType) {
            {
                if (typeof node !== 'object') {
                    return;
                }
                if (isArray(node)) {
                    for (var i = 0; i < node.length; i++) {
                        var child = node[i];
                        if (isValidElement(child)) {
                            validateExplicitKey(child, parentType);
                        }
                    }
                }
                else if (isValidElement(node)) {
                    if (node._store) {
                        node._store.validated = true;
                    }
                }
                else if (node) {
                    var iteratorFn = getIteratorFn(node);
                    if (typeof iteratorFn === 'function') {
                        if (iteratorFn !== node.entries) {
                            var iterator = iteratorFn.call(node);
                            var step;
                            while (!(step = iterator.next()).done) {
                                if (isValidElement(step.value)) {
                                    validateExplicitKey(step.value, parentType);
                                }
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                }
                else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
                    type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                }
                else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                }
                else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement$1(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement$1(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement$1(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement$1(null);
                }
            }
        }
        var didWarnAboutKeySpread = {};
        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
            {
                var validType = isValidElementType(type);
                if (!validType) {
                    var info = '';
                    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                    }
                    var sourceInfo = getSourceInfoErrorAddendum(source);
                    if (sourceInfo) {
                        info += sourceInfo;
                    }
                    else {
                        info += getDeclarationErrorAddendum();
                    }
                    var typeString;
                    if (type === null) {
                        typeString = 'null';
                    }
                    else if (isArray(type)) {
                        typeString = 'array';
                    }
                    else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                        info = ' Did you accidentally export a JSX literal instead of a component?';
                    }
                    else {
                        typeString = typeof type;
                    }
                    error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
                var element = jsxDEV(type, props, key, source, self);
                if (element == null) {
                    return element;
                }
                if (validType) {
                    var children = props.children;
                    if (children !== undefined) {
                        if (isStaticChildren) {
                            if (isArray(children)) {
                                for (var i = 0; i < children.length; i++) {
                                    validateChildKeys(children[i], type);
                                }
                                if (Object.freeze) {
                                    Object.freeze(children);
                                }
                            }
                            else {
                                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
                            }
                        }
                        else {
                            validateChildKeys(children, type);
                        }
                    }
                }
                {
                    if (hasOwnProperty.call(props, 'key')) {
                        var componentName = getComponentNameFromType(type);
                        var keys = Object.keys(props).filter(function (k) {
                            return k !== 'key';
                        });
                        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';
                        if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                            var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
                            error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                            didWarnAboutKeySpread[componentName + beforeExample] = true;
                        }
                    }
                }
                if (type === REACT_FRAGMENT_TYPE) {
                    validateFragmentProps(element);
                }
                else {
                    validatePropTypes(element);
                }
                return element;
            }
        }
        function jsxWithValidationStatic(type, props, key) {
            {
                return jsxWithValidation(type, props, key, true);
            }
        }
        function jsxWithValidationDynamic(type, props, key) {
            {
                return jsxWithValidation(type, props, key, false);
            }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx;
        exports.jsxs = jsxs;
    })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);

if (true) {
    (function () {
        'use strict';
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
                'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = '18.3.1';
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var ReactCurrentDispatcher = {
            current: null
        };
        var ReactCurrentBatchConfig = {
            transition: null
        };
        var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
            current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
            {
                currentExtraStackFrame = stack;
            }
        }
        {
            ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
                {
                    currentExtraStackFrame = stack;
                }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function () {
                var stack = '';
                if (currentExtraStackFrame) {
                    stack += currentExtraStackFrame;
                }
                var impl = ReactDebugCurrentFrame.getCurrentStack;
                if (impl) {
                    stack += impl() || '';
                }
                return stack;
            };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
            ReactCurrentDispatcher: ReactCurrentDispatcher,
            ReactCurrentBatchConfig: ReactCurrentBatchConfig,
            ReactCurrentOwner: ReactCurrentOwner
        };
        {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
            {
                {
                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([stack]);
                }
                var argsWithFormat = args.map(function (item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
            {
                var _constructor = publicInstance.constructor;
                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
                var warningKey = componentName + "." + callerName;
                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                    return;
                }
                error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
                didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
        }
        var ReactNoopUpdateQueue = {
            isMounted: function (publicInstance) {
                return false;
            },
            enqueueForceUpdate: function (publicInstance, callback, callerName) {
                warnNoop(publicInstance, 'forceUpdate');
            },
            enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
                warnNoop(publicInstance, 'replaceState');
            },
            enqueueSetState: function (publicInstance, partialState, callback, callerName) {
                warnNoop(publicInstance, 'setState');
            }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
            Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function (partialState, callback) {
            if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
                throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
            }
            this.updater.enqueueSetState(this, partialState, callback, 'setState');
        };
        Component.prototype.forceUpdate = function (callback) {
            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
        };
        {
            var deprecatedAPIs = {
                isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
                replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
            };
            var defineDeprecationWarning = function (methodName, info) {
                Object.defineProperty(Component.prototype, methodName, {
                    get: function () {
                        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                        return undefined;
                    }
                });
            };
            for (var fnName in deprecatedAPIs) {
                if (deprecatedAPIs.hasOwnProperty(fnName)) {
                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                }
            }
        }
        function ComponentDummy() { }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
            var refObject = {
                current: null
            };
            {
                Object.seal(refObject);
            }
            return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                }
                catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch (type) {
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
            }
            if (typeof type === 'object') {
                switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            }
                            catch (x) {
                                return null;
                            }
                        }
                }
            }
            return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function () {
                {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, 'key', {
                get: warnAboutAccessingKey,
                configurable: true
            });
        }
        function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function () {
                {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, 'ref', {
                get: warnAboutAccessingRef,
                configurable: true
            });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        var ReactElement = function (type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        };
        function createElement(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self = null;
            var source = null;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    {
                        warnIfStringRefCannotBeAutoConverted(config);
                    }
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                self = config.__self === undefined ? null : config.__self;
                source = config.__source === undefined ? null : config.__source;
                for (propName in config) {
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            }
            else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for (var i = 0; i < childrenLength; i++) {
                    childArray[i] = arguments[i + 2];
                }
                {
                    if (Object.freeze) {
                        Object.freeze(childArray);
                    }
                }
                props.children = childArray;
            }
            if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for (propName in defaultProps) {
                    if (props[propName] === undefined) {
                        props[propName] = defaultProps[propName];
                    }
                }
            }
            {
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
        }
        function cloneElement(element, config, children) {
            if (element === null || element === undefined) {
                throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    owner = ReactCurrentOwner.current;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                var defaultProps;
                if (element.type && element.type.defaultProps) {
                    defaultProps = element.type.defaultProps;
                }
                for (propName in config) {
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        if (config[propName] === undefined && defaultProps !== undefined) {
                            props[propName] = defaultProps[propName];
                        }
                        else {
                            props[propName] = config[propName];
                        }
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            }
            else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for (var i = 0; i < childrenLength; i++) {
                    childArray[i] = arguments[i + 2];
                }
                props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = '.';
        var SUBSEPARATOR = ':';
        function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
                '=': '=0',
                ':': '=2'
            };
            var escapedString = key.replace(escapeRegex, function (match) {
                return escaperLookup[match];
            });
            return '$' + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, '$&/');
        }
        function getElementKey(element, index) {
            if (typeof element === 'object' && element !== null && element.key != null) {
                {
                    checkKeyStringCoercion(element.key);
                }
                return escape('' + element.key);
            }
            return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === 'undefined' || type === 'boolean') {
                children = null;
            }
            var invokeCallback = false;
            if (children === null) {
                invokeCallback = true;
            }
            else {
                switch (type) {
                    case 'string':
                    case 'number':
                        invokeCallback = true;
                        break;
                    case 'object':
                        switch (children.$$typeof) {
                            case REACT_ELEMENT_TYPE:
                            case REACT_PORTAL_TYPE:
                                invokeCallback = true;
                        }
                }
            }
            if (invokeCallback) {
                var _child = children;
                var mappedChild = callback(_child);
                var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
                if (isArray(mappedChild)) {
                    var escapedChildKey = '';
                    if (childKey != null) {
                        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                    }
                    mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
                        return c;
                    });
                }
                else if (mappedChild != null) {
                    if (isValidElement(mappedChild)) {
                        {
                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                                checkKeyStringCoercion(mappedChild.key);
                            }
                        }
                        mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ?
                            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                    }
                    array.push(mappedChild);
                }
                return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    nextName = nextNamePrefix + getElementKey(child, i);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            }
            else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var iterableChildren = children;
                    {
                        if (iteratorFn === iterableChildren.entries) {
                            if (!didWarnAboutMaps) {
                                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                            }
                            didWarnAboutMaps = true;
                        }
                    }
                    var iterator = iteratorFn.call(iterableChildren);
                    var step;
                    var ii = 0;
                    while (!(step = iterator.next()).done) {
                        child = step.value;
                        nextName = nextNamePrefix + getElementKey(child, ii++);
                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                    }
                }
                else if (type === 'object') {
                    var childrenString = String(children);
                    throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
                }
            }
            return subtreeCount;
        }
        function mapChildren(children, func, context) {
            if (children == null) {
                return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, '', '', function (child) {
                return func.call(context, child, count++);
            });
            return result;
        }
        function countChildren(children) {
            var n = 0;
            mapChildren(children, function () {
                n++;
            });
            return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function () {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        }
        function toArray(children) {
            return mapChildren(children, function (child) {
                return child;
            }) || [];
        }
        function onlyChild(children) {
            if (!isValidElement(children)) {
                throw new Error('React.Children.only expected to receive a single React element child.');
            }
            return children;
        }
        function createContext(defaultValue) {
            var context = {
                $$typeof: REACT_CONTEXT_TYPE,
                _currentValue: defaultValue,
                _currentValue2: defaultValue,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
            };
            context.Provider = {
                $$typeof: REACT_PROVIDER_TYPE,
                _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
                var Consumer = {
                    $$typeof: REACT_CONTEXT_TYPE,
                    _context: context
                };
                Object.defineProperties(Consumer, {
                    Provider: {
                        get: function () {
                            if (!hasWarnedAboutUsingConsumerProvider) {
                                hasWarnedAboutUsingConsumerProvider = true;
                                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                            }
                            return context.Provider;
                        },
                        set: function (_Provider) {
                            context.Provider = _Provider;
                        }
                    },
                    _currentValue: {
                        get: function () {
                            return context._currentValue;
                        },
                        set: function (_currentValue) {
                            context._currentValue = _currentValue;
                        }
                    },
                    _currentValue2: {
                        get: function () {
                            return context._currentValue2;
                        },
                        set: function (_currentValue2) {
                            context._currentValue2 = _currentValue2;
                        }
                    },
                    _threadCount: {
                        get: function () {
                            return context._threadCount;
                        },
                        set: function (_threadCount) {
                            context._threadCount = _threadCount;
                        }
                    },
                    Consumer: {
                        get: function () {
                            if (!hasWarnedAboutUsingNestedContextConsumers) {
                                hasWarnedAboutUsingNestedContextConsumers = true;
                                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                            }
                            return context.Consumer;
                        }
                    },
                    displayName: {
                        get: function () {
                            return context.displayName;
                        },
                        set: function (displayName) {
                            if (!hasWarnedAboutDisplayNameOnConsumer) {
                                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                                hasWarnedAboutDisplayNameOnConsumer = true;
                            }
                        }
                    }
                });
                context.Consumer = Consumer;
            }
            {
                context._currentRenderer = null;
                context._currentRenderer2 = null;
            }
            return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
                var ctor = payload._result;
                var thenable = ctor();
                thenable.then(function (moduleObject) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var resolved = payload;
                        resolved._status = Resolved;
                        resolved._result = moduleObject;
                    }
                }, function (error) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var rejected = payload;
                        rejected._status = Rejected;
                        rejected._result = error;
                    }
                });
                if (payload._status === Uninitialized) {
                    var pending = payload;
                    pending._status = Pending;
                    pending._result = thenable;
                }
            }
            if (payload._status === Resolved) {
                var moduleObject = payload._result;
                {
                    if (moduleObject === undefined) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
                            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
                    }
                }
                {
                    if (!('default' in moduleObject)) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
                            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
                    }
                }
                return moduleObject.default;
            }
            else {
                throw payload._result;
            }
        }
        function lazy(ctor) {
            var payload = {
                _status: Uninitialized,
                _result: ctor
            };
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: payload,
                _init: lazyInitializer
            };
            {
                var defaultProps;
                var propTypes;
                Object.defineProperties(lazyType, {
                    defaultProps: {
                        configurable: true,
                        get: function () {
                            return defaultProps;
                        },
                        set: function (newDefaultProps) {
                            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            defaultProps = newDefaultProps;
                            Object.defineProperty(lazyType, 'defaultProps', {
                                enumerable: true
                            });
                        }
                    },
                    propTypes: {
                        configurable: true,
                        get: function () {
                            return propTypes;
                        },
                        set: function (newPropTypes) {
                            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            propTypes = newPropTypes;
                            Object.defineProperty(lazyType, 'propTypes', {
                                enumerable: true
                            });
                        }
                    }
                });
            }
            return lazyType;
        }
        function forwardRef(render) {
            {
                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                    error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
                }
                else if (typeof render !== 'function') {
                    error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
                }
                else {
                    if (render.length !== 0 && render.length !== 2) {
                        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
                    }
                }
                if (render != null) {
                    if (render.defaultProps != null || render.propTypes != null) {
                        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
                    }
                }
            }
            var elementType = {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: render
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function () {
                        return ownName;
                    },
                    set: function (name) {
                        ownName = name;
                        if (!render.name && !render.displayName) {
                            render.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
            REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
        }
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
                    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function memo(type, compare) {
            {
                if (!isValidElementType(type)) {
                    error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
                }
            }
            var elementType = {
                $$typeof: REACT_MEMO_TYPE,
                type: type,
                compare: compare === undefined ? null : compare
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function () {
                        return ownName;
                    },
                    set: function (name) {
                        ownName = name;
                        if (!type.name && !type.displayName) {
                            type.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
                if (dispatcher === null) {
                    error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
                }
            }
            return dispatcher;
        }
        function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
                if (Context._context !== undefined) {
                    var realContext = Context._context;
                    if (realContext.Consumer === Context) {
                        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
                    }
                    else if (realContext.Provider === Context) {
                        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
                    }
                }
            }
            return dispatcher.useContext(Context);
        }
        function useState(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
            {
                var dispatcher = resolveDispatcher();
                return dispatcher.useDebugValue(value, formatterFn);
            }
        }
        function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
        }
        function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() { }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    }
                    catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function () {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function () {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        }
                        catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    }
                    else {
                        try {
                            Fake.call();
                        }
                        catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                }
                else {
                    try {
                        throw Error();
                    }
                    catch (x) {
                        control = x;
                    }
                    fn();
                }
            }
            catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                        c--;
                    }
                    for (; s >= 1 && c >= 0; s--, c--) {
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                } while (s >= 1 && c >= 0);
                            }
                            break;
                        }
                    }
                }
            }
            finally {
                reentry = false;
                {
                    ReactCurrentDispatcher$1.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch (type) {
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch (type.$$typeof) {
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            }
                            catch (x) { }
                        }
                }
            }
            return '';
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                }
                else {
                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for (var typeSpecName in typeSpecs) {
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        }
                        catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement(null);
                        }
                    }
                }
            }
        }
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    setExtraStackFrame(stack);
                }
                else {
                    setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
                var name = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (name) {
                    return '\n\nCheck the render method of `' + name + '`.';
                }
            }
            return '';
        }
        function getSourceInfoErrorAddendum(source) {
            if (source !== undefined) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                var lineNumber = source.lineNumber;
                return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
            }
            return '';
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== undefined) {
                return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return '';
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                    info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
            }
            return info;
        }
        function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
                return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = '';
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
                setCurrentlyValidatingElement$1(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement$1(null);
            }
        }
        function validateChildKeys(node, parentType) {
            if (typeof node !== 'object') {
                return;
            }
            if (isArray(node)) {
                for (var i = 0; i < node.length; i++) {
                    var child = node[i];
                    if (isValidElement(child)) {
                        validateExplicitKey(child, parentType);
                    }
                }
            }
            else if (isValidElement(node)) {
                if (node._store) {
                    node._store.validated = true;
                }
            }
            else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === 'function') {
                    if (iteratorFn !== node.entries) {
                        var iterator = iteratorFn.call(node);
                        var step;
                        while (!(step = iterator.next()).done) {
                            if (isValidElement(step.value)) {
                                validateExplicitKey(step.value, parentType);
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                }
                else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
                    type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                }
                else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                }
                else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement$1(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement$1(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement$1(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement$1(null);
                }
            }
        }
        function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                    info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendumForProps(props);
                if (sourceInfo) {
                    info += sourceInfo;
                }
                else {
                    info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                    typeString = 'null';
                }
                else if (isArray(type)) {
                    typeString = 'array';
                }
                else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                    typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                    info = ' Did you accidentally export a JSX literal instead of a component?';
                }
                else {
                    typeString = typeof type;
                }
                {
                    error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
            }
            var element = createElement.apply(this, arguments);
            if (element == null) {
                return element;
            }
            if (validType) {
                for (var i = 2; i < arguments.length; i++) {
                    validateChildKeys(arguments[i], type);
                }
            }
            if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
            }
            else {
                validatePropTypes(element);
            }
            return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
                if (!didWarnAboutDeprecatedCreateFactory) {
                    didWarnAboutDeprecatedCreateFactory = true;
                    warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
                }
                Object.defineProperty(validatedFactory, 'type', {
                    enumerable: false,
                    get: function () {
                        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
                        Object.defineProperty(this, 'type', {
                            value: type
                        });
                        return type;
                    }
                });
            }
            return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
        }
        function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
                ReactCurrentBatchConfig.transition._updatedFibers = new Set();
            }
            try {
                scope();
            }
            finally {
                ReactCurrentBatchConfig.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                        currentTransition._updatedFibers.clear();
                    }
                }
            }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
                try {
                    var requireString = ('require' + Math.random()).slice(0, 7);
                    var nodeRequire = module && module[requireString];
                    enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
                }
                catch (_err) {
                    enqueueTaskImpl = function (callback) {
                        {
                            if (didWarnAboutMessageChannel === false) {
                                didWarnAboutMessageChannel = true;
                                if (typeof MessageChannel === 'undefined') {
                                    error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
                                }
                            }
                        }
                        var channel = new MessageChannel();
                        channel.port1.onmessage = callback;
                        channel.port2.postMessage(undefined);
                    };
                }
            }
            return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
            {
                var prevActScopeDepth = actScopeDepth;
                actScopeDepth++;
                if (ReactCurrentActQueue.current === null) {
                    ReactCurrentActQueue.current = [];
                }
                var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
                var result;
                try {
                    ReactCurrentActQueue.isBatchingLegacy = true;
                    result = callback();
                    if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                        var queue = ReactCurrentActQueue.current;
                        if (queue !== null) {
                            ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                            flushActQueue(queue);
                        }
                    }
                }
                catch (error) {
                    popActScope(prevActScopeDepth);
                    throw error;
                }
                finally {
                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
                }
                if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
                    var thenableResult = result;
                    var wasAwaited = false;
                    var thenable = {
                        then: function (resolve, reject) {
                            wasAwaited = true;
                            thenableResult.then(function (returnValue) {
                                popActScope(prevActScopeDepth);
                                if (actScopeDepth === 0) {
                                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                }
                                else {
                                    resolve(returnValue);
                                }
                            }, function (error) {
                                popActScope(prevActScopeDepth);
                                reject(error);
                            });
                        }
                    };
                    {
                        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
                            Promise.resolve().then(function () { }).then(function () {
                                if (!wasAwaited) {
                                    didWarnNoAwaitAct = true;
                                    error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
                                }
                            });
                        }
                    }
                    return thenable;
                }
                else {
                    var returnValue = result;
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                        var _queue = ReactCurrentActQueue.current;
                        if (_queue !== null) {
                            flushActQueue(_queue);
                            ReactCurrentActQueue.current = null;
                        }
                        var _thenable = {
                            then: function (resolve, reject) {
                                if (ReactCurrentActQueue.current === null) {
                                    ReactCurrentActQueue.current = [];
                                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                }
                                else {
                                    resolve(returnValue);
                                }
                            }
                        };
                        return _thenable;
                    }
                    else {
                        var _thenable2 = {
                            then: function (resolve, reject) {
                                resolve(returnValue);
                            }
                        };
                        return _thenable2;
                    }
                }
            }
        }
        function popActScope(prevActScopeDepth) {
            {
                if (prevActScopeDepth !== actScopeDepth - 1) {
                    error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
                }
                actScopeDepth = prevActScopeDepth;
            }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                    try {
                        flushActQueue(queue);
                        enqueueTask(function () {
                            if (queue.length === 0) {
                                ReactCurrentActQueue.current = null;
                                resolve(returnValue);
                            }
                            else {
                                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                            }
                        });
                    }
                    catch (error) {
                        reject(error);
                    }
                }
                else {
                    resolve(returnValue);
                }
            }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
            {
                if (!isFlushing) {
                    isFlushing = true;
                    var i = 0;
                    try {
                        for (; i < queue.length; i++) {
                            var callback = queue[i];
                            do {
                                callback = callback(true);
                            } while (callback !== null);
                        }
                        queue.length = 0;
                    }
                    catch (error) {
                        queue = queue.slice(i + 1);
                        throw error;
                    }
                    finally {
                        isFlushing = false;
                    }
                }
            }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray,
            only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.act = act;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
                'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
    })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


if (false) // removed by dead control flow
{}
else {
    module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


if (false) // removed by dead control flow
{}
else {
    module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {


if (true) {
    (function () {
        'use strict';
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
                'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
            var index = heap.length;
            heap.push(node);
            siftUp(heap, node, index);
        }
        function peek(heap) {
            return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
            if (heap.length === 0) {
                return null;
            }
            var first = heap[0];
            var last = heap.pop();
            if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
            }
            return first;
        }
        function siftUp(heap, node, i) {
            var index = i;
            while (index > 0) {
                var parentIndex = index - 1 >>> 1;
                var parent = heap[parentIndex];
                if (compare(parent, node) > 0) {
                    heap[parentIndex] = node;
                    heap[index] = parent;
                    index = parentIndex;
                }
                else {
                    return;
                }
            }
        }
        function siftDown(heap, node, i) {
            var index = i;
            var length = heap.length;
            var halfLength = length >>> 1;
            while (index < halfLength) {
                var leftIndex = (index + 1) * 2 - 1;
                var left = heap[leftIndex];
                var rightIndex = leftIndex + 1;
                var right = heap[rightIndex];
                if (compare(left, node) < 0) {
                    if (rightIndex < length && compare(right, left) < 0) {
                        heap[index] = right;
                        heap[rightIndex] = node;
                        index = rightIndex;
                    }
                    else {
                        heap[index] = left;
                        heap[leftIndex] = node;
                        index = leftIndex;
                    }
                }
                else if (rightIndex < length && compare(right, node) < 0) {
                    heap[index] = right;
                    heap[rightIndex] = node;
                    index = rightIndex;
                }
                else {
                    return;
                }
            }
        }
        function compare(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
        if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function () {
                return localPerformance.now();
            };
        }
        else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function () {
                return localDate.now() - initialTime;
            };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5000;
        var LOW_PRIORITY_TIMEOUT = 10000;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null;
        var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
                if (timer.callback === null) {
                    pop(timerQueue);
                }
                else if (timer.startTime <= currentTime) {
                    pop(timerQueue);
                    timer.sortIndex = timer.expirationTime;
                    push(taskQueue, timer);
                }
                else {
                    return;
                }
                timer = peek(timerQueue);
            }
        }
        function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
                if (peek(taskQueue) !== null) {
                    isHostCallbackScheduled = true;
                    requestHostCallback(flushWork);
                }
                else {
                    var firstTimer = peek(timerQueue);
                    if (firstTimer !== null) {
                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                    }
                }
            }
        }
        function flushWork(hasTimeRemaining, initialTime) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
                isHostTimeoutScheduled = false;
                cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
                if (enableProfiling) {
                    try {
                        return workLoop(hasTimeRemaining, initialTime);
                    }
                    catch (error) {
                        if (currentTask !== null) {
                            var currentTime = exports.unstable_now();
                            markTaskErrored(currentTask, currentTime);
                            currentTask.isQueued = false;
                        }
                        throw error;
                    }
                }
                else {
                    return workLoop(hasTimeRemaining, initialTime);
                }
            }
            finally {
                currentTask = null;
                currentPriorityLevel = previousPriorityLevel;
                isPerformingWork = false;
            }
        }
        function workLoop(hasTimeRemaining, initialTime) {
            var currentTime = initialTime;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !(enableSchedulerDebugging)) {
                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                    break;
                }
                var callback = currentTask.callback;
                if (typeof callback === 'function') {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                    var continuationCallback = callback(didUserCallbackTimeout);
                    currentTime = exports.unstable_now();
                    if (typeof continuationCallback === 'function') {
                        currentTask.callback = continuationCallback;
                    }
                    else {
                        if (currentTask === peek(taskQueue)) {
                            pop(taskQueue);
                        }
                    }
                    advanceTimers(currentTime);
                }
                else {
                    pop(taskQueue);
                }
                currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
                return true;
            }
            else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
                return false;
            }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
                case ImmediatePriority:
                case UserBlockingPriority:
                case NormalPriority:
                case LowPriority:
                case IdlePriority:
                    break;
                default:
                    priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
                return eventHandler();
            }
            finally {
                currentPriorityLevel = previousPriorityLevel;
            }
        }
        function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
                case ImmediatePriority:
                case UserBlockingPriority:
                case NormalPriority:
                    priorityLevel = NormalPriority;
                    break;
                default:
                    priorityLevel = currentPriorityLevel;
                    break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
                return eventHandler();
            }
            finally {
                currentPriorityLevel = previousPriorityLevel;
            }
        }
        function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function () {
                var previousPriorityLevel = currentPriorityLevel;
                currentPriorityLevel = parentPriorityLevel;
                try {
                    return callback.apply(this, arguments);
                }
                finally {
                    currentPriorityLevel = previousPriorityLevel;
                }
            };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime;
            if (typeof options === 'object' && options !== null) {
                var delay = options.delay;
                if (typeof delay === 'number' && delay > 0) {
                    startTime = currentTime + delay;
                }
                else {
                    startTime = currentTime;
                }
            }
            else {
                startTime = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
                case ImmediatePriority:
                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                    break;
                case UserBlockingPriority:
                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                    break;
                case IdlePriority:
                    timeout = IDLE_PRIORITY_TIMEOUT;
                    break;
                case LowPriority:
                    timeout = LOW_PRIORITY_TIMEOUT;
                    break;
                case NormalPriority:
                default:
                    timeout = NORMAL_PRIORITY_TIMEOUT;
                    break;
            }
            var expirationTime = startTime + timeout;
            var newTask = {
                id: taskIdCounter++,
                callback: callback,
                priorityLevel: priorityLevel,
                startTime: startTime,
                expirationTime: expirationTime,
                sortIndex: -1
            };
            if (startTime > currentTime) {
                newTask.sortIndex = startTime;
                push(timerQueue, newTask);
                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                    if (isHostTimeoutScheduled) {
                        cancelHostTimeout();
                    }
                    else {
                        isHostTimeoutScheduled = true;
                    }
                    requestHostTimeout(handleTimeout, startTime - currentTime);
                }
            }
            else {
                newTask.sortIndex = expirationTime;
                push(taskQueue, newTask);
                if (!isHostCallbackScheduled && !isPerformingWork) {
                    isHostCallbackScheduled = true;
                    requestHostCallback(flushWork);
                }
            }
            return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            }
        }
        function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
            task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
                return false;
            }
            return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
                console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
                return;
            }
            if (fps > 0) {
                frameInterval = Math.floor(1000 / fps);
            }
            else {
                frameInterval = frameYieldMs;
            }
        }
        var performWorkUntilDeadline = function () {
            if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now();
                startTime = currentTime;
                var hasTimeRemaining = true;
                var hasMoreWork = true;
                try {
                    hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                }
                finally {
                    if (hasMoreWork) {
                        schedulePerformWorkUntilDeadline();
                    }
                    else {
                        isMessageLoopRunning = false;
                        scheduledHostCallback = null;
                    }
                }
            }
            else {
                isMessageLoopRunning = false;
            }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === 'function') {
            schedulePerformWorkUntilDeadline = function () {
                localSetImmediate(performWorkUntilDeadline);
            };
        }
        else if (typeof MessageChannel !== 'undefined') {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function () {
                port.postMessage(null);
            };
        }
        else {
            schedulePerformWorkUntilDeadline = function () {
                localSetTimeout(performWorkUntilDeadline, 0);
            };
        }
        function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                schedulePerformWorkUntilDeadline();
            }
        }
        function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function () {
                callback(exports.unstable_now());
            }, ms);
        }
        function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
                'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
    })();
}


/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


if (false) // removed by dead control flow
{}
else {
    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ }),

/***/ "./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StyleModule: () => (/* binding */ StyleModule)
/* harmony export */ });
const C = "\u037c";
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
    constructor(spec, options) {
        this.rules = [];
        let { finish } = options || {};
        function splitSelector(selector) {
            return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
        }
        function render(selectors, spec, target, isKeyframes) {
            let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
            if (isAt && spec == null)
                return target.push(selectors[0] + ";");
            for (let prop in spec) {
                let value = spec[prop];
                if (/&/.test(prop)) {
                    render(prop.split(/,\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
                }
                else if (value && typeof value == "object") {
                    if (!isAt)
                        throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
                    render(splitSelector(prop), value, local, keyframes);
                }
                else if (value != null) {
                    local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, l => "-" + l.toLowerCase()) + ": " + value + ";");
                }
            }
            if (local.length || keyframes) {
                target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") +
                    " {" + local.join(" ") + "}");
            }
        }
        for (let prop in spec)
            render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() { return this.rules.join("\n"); }
    static newName() {
        let id = top[COUNT] || 1;
        top[COUNT] = id + 1;
        return C + id.toString(36);
    }
    static mount(root, modules, options) {
        let set = root[SET], nonce = options && options.nonce;
        if (!set)
            set = new StyleSet(root, nonce);
        else if (nonce)
            set.setNonce(nonce);
        set.mount(Array.isArray(modules) ? modules : [modules], root);
    }
}
let adoptedSet = new Map;
class StyleSet {
    constructor(root, nonce) {
        let doc = root.ownerDocument || root, win = doc.defaultView;
        if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
            let adopted = adoptedSet.get(doc);
            if (adopted)
                return root[SET] = adopted;
            this.sheet = new win.CSSStyleSheet;
            adoptedSet.set(doc, this);
        }
        else {
            this.styleTag = doc.createElement("style");
            if (nonce)
                this.styleTag.setAttribute("nonce", nonce);
        }
        this.modules = [];
        root[SET] = this;
    }
    mount(modules, root) {
        let sheet = this.sheet;
        let pos = 0, j = 0;
        for (let i = 0; i < modules.length; i++) {
            let mod = modules[i], index = this.modules.indexOf(mod);
            if (index < j && index > -1) {
                this.modules.splice(index, 1);
                j--;
                index = -1;
            }
            if (index == -1) {
                this.modules.splice(j++, 0, mod);
                if (sheet)
                    for (let k = 0; k < mod.rules.length; k++)
                        sheet.insertRule(mod.rules[k], pos++);
            }
            else {
                while (j < index)
                    pos += this.modules[j++].rules.length;
                pos += mod.rules.length;
                j++;
            }
        }
        if (sheet) {
            if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
                root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
        }
        else {
            let text = "";
            for (let i = 0; i < this.modules.length; i++)
                text += this.modules[i].getRules() + "\n";
            this.styleTag.textContent = text;
            let target = root.head || root;
            if (this.styleTag.parentNode != target)
                target.insertBefore(this.styleTag, target.firstChild);
        }
    }
    setNonce(nonce) {
        if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
            this.styleTag.setAttribute("nonce", nonce);
    }
}


/***/ }),

/***/ "./node_modules/w3c-keyname/index.js":
/*!*******************************************!*\
  !*** ./node_modules/w3c-keyname/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base: () => (/* binding */ base),
/* harmony export */   keyName: () => (/* binding */ keyName),
/* harmony export */   shift: () => (/* binding */ shift)
/* harmony export */ });
var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
};
var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: "\""
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
}
for (var code in base)
    if (!shift.hasOwnProperty(code))
        shift[code] = base[code];
function keyName(event) {
    var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||
        ie && event.shiftKey && event.key && event.key.length == 1 ||
        event.key == "Unidentified";
    var name = (!ignoreKey && event.key) ||
        (event.shiftKey ? shift : base)[event.keyCode] ||
        event.key || "Unidentified";
    if (name == "Esc")
        name = "Escape";
    if (name == "Del")
        name = "Delete";
    if (name == "Left")
        name = "ArrowLeft";
    if (name == "Up")
        name = "ArrowUp";
    if (name == "Right")
        name = "ArrowRight";
    if (name == "Down")
        name = "ArrowDown";
    return name;
}


/***/ }),

/***/ "./node_modules/zustand/esm/middleware.mjs":
/*!*************************************************!*\
  !*** ./node_modules/zustand/esm/middleware.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   combine: () => (/* binding */ combine),
/* harmony export */   createJSONStorage: () => (/* binding */ createJSONStorage),
/* harmony export */   devtools: () => (/* binding */ devtools),
/* harmony export */   persist: () => (/* binding */ persist),
/* harmony export */   redux: () => (/* binding */ redux),
/* harmony export */   subscribeWithSelector: () => (/* binding */ subscribeWithSelector)
/* harmony export */ });
const reduxImpl = (reducer, initial) => (set, _get, api) => {
  api.dispatch = (action) => {
    set((state) => reducer(state, action), false, action);
    return action;
  };
  api.dispatchFromDevtools = true;
  return { dispatch: (...args) => api.dispatch(...args), ...initial };
};
const redux = reduxImpl;

const trackedConnections = /* @__PURE__ */ new Map();
const getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api) return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
const extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
const removeStoreFromTrackedConnections = (name, store) => {
  if (store === void 0) return;
  const connectionInfo = trackedConnections.get(name);
  if (!connectionInfo) return;
  delete connectionInfo.stores[store];
  if (Object.keys(connectionInfo.stores).length === 0) {
    trackedConnections.delete(name);
  }
};
const findCallerName = (stack) => {
  var _a, _b;
  if (!stack) return void 0;
  const traceLines = stack.split("\n");
  const apiSetStateLineIndex = traceLines.findIndex(
    (traceLine) => traceLine.includes("api.setState")
  );
  if (apiSetStateLineIndex < 0) return void 0;
  const callerLine = ((_a = traceLines[apiSetStateLineIndex + 1]) == null ? void 0 : _a.trim()) || "";
  return (_b = /.+ (.+) .+/.exec(callerLine)) == null ? void 0 : _b[1];
};
const devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : ( false ? 0 : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extensionConnector) {
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = (state, replace, nameOrAction) => {
    const r = set(state, replace);
    if (!isRecording) return r;
    const action = nameOrAction === void 0 ? {
      type: anonymousActionType || findCallerName(new Error().stack) || "anonymous"
    } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  };
  api.devtools = {
    cleanup: () => {
      if (connection && typeof connection.unsubscribe === "function") {
        connection.unsubscribe();
      }
      removeStoreFromTrackedConnections(options.name, store);
    }
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...args) => {
      if (( false ? 0 : void 0) !== "production" && args[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...args);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools) return;
            if (typeof api.dispatch !== "function") return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                setStateFromDevtools(state[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState) return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
const devtools = devtoolsImpl;
const parseJsonThen = (stringified, fn) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0) fn(parsed);
};

const subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
const subscribeWithSelector = subscribeWithSelectorImpl;

function combine(initialState, create) {
  return (...args) => Object.assign({}, initialState, create(...args));
}

function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
const persistImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a2;
      return cb((_a2 = get()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            const migration = options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
            if (migration instanceof Promise) {
              return migration.then((result) => [true, result]);
            }
            return [true, migration];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a2;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persist = persistImpl;




/***/ }),

/***/ "./node_modules/zustand/esm/react.mjs":
/*!********************************************!*\
  !*** ./node_modules/zustand/esm/react.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   useStore: () => (/* binding */ useStore)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/vanilla */ "./node_modules/zustand/esm/vanilla.mjs");



const identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createState ? createImpl(createState) : createImpl;




/***/ }),

/***/ "./node_modules/zustand/esm/vanilla.mjs":
/*!**********************************************!*\
  !*** ./node_modules/zustand/esm/vanilla.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStore: () => (/* binding */ createStore)
/* harmony export */ });
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;




/***/ }),

/***/ "./src/@production/ui.tsx":
/*!********************************!*\
  !*** ./src/@production/ui.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UI: () => (/* binding */ UI)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _liqvid_utils_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liqvid/utils/json */ "./node_modules/@liqvid/utils/dist/esm/json.mjs");
/* harmony import */ var _lqv_codebooth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lqv/codebooth */ "./node_modules/@lqv/codebooth/dist/esm/index.mjs");
/* harmony import */ var _lqv_codebooth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lqv/codebooth */ "./node_modules/@lqv/codebooth/dist/esm/components/Replay.mjs");




console.log('Hi there');
function UI() {
    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        (0,_liqvid_utils_json__WEBPACK_IMPORTED_MODULE_2__.loadJSON)('code')
            .then(json => {
            console.log('Replay data loaded:', json);
            setData(json);
        })
            .catch(err => {
            console.error('Failed to load replay data:', err);
        });
    }, []);
    if (!data)
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { children: "Loading replay..." });
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_lqv_codebooth__WEBPACK_IMPORTED_MODULE_3__.CodeBooth, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_lqv_codebooth__WEBPACK_IMPORTED_MODULE_4__.Replay, { replay: (0,_liqvid_utils_json__WEBPACK_IMPORTED_MODULE_2__.loadJSON)('code') }) }));
}


/***/ }),

/***/ "./static/audio.mp4":
/*!**************************!*\
  !*** ./static/audio.mp4 ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "f6ebd4599cb3dd48ca46.mp4";

/***/ }),

/***/ "./static/audio.webm":
/*!***************************!*\
  !*** ./static/audio.webm ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "1b355384e4b03e7991af.webm";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!***********************************!*\
  !*** ./src/@production/index.tsx ***!
  \***********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var liqvid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! liqvid */ "./node_modules/liqvid/dist/esm/index.mjs");
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js");
/* harmony import */ var _static_audio_mp4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../static/audio.mp4 */ "./static/audio.mp4");
/* harmony import */ var _static_audio_webm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../static/audio.webm */ "./static/audio.webm");
/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui */ "./src/@production/ui.tsx");






const playback = new liqvid__WEBPACK_IMPORTED_MODULE_1__.Playback({ duration: 45531.400000002235 });
function Lesson() {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(liqvid__WEBPACK_IMPORTED_MODULE_1__.Player, Object.assign({ playback: playback }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(liqvid__WEBPACK_IMPORTED_MODULE_1__.Audio, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("source", { src: _static_audio_mp4__WEBPACK_IMPORTED_MODULE_3__, type: 'audio/mp4' }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("source", { src: _static_audio_webm__WEBPACK_IMPORTED_MODULE_4__, type: 'audio/webm' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_ui__WEBPACK_IMPORTED_MODULE_5__.UI, {})] })));
}
(0,react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot)(document.querySelector('main')).render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Lesson, {}));

})();

/******/ })()
;